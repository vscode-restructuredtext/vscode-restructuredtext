var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
var __decorateParam = (index, decorator) => (target, key) => decorator(target, key, index);

// node_modules/inversify/lib/constants/metadata_keys.js
var require_metadata_keys = __commonJS({
  "node_modules/inversify/lib/constants/metadata_keys.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NON_CUSTOM_TAG_KEYS = exports.PRE_DESTROY = exports.POST_CONSTRUCT = exports.DESIGN_PARAM_TYPES = exports.PARAM_TYPES = exports.TAGGED_PROP = exports.TAGGED = exports.MULTI_INJECT_TAG = exports.INJECT_TAG = exports.OPTIONAL_TAG = exports.UNMANAGED_TAG = exports.NAME_TAG = exports.NAMED_TAG = void 0;
    exports.NAMED_TAG = "named";
    exports.NAME_TAG = "name";
    exports.UNMANAGED_TAG = "unmanaged";
    exports.OPTIONAL_TAG = "optional";
    exports.INJECT_TAG = "inject";
    exports.MULTI_INJECT_TAG = "multi_inject";
    exports.TAGGED = "inversify:tagged";
    exports.TAGGED_PROP = "inversify:tagged_props";
    exports.PARAM_TYPES = "inversify:paramtypes";
    exports.DESIGN_PARAM_TYPES = "design:paramtypes";
    exports.POST_CONSTRUCT = "post_construct";
    exports.PRE_DESTROY = "pre_destroy";
    function getNonCustomTagKeys() {
      return [
        exports.INJECT_TAG,
        exports.MULTI_INJECT_TAG,
        exports.NAME_TAG,
        exports.UNMANAGED_TAG,
        exports.NAMED_TAG,
        exports.OPTIONAL_TAG
      ];
    }
    exports.NON_CUSTOM_TAG_KEYS = getNonCustomTagKeys();
  }
});

// node_modules/inversify/lib/constants/literal_types.js
var require_literal_types = __commonJS({
  "node_modules/inversify/lib/constants/literal_types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TargetTypeEnum = exports.BindingTypeEnum = exports.BindingScopeEnum = void 0;
    var BindingScopeEnum = {
      Request: "Request",
      Singleton: "Singleton",
      Transient: "Transient"
    };
    exports.BindingScopeEnum = BindingScopeEnum;
    var BindingTypeEnum = {
      ConstantValue: "ConstantValue",
      Constructor: "Constructor",
      DynamicValue: "DynamicValue",
      Factory: "Factory",
      Function: "Function",
      Instance: "Instance",
      Invalid: "Invalid",
      Provider: "Provider"
    };
    exports.BindingTypeEnum = BindingTypeEnum;
    var TargetTypeEnum = {
      ClassProperty: "ClassProperty",
      ConstructorArgument: "ConstructorArgument",
      Variable: "Variable"
    };
    exports.TargetTypeEnum = TargetTypeEnum;
  }
});

// node_modules/inversify/lib/utils/id.js
var require_id = __commonJS({
  "node_modules/inversify/lib/utils/id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.id = void 0;
    var idCounter = 0;
    function id() {
      return idCounter++;
    }
    exports.id = id;
  }
});

// node_modules/inversify/lib/bindings/binding.js
var require_binding = __commonJS({
  "node_modules/inversify/lib/bindings/binding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Binding = void 0;
    var literal_types_1 = require_literal_types();
    var id_1 = require_id();
    var Binding = function() {
      function Binding2(serviceIdentifier, scope) {
        this.id = (0, id_1.id)();
        this.activated = false;
        this.serviceIdentifier = serviceIdentifier;
        this.scope = scope;
        this.type = literal_types_1.BindingTypeEnum.Invalid;
        this.constraint = function(request) {
          return true;
        };
        this.implementationType = null;
        this.cache = null;
        this.factory = null;
        this.provider = null;
        this.onActivation = null;
        this.onDeactivation = null;
        this.dynamicValue = null;
      }
      Binding2.prototype.clone = function() {
        var clone = new Binding2(this.serviceIdentifier, this.scope);
        clone.activated = clone.scope === literal_types_1.BindingScopeEnum.Singleton ? this.activated : false;
        clone.implementationType = this.implementationType;
        clone.dynamicValue = this.dynamicValue;
        clone.scope = this.scope;
        clone.type = this.type;
        clone.factory = this.factory;
        clone.provider = this.provider;
        clone.constraint = this.constraint;
        clone.onActivation = this.onActivation;
        clone.onDeactivation = this.onDeactivation;
        clone.cache = this.cache;
        return clone;
      };
      return Binding2;
    }();
    exports.Binding = Binding;
  }
});

// node_modules/inversify/lib/constants/error_msgs.js
var require_error_msgs = __commonJS({
  "node_modules/inversify/lib/constants/error_msgs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.STACK_OVERFLOW = exports.CIRCULAR_DEPENDENCY_IN_FACTORY = exports.ON_DEACTIVATION_ERROR = exports.PRE_DESTROY_ERROR = exports.POST_CONSTRUCT_ERROR = exports.ASYNC_UNBIND_REQUIRED = exports.MULTIPLE_POST_CONSTRUCT_METHODS = exports.MULTIPLE_PRE_DESTROY_METHODS = exports.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = exports.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = exports.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = exports.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = exports.ARGUMENTS_LENGTH_MISMATCH = exports.INVALID_DECORATOR_OPERATION = exports.INVALID_TO_SELF_VALUE = exports.LAZY_IN_SYNC = exports.INVALID_FUNCTION_BINDING = exports.INVALID_MIDDLEWARE_RETURN = exports.NO_MORE_SNAPSHOTS_AVAILABLE = exports.INVALID_BINDING_TYPE = exports.NOT_IMPLEMENTED = exports.CIRCULAR_DEPENDENCY = exports.UNDEFINED_INJECT_ANNOTATION = exports.MISSING_INJECT_ANNOTATION = exports.MISSING_INJECTABLE_ANNOTATION = exports.NOT_REGISTERED = exports.CANNOT_UNBIND = exports.AMBIGUOUS_MATCH = exports.KEY_NOT_FOUND = exports.NULL_ARGUMENT = exports.DUPLICATED_METADATA = exports.DUPLICATED_INJECTABLE_DECORATOR = void 0;
    exports.DUPLICATED_INJECTABLE_DECORATOR = "Cannot apply @injectable decorator multiple times.";
    exports.DUPLICATED_METADATA = "Metadata key was used more than once in a parameter:";
    exports.NULL_ARGUMENT = "NULL argument";
    exports.KEY_NOT_FOUND = "Key Not Found";
    exports.AMBIGUOUS_MATCH = "Ambiguous match found for serviceIdentifier:";
    exports.CANNOT_UNBIND = "Could not unbind serviceIdentifier:";
    exports.NOT_REGISTERED = "No matching bindings found for serviceIdentifier:";
    exports.MISSING_INJECTABLE_ANNOTATION = "Missing required @injectable annotation in:";
    exports.MISSING_INJECT_ANNOTATION = "Missing required @inject or @multiInject annotation in:";
    var UNDEFINED_INJECT_ANNOTATION = function(name) {
      return "@inject called with undefined this could mean that the class " + name + " has a circular dependency problem. You can use a LazyServiceIdentifer to  overcome this limitation.";
    };
    exports.UNDEFINED_INJECT_ANNOTATION = UNDEFINED_INJECT_ANNOTATION;
    exports.CIRCULAR_DEPENDENCY = "Circular dependency found:";
    exports.NOT_IMPLEMENTED = "Sorry, this feature is not fully implemented yet.";
    exports.INVALID_BINDING_TYPE = "Invalid binding type:";
    exports.NO_MORE_SNAPSHOTS_AVAILABLE = "No snapshot available to restore.";
    exports.INVALID_MIDDLEWARE_RETURN = "Invalid return type in middleware. Middleware must return!";
    exports.INVALID_FUNCTION_BINDING = "Value provided to function binding must be a function!";
    var LAZY_IN_SYNC = function(key) {
      return "You are attempting to construct '" + key + "' in a synchronous way\n but it has asynchronous dependencies.";
    };
    exports.LAZY_IN_SYNC = LAZY_IN_SYNC;
    exports.INVALID_TO_SELF_VALUE = "The toSelf function can only be applied when a constructor is used as service identifier";
    exports.INVALID_DECORATOR_OPERATION = "The @inject @multiInject @tagged and @named decorators must be applied to the parameters of a class constructor or a class property.";
    var ARGUMENTS_LENGTH_MISMATCH = function() {
      var values = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
      }
      return "The number of constructor arguments in the derived class " + (values[0] + " must be >= than the number of constructor arguments of its base class.");
    };
    exports.ARGUMENTS_LENGTH_MISMATCH = ARGUMENTS_LENGTH_MISMATCH;
    exports.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = "Invalid Container constructor argument. Container options must be an object.";
    exports.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = "Invalid Container option. Default scope must be a string ('singleton' or 'transient').";
    exports.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = "Invalid Container option. Auto bind injectable must be a boolean";
    exports.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = "Invalid Container option. Skip base check must be a boolean";
    exports.MULTIPLE_PRE_DESTROY_METHODS = "Cannot apply @preDestroy decorator multiple times in the same class";
    exports.MULTIPLE_POST_CONSTRUCT_METHODS = "Cannot apply @postConstruct decorator multiple times in the same class";
    exports.ASYNC_UNBIND_REQUIRED = "Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)";
    var POST_CONSTRUCT_ERROR = function(clazz, errorMessage) {
      return "@postConstruct error in class " + clazz + ": " + errorMessage;
    };
    exports.POST_CONSTRUCT_ERROR = POST_CONSTRUCT_ERROR;
    var PRE_DESTROY_ERROR = function(clazz, errorMessage) {
      return "@preDestroy error in class " + clazz + ": " + errorMessage;
    };
    exports.PRE_DESTROY_ERROR = PRE_DESTROY_ERROR;
    var ON_DEACTIVATION_ERROR = function(clazz, errorMessage) {
      return "onDeactivation() error in class " + clazz + ": " + errorMessage;
    };
    exports.ON_DEACTIVATION_ERROR = ON_DEACTIVATION_ERROR;
    var CIRCULAR_DEPENDENCY_IN_FACTORY = function(factoryType, serviceIdentifier) {
      return "It looks like there is a circular dependency in one of the '" + factoryType + "' bindings. Please investigate bindings with" + ("service identifier '" + serviceIdentifier + "'.");
    };
    exports.CIRCULAR_DEPENDENCY_IN_FACTORY = CIRCULAR_DEPENDENCY_IN_FACTORY;
    exports.STACK_OVERFLOW = "Maximum call stack size exceeded";
  }
});

// node_modules/inversify/lib/planning/metadata_reader.js
var require_metadata_reader = __commonJS({
  "node_modules/inversify/lib/planning/metadata_reader.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MetadataReader = void 0;
    var METADATA_KEY = __importStar(require_metadata_keys());
    var MetadataReader = function() {
      function MetadataReader2() {
      }
      MetadataReader2.prototype.getConstructorMetadata = function(constructorFunc) {
        var compilerGeneratedMetadata = Reflect.getMetadata(METADATA_KEY.PARAM_TYPES, constructorFunc);
        var userGeneratedMetadata = Reflect.getMetadata(METADATA_KEY.TAGGED, constructorFunc);
        return {
          compilerGeneratedMetadata,
          userGeneratedMetadata: userGeneratedMetadata || {}
        };
      };
      MetadataReader2.prototype.getPropertiesMetadata = function(constructorFunc) {
        var userGeneratedMetadata = Reflect.getMetadata(METADATA_KEY.TAGGED_PROP, constructorFunc) || [];
        return userGeneratedMetadata;
      };
      return MetadataReader2;
    }();
    exports.MetadataReader = MetadataReader;
  }
});

// node_modules/inversify/lib/bindings/binding_count.js
var require_binding_count = __commonJS({
  "node_modules/inversify/lib/bindings/binding_count.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BindingCount = void 0;
    var BindingCount = {
      MultipleBindingsAvailable: 2,
      NoBindingsAvailable: 0,
      OnlyOneBindingAvailable: 1
    };
    exports.BindingCount = BindingCount;
  }
});

// node_modules/inversify/lib/utils/exceptions.js
var require_exceptions = __commonJS({
  "node_modules/inversify/lib/utils/exceptions.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tryAndThrowErrorIfStackOverflow = exports.isStackOverflowExeption = void 0;
    var ERROR_MSGS = __importStar(require_error_msgs());
    function isStackOverflowExeption(error) {
      return error instanceof RangeError || error.message === ERROR_MSGS.STACK_OVERFLOW;
    }
    exports.isStackOverflowExeption = isStackOverflowExeption;
    var tryAndThrowErrorIfStackOverflow = function(fn, errorCallback) {
      try {
        return fn();
      } catch (error) {
        if (isStackOverflowExeption(error)) {
          error = errorCallback();
        }
        throw error;
      }
    };
    exports.tryAndThrowErrorIfStackOverflow = tryAndThrowErrorIfStackOverflow;
  }
});

// node_modules/inversify/lib/utils/serialization.js
var require_serialization = __commonJS({
  "node_modules/inversify/lib/utils/serialization.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSymbolDescription = exports.circularDependencyToException = exports.listMetadataForTarget = exports.listRegisteredBindingsForServiceIdentifier = exports.getServiceIdentifierAsString = exports.getFunctionName = void 0;
    var ERROR_MSGS = __importStar(require_error_msgs());
    function getServiceIdentifierAsString(serviceIdentifier) {
      if (typeof serviceIdentifier === "function") {
        var _serviceIdentifier = serviceIdentifier;
        return _serviceIdentifier.name;
      } else if (typeof serviceIdentifier === "symbol") {
        return serviceIdentifier.toString();
      } else {
        var _serviceIdentifier = serviceIdentifier;
        return _serviceIdentifier;
      }
    }
    exports.getServiceIdentifierAsString = getServiceIdentifierAsString;
    function listRegisteredBindingsForServiceIdentifier(container2, serviceIdentifier, getBindings) {
      var registeredBindingsList = "";
      var registeredBindings = getBindings(container2, serviceIdentifier);
      if (registeredBindings.length !== 0) {
        registeredBindingsList = "\nRegistered bindings:";
        registeredBindings.forEach(function(binding) {
          var name = "Object";
          if (binding.implementationType !== null) {
            name = getFunctionName(binding.implementationType);
          }
          registeredBindingsList = registeredBindingsList + "\n " + name;
          if (binding.constraint.metaData) {
            registeredBindingsList = registeredBindingsList + " - " + binding.constraint.metaData;
          }
        });
      }
      return registeredBindingsList;
    }
    exports.listRegisteredBindingsForServiceIdentifier = listRegisteredBindingsForServiceIdentifier;
    function alreadyDependencyChain(request, serviceIdentifier) {
      if (request.parentRequest === null) {
        return false;
      } else if (request.parentRequest.serviceIdentifier === serviceIdentifier) {
        return true;
      } else {
        return alreadyDependencyChain(request.parentRequest, serviceIdentifier);
      }
    }
    function dependencyChainToString(request) {
      function _createStringArr(req, result) {
        if (result === void 0) {
          result = [];
        }
        var serviceIdentifier = getServiceIdentifierAsString(req.serviceIdentifier);
        result.push(serviceIdentifier);
        if (req.parentRequest !== null) {
          return _createStringArr(req.parentRequest, result);
        }
        return result;
      }
      var stringArr = _createStringArr(request);
      return stringArr.reverse().join(" --> ");
    }
    function circularDependencyToException(request) {
      request.childRequests.forEach(function(childRequest) {
        if (alreadyDependencyChain(childRequest, childRequest.serviceIdentifier)) {
          var services = dependencyChainToString(childRequest);
          throw new Error(ERROR_MSGS.CIRCULAR_DEPENDENCY + " " + services);
        } else {
          circularDependencyToException(childRequest);
        }
      });
    }
    exports.circularDependencyToException = circularDependencyToException;
    function listMetadataForTarget(serviceIdentifierString, target) {
      if (target.isTagged() || target.isNamed()) {
        var m_1 = "";
        var namedTag = target.getNamedTag();
        var otherTags = target.getCustomTags();
        if (namedTag !== null) {
          m_1 += namedTag.toString() + "\n";
        }
        if (otherTags !== null) {
          otherTags.forEach(function(tag) {
            m_1 += tag.toString() + "\n";
          });
        }
        return " " + serviceIdentifierString + "\n " + serviceIdentifierString + " - " + m_1;
      } else {
        return " " + serviceIdentifierString;
      }
    }
    exports.listMetadataForTarget = listMetadataForTarget;
    function getFunctionName(func) {
      if (func.name) {
        return func.name;
      } else {
        var name_1 = func.toString();
        var match = name_1.match(/^function\s*([^\s(]+)/);
        return match ? match[1] : "Anonymous function: " + name_1;
      }
    }
    exports.getFunctionName = getFunctionName;
    function getSymbolDescription(symbol) {
      return symbol.toString().slice(7, -1);
    }
    exports.getSymbolDescription = getSymbolDescription;
  }
});

// node_modules/inversify/lib/planning/context.js
var require_context = __commonJS({
  "node_modules/inversify/lib/planning/context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Context = void 0;
    var id_1 = require_id();
    var Context = function() {
      function Context2(container2) {
        this.id = (0, id_1.id)();
        this.container = container2;
      }
      Context2.prototype.addPlan = function(plan) {
        this.plan = plan;
      };
      Context2.prototype.setCurrentRequest = function(currentRequest) {
        this.currentRequest = currentRequest;
      };
      return Context2;
    }();
    exports.Context = Context;
  }
});

// node_modules/inversify/lib/planning/metadata.js
var require_metadata = __commonJS({
  "node_modules/inversify/lib/planning/metadata.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Metadata = void 0;
    var METADATA_KEY = __importStar(require_metadata_keys());
    var Metadata = function() {
      function Metadata2(key, value) {
        this.key = key;
        this.value = value;
      }
      Metadata2.prototype.toString = function() {
        if (this.key === METADATA_KEY.NAMED_TAG) {
          return "named: " + String(this.value).toString() + " ";
        } else {
          return "tagged: { key:" + this.key.toString() + ", value: " + String(this.value) + " }";
        }
      };
      return Metadata2;
    }();
    exports.Metadata = Metadata;
  }
});

// node_modules/inversify/lib/planning/plan.js
var require_plan = __commonJS({
  "node_modules/inversify/lib/planning/plan.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Plan = void 0;
    var Plan = function() {
      function Plan2(parentContext, rootRequest) {
        this.parentContext = parentContext;
        this.rootRequest = rootRequest;
      }
      return Plan2;
    }();
    exports.Plan = Plan;
  }
});

// node_modules/inversify/lib/annotation/lazy_service_identifier.js
var require_lazy_service_identifier = __commonJS({
  "node_modules/inversify/lib/annotation/lazy_service_identifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LazyServiceIdentifer = void 0;
    var LazyServiceIdentifer = function() {
      function LazyServiceIdentifer2(cb) {
        this._cb = cb;
      }
      LazyServiceIdentifer2.prototype.unwrap = function() {
        return this._cb();
      };
      return LazyServiceIdentifer2;
    }();
    exports.LazyServiceIdentifer = LazyServiceIdentifer;
  }
});

// node_modules/inversify/lib/planning/queryable_string.js
var require_queryable_string = __commonJS({
  "node_modules/inversify/lib/planning/queryable_string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryableString = void 0;
    var QueryableString = function() {
      function QueryableString2(str) {
        this.str = str;
      }
      QueryableString2.prototype.startsWith = function(searchString) {
        return this.str.indexOf(searchString) === 0;
      };
      QueryableString2.prototype.endsWith = function(searchString) {
        var reverseString = "";
        var reverseSearchString = searchString.split("").reverse().join("");
        reverseString = this.str.split("").reverse().join("");
        return this.startsWith.call({ str: reverseString }, reverseSearchString);
      };
      QueryableString2.prototype.contains = function(searchString) {
        return this.str.indexOf(searchString) !== -1;
      };
      QueryableString2.prototype.equals = function(compareString) {
        return this.str === compareString;
      };
      QueryableString2.prototype.value = function() {
        return this.str;
      };
      return QueryableString2;
    }();
    exports.QueryableString = QueryableString;
  }
});

// node_modules/inversify/lib/planning/target.js
var require_target = __commonJS({
  "node_modules/inversify/lib/planning/target.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Target = void 0;
    var METADATA_KEY = __importStar(require_metadata_keys());
    var id_1 = require_id();
    var serialization_1 = require_serialization();
    var metadata_1 = require_metadata();
    var queryable_string_1 = require_queryable_string();
    var Target = function() {
      function Target2(type, identifier, serviceIdentifier, namedOrTagged) {
        this.id = (0, id_1.id)();
        this.type = type;
        this.serviceIdentifier = serviceIdentifier;
        var queryableName = typeof identifier === "symbol" ? (0, serialization_1.getSymbolDescription)(identifier) : identifier;
        this.name = new queryable_string_1.QueryableString(queryableName || "");
        this.identifier = identifier;
        this.metadata = new Array();
        var metadataItem = null;
        if (typeof namedOrTagged === "string") {
          metadataItem = new metadata_1.Metadata(METADATA_KEY.NAMED_TAG, namedOrTagged);
        } else if (namedOrTagged instanceof metadata_1.Metadata) {
          metadataItem = namedOrTagged;
        }
        if (metadataItem !== null) {
          this.metadata.push(metadataItem);
        }
      }
      Target2.prototype.hasTag = function(key) {
        for (var _i = 0, _a = this.metadata; _i < _a.length; _i++) {
          var m = _a[_i];
          if (m.key === key) {
            return true;
          }
        }
        return false;
      };
      Target2.prototype.isArray = function() {
        return this.hasTag(METADATA_KEY.MULTI_INJECT_TAG);
      };
      Target2.prototype.matchesArray = function(name) {
        return this.matchesTag(METADATA_KEY.MULTI_INJECT_TAG)(name);
      };
      Target2.prototype.isNamed = function() {
        return this.hasTag(METADATA_KEY.NAMED_TAG);
      };
      Target2.prototype.isTagged = function() {
        return this.metadata.some(function(metadata) {
          return METADATA_KEY.NON_CUSTOM_TAG_KEYS.every(function(key) {
            return metadata.key !== key;
          });
        });
      };
      Target2.prototype.isOptional = function() {
        return this.matchesTag(METADATA_KEY.OPTIONAL_TAG)(true);
      };
      Target2.prototype.getNamedTag = function() {
        if (this.isNamed()) {
          return this.metadata.filter(function(m) {
            return m.key === METADATA_KEY.NAMED_TAG;
          })[0];
        }
        return null;
      };
      Target2.prototype.getCustomTags = function() {
        if (this.isTagged()) {
          return this.metadata.filter(function(metadata) {
            return METADATA_KEY.NON_CUSTOM_TAG_KEYS.every(function(key) {
              return metadata.key !== key;
            });
          });
        } else {
          return null;
        }
      };
      Target2.prototype.matchesNamedTag = function(name) {
        return this.matchesTag(METADATA_KEY.NAMED_TAG)(name);
      };
      Target2.prototype.matchesTag = function(key) {
        var _this = this;
        return function(value) {
          for (var _i = 0, _a = _this.metadata; _i < _a.length; _i++) {
            var m = _a[_i];
            if (m.key === key && m.value === value) {
              return true;
            }
          }
          return false;
        };
      };
      return Target2;
    }();
    exports.Target = Target;
  }
});

// node_modules/inversify/lib/planning/reflection_utils.js
var require_reflection_utils = __commonJS({
  "node_modules/inversify/lib/planning/reflection_utils.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFunctionName = exports.getBaseClassDependencyCount = exports.getDependencies = void 0;
    var lazy_service_identifier_1 = require_lazy_service_identifier();
    var ERROR_MSGS = __importStar(require_error_msgs());
    var literal_types_1 = require_literal_types();
    var METADATA_KEY = __importStar(require_metadata_keys());
    var serialization_1 = require_serialization();
    Object.defineProperty(exports, "getFunctionName", { enumerable: true, get: function() {
      return serialization_1.getFunctionName;
    } });
    var target_1 = require_target();
    function getDependencies(metadataReader, func) {
      var constructorName = (0, serialization_1.getFunctionName)(func);
      return getTargets(metadataReader, constructorName, func, false);
    }
    exports.getDependencies = getDependencies;
    function getTargets(metadataReader, constructorName, func, isBaseClass) {
      var metadata = metadataReader.getConstructorMetadata(func);
      var serviceIdentifiers = metadata.compilerGeneratedMetadata;
      if (serviceIdentifiers === void 0) {
        var msg = ERROR_MSGS.MISSING_INJECTABLE_ANNOTATION + " " + constructorName + ".";
        throw new Error(msg);
      }
      var constructorArgsMetadata = metadata.userGeneratedMetadata;
      var keys = Object.keys(constructorArgsMetadata);
      var hasUserDeclaredUnknownInjections = func.length === 0 && keys.length > 0;
      var hasOptionalParameters = keys.length > func.length;
      var iterations = hasUserDeclaredUnknownInjections || hasOptionalParameters ? keys.length : func.length;
      var constructorTargets = getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations);
      var propertyTargets = getClassPropsAsTargets(metadataReader, func, constructorName);
      var targets = __spreadArray(__spreadArray([], constructorTargets, true), propertyTargets, true);
      return targets;
    }
    function getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata) {
      var targetMetadata = constructorArgsMetadata[index.toString()] || [];
      var metadata = formatTargetMetadata(targetMetadata);
      var isManaged = metadata.unmanaged !== true;
      var serviceIdentifier = serviceIdentifiers[index];
      var injectIdentifier = metadata.inject || metadata.multiInject;
      serviceIdentifier = injectIdentifier ? injectIdentifier : serviceIdentifier;
      if (serviceIdentifier instanceof lazy_service_identifier_1.LazyServiceIdentifer) {
        serviceIdentifier = serviceIdentifier.unwrap();
      }
      if (isManaged) {
        var isObject = serviceIdentifier === Object;
        var isFunction = serviceIdentifier === Function;
        var isUndefined = serviceIdentifier === void 0;
        var isUnknownType = isObject || isFunction || isUndefined;
        if (!isBaseClass && isUnknownType) {
          var msg = ERROR_MSGS.MISSING_INJECT_ANNOTATION + " argument " + index + " in class " + constructorName + ".";
          throw new Error(msg);
        }
        var target = new target_1.Target(literal_types_1.TargetTypeEnum.ConstructorArgument, metadata.targetName, serviceIdentifier);
        target.metadata = targetMetadata;
        return target;
      }
      return null;
    }
    function getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations) {
      var targets = [];
      for (var i = 0; i < iterations; i++) {
        var index = i;
        var target = getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata);
        if (target !== null) {
          targets.push(target);
        }
      }
      return targets;
    }
    function _getServiceIdentifierForProperty(inject2, multiInject, propertyName, className) {
      var serviceIdentifier = inject2 || multiInject;
      if (serviceIdentifier === void 0) {
        var msg = ERROR_MSGS.MISSING_INJECTABLE_ANNOTATION + " for property " + String(propertyName) + " in class " + className + ".";
        throw new Error(msg);
      }
      return serviceIdentifier;
    }
    function getClassPropsAsTargets(metadataReader, constructorFunc, constructorName) {
      var classPropsMetadata = metadataReader.getPropertiesMetadata(constructorFunc);
      var targets = [];
      var symbolKeys = Object.getOwnPropertySymbols(classPropsMetadata);
      var stringKeys = Object.keys(classPropsMetadata);
      var keys = stringKeys.concat(symbolKeys);
      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        var targetMetadata = classPropsMetadata[key];
        var metadata = formatTargetMetadata(targetMetadata);
        var identifier = metadata.targetName || key;
        var serviceIdentifier = _getServiceIdentifierForProperty(metadata.inject, metadata.multiInject, key, constructorName);
        var target = new target_1.Target(literal_types_1.TargetTypeEnum.ClassProperty, identifier, serviceIdentifier);
        target.metadata = targetMetadata;
        targets.push(target);
      }
      var baseConstructor = Object.getPrototypeOf(constructorFunc.prototype).constructor;
      if (baseConstructor !== Object) {
        var baseTargets = getClassPropsAsTargets(metadataReader, baseConstructor, constructorName);
        targets = __spreadArray(__spreadArray([], targets, true), baseTargets, true);
      }
      return targets;
    }
    function getBaseClassDependencyCount(metadataReader, func) {
      var baseConstructor = Object.getPrototypeOf(func.prototype).constructor;
      if (baseConstructor !== Object) {
        var baseConstructorName = (0, serialization_1.getFunctionName)(baseConstructor);
        var targets = getTargets(metadataReader, baseConstructorName, baseConstructor, true);
        var metadata = targets.map(function(t) {
          return t.metadata.filter(function(m) {
            return m.key === METADATA_KEY.UNMANAGED_TAG;
          });
        });
        var unmanagedCount = [].concat.apply([], metadata).length;
        var dependencyCount = targets.length - unmanagedCount;
        if (dependencyCount > 0) {
          return dependencyCount;
        } else {
          return getBaseClassDependencyCount(metadataReader, baseConstructor);
        }
      } else {
        return 0;
      }
    }
    exports.getBaseClassDependencyCount = getBaseClassDependencyCount;
    function formatTargetMetadata(targetMetadata) {
      var targetMetadataMap = {};
      targetMetadata.forEach(function(m) {
        targetMetadataMap[m.key.toString()] = m.value;
      });
      return {
        inject: targetMetadataMap[METADATA_KEY.INJECT_TAG],
        multiInject: targetMetadataMap[METADATA_KEY.MULTI_INJECT_TAG],
        targetName: targetMetadataMap[METADATA_KEY.NAME_TAG],
        unmanaged: targetMetadataMap[METADATA_KEY.UNMANAGED_TAG]
      };
    }
  }
});

// node_modules/inversify/lib/planning/request.js
var require_request = __commonJS({
  "node_modules/inversify/lib/planning/request.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Request = void 0;
    var id_1 = require_id();
    var Request = function() {
      function Request2(serviceIdentifier, parentContext, parentRequest, bindings, target) {
        this.id = (0, id_1.id)();
        this.serviceIdentifier = serviceIdentifier;
        this.parentContext = parentContext;
        this.parentRequest = parentRequest;
        this.target = target;
        this.childRequests = [];
        this.bindings = Array.isArray(bindings) ? bindings : [bindings];
        this.requestScope = parentRequest === null ? /* @__PURE__ */ new Map() : null;
      }
      Request2.prototype.addChildRequest = function(serviceIdentifier, bindings, target) {
        var child = new Request2(serviceIdentifier, this.parentContext, this, bindings, target);
        this.childRequests.push(child);
        return child;
      };
      return Request2;
    }();
    exports.Request = Request;
  }
});

// node_modules/inversify/lib/planning/planner.js
var require_planner = __commonJS({
  "node_modules/inversify/lib/planning/planner.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBindingDictionary = exports.createMockRequest = exports.plan = void 0;
    var binding_count_1 = require_binding_count();
    var ERROR_MSGS = __importStar(require_error_msgs());
    var literal_types_1 = require_literal_types();
    var METADATA_KEY = __importStar(require_metadata_keys());
    var exceptions_1 = require_exceptions();
    var serialization_1 = require_serialization();
    var context_1 = require_context();
    var metadata_1 = require_metadata();
    var plan_1 = require_plan();
    var reflection_utils_1 = require_reflection_utils();
    var request_1 = require_request();
    var target_1 = require_target();
    function getBindingDictionary(cntnr) {
      return cntnr._bindingDictionary;
    }
    exports.getBindingDictionary = getBindingDictionary;
    function _createTarget(isMultiInject, targetType, serviceIdentifier, name, key, value) {
      var metadataKey = isMultiInject ? METADATA_KEY.MULTI_INJECT_TAG : METADATA_KEY.INJECT_TAG;
      var injectMetadata = new metadata_1.Metadata(metadataKey, serviceIdentifier);
      var target = new target_1.Target(targetType, name, serviceIdentifier, injectMetadata);
      if (key !== void 0) {
        var tagMetadata = new metadata_1.Metadata(key, value);
        target.metadata.push(tagMetadata);
      }
      return target;
    }
    function _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target) {
      var bindings = getBindings(context.container, target.serviceIdentifier);
      var activeBindings = [];
      if (bindings.length === binding_count_1.BindingCount.NoBindingsAvailable && context.container.options.autoBindInjectable && typeof target.serviceIdentifier === "function" && metadataReader.getConstructorMetadata(target.serviceIdentifier).compilerGeneratedMetadata) {
        context.container.bind(target.serviceIdentifier).toSelf();
        bindings = getBindings(context.container, target.serviceIdentifier);
      }
      if (!avoidConstraints) {
        activeBindings = bindings.filter(function(binding) {
          var request = new request_1.Request(binding.serviceIdentifier, context, parentRequest, binding, target);
          return binding.constraint(request);
        });
      } else {
        activeBindings = bindings;
      }
      _validateActiveBindingCount(target.serviceIdentifier, activeBindings, target, context.container);
      return activeBindings;
    }
    function _validateActiveBindingCount(serviceIdentifier, bindings, target, container2) {
      switch (bindings.length) {
        case binding_count_1.BindingCount.NoBindingsAvailable:
          if (target.isOptional()) {
            return bindings;
          } else {
            var serviceIdentifierString = (0, serialization_1.getServiceIdentifierAsString)(serviceIdentifier);
            var msg = ERROR_MSGS.NOT_REGISTERED;
            msg += (0, serialization_1.listMetadataForTarget)(serviceIdentifierString, target);
            msg += (0, serialization_1.listRegisteredBindingsForServiceIdentifier)(container2, serviceIdentifierString, getBindings);
            throw new Error(msg);
          }
        case binding_count_1.BindingCount.OnlyOneBindingAvailable:
          return bindings;
        case binding_count_1.BindingCount.MultipleBindingsAvailable:
        default:
          if (!target.isArray()) {
            var serviceIdentifierString = (0, serialization_1.getServiceIdentifierAsString)(serviceIdentifier);
            var msg = ERROR_MSGS.AMBIGUOUS_MATCH + " " + serviceIdentifierString;
            msg += (0, serialization_1.listRegisteredBindingsForServiceIdentifier)(container2, serviceIdentifierString, getBindings);
            throw new Error(msg);
          } else {
            return bindings;
          }
      }
    }
    function _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, parentRequest, target) {
      var activeBindings;
      var childRequest;
      if (parentRequest === null) {
        activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, null, target);
        childRequest = new request_1.Request(serviceIdentifier, context, null, activeBindings, target);
        var thePlan = new plan_1.Plan(context, childRequest);
        context.addPlan(thePlan);
      } else {
        activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target);
        childRequest = parentRequest.addChildRequest(target.serviceIdentifier, activeBindings, target);
      }
      activeBindings.forEach(function(binding) {
        var subChildRequest = null;
        if (target.isArray()) {
          subChildRequest = childRequest.addChildRequest(binding.serviceIdentifier, binding, target);
        } else {
          if (binding.cache) {
            return;
          }
          subChildRequest = childRequest;
        }
        if (binding.type === literal_types_1.BindingTypeEnum.Instance && binding.implementationType !== null) {
          var dependencies = (0, reflection_utils_1.getDependencies)(metadataReader, binding.implementationType);
          if (!context.container.options.skipBaseClassChecks) {
            var baseClassDependencyCount = (0, reflection_utils_1.getBaseClassDependencyCount)(metadataReader, binding.implementationType);
            if (dependencies.length < baseClassDependencyCount) {
              var error = ERROR_MSGS.ARGUMENTS_LENGTH_MISMATCH((0, reflection_utils_1.getFunctionName)(binding.implementationType));
              throw new Error(error);
            }
          }
          dependencies.forEach(function(dependency) {
            _createSubRequests(metadataReader, false, dependency.serviceIdentifier, context, subChildRequest, dependency);
          });
        }
      });
    }
    function getBindings(container2, serviceIdentifier) {
      var bindings = [];
      var bindingDictionary = getBindingDictionary(container2);
      if (bindingDictionary.hasKey(serviceIdentifier)) {
        bindings = bindingDictionary.get(serviceIdentifier);
      } else if (container2.parent !== null) {
        bindings = getBindings(container2.parent, serviceIdentifier);
      }
      return bindings;
    }
    function plan(metadataReader, container2, isMultiInject, targetType, serviceIdentifier, key, value, avoidConstraints) {
      if (avoidConstraints === void 0) {
        avoidConstraints = false;
      }
      var context = new context_1.Context(container2);
      var target = _createTarget(isMultiInject, targetType, serviceIdentifier, "", key, value);
      try {
        _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, null, target);
        return context;
      } catch (error) {
        if ((0, exceptions_1.isStackOverflowExeption)(error)) {
          (0, serialization_1.circularDependencyToException)(context.plan.rootRequest);
        }
        throw error;
      }
    }
    exports.plan = plan;
    function createMockRequest(container2, serviceIdentifier, key, value) {
      var target = new target_1.Target(literal_types_1.TargetTypeEnum.Variable, "", serviceIdentifier, new metadata_1.Metadata(key, value));
      var context = new context_1.Context(container2);
      var request = new request_1.Request(serviceIdentifier, context, null, [], target);
      return request;
    }
    exports.createMockRequest = createMockRequest;
  }
});

// node_modules/inversify/lib/utils/async.js
var require_async = __commonJS({
  "node_modules/inversify/lib/utils/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isPromiseOrContainsPromise = exports.isPromise = void 0;
    function isPromise(object) {
      var isObjectOrFunction = typeof object === "object" && object !== null || typeof object === "function";
      return isObjectOrFunction && typeof object.then === "function";
    }
    exports.isPromise = isPromise;
    function isPromiseOrContainsPromise(object) {
      if (isPromise(object)) {
        return true;
      }
      return Array.isArray(object) && object.some(isPromise);
    }
    exports.isPromiseOrContainsPromise = isPromiseOrContainsPromise;
  }
});

// node_modules/inversify/lib/scope/scope.js
var require_scope = __commonJS({
  "node_modules/inversify/lib/scope/scope.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.saveToScope = exports.tryGetFromScope = void 0;
    var inversify_1 = require_inversify();
    var async_1 = require_async();
    var tryGetFromScope = function(requestScope, binding) {
      if (binding.scope === inversify_1.BindingScopeEnum.Singleton && binding.activated) {
        return binding.cache;
      }
      if (binding.scope === inversify_1.BindingScopeEnum.Request && requestScope.has(binding.id)) {
        return requestScope.get(binding.id);
      }
      return null;
    };
    exports.tryGetFromScope = tryGetFromScope;
    var saveToScope = function(requestScope, binding, result) {
      if (binding.scope === inversify_1.BindingScopeEnum.Singleton) {
        _saveToSingletonScope(binding, result);
      }
      if (binding.scope === inversify_1.BindingScopeEnum.Request) {
        _saveToRequestScope(requestScope, binding, result);
      }
    };
    exports.saveToScope = saveToScope;
    var _saveToRequestScope = function(requestScope, binding, result) {
      if (!requestScope.has(binding.id)) {
        requestScope.set(binding.id, result);
      }
    };
    var _saveToSingletonScope = function(binding, result) {
      binding.cache = result;
      binding.activated = true;
      if ((0, async_1.isPromise)(result)) {
        void _saveAsyncResultToSingletonScope(binding, result);
      }
    };
    var _saveAsyncResultToSingletonScope = function(binding, asyncResult) {
      return __awaiter(void 0, void 0, void 0, function() {
        var result, ex_1;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              _a.trys.push([0, 2, , 3]);
              return [4, asyncResult];
            case 1:
              result = _a.sent();
              binding.cache = result;
              return [3, 3];
            case 2:
              ex_1 = _a.sent();
              binding.cache = null;
              binding.activated = false;
              throw ex_1;
            case 3:
              return [2];
          }
        });
      });
    };
  }
});

// node_modules/inversify/lib/utils/factory_type.js
var require_factory_type = __commonJS({
  "node_modules/inversify/lib/utils/factory_type.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FactoryType = void 0;
    var FactoryType;
    (function(FactoryType2) {
      FactoryType2["DynamicValue"] = "toDynamicValue";
      FactoryType2["Factory"] = "toFactory";
      FactoryType2["Provider"] = "toProvider";
    })(FactoryType = exports.FactoryType || (exports.FactoryType = {}));
  }
});

// node_modules/inversify/lib/utils/binding_utils.js
var require_binding_utils = __commonJS({
  "node_modules/inversify/lib/utils/binding_utils.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFactoryDetails = exports.ensureFullyBound = exports.multiBindToService = void 0;
    var inversify_1 = require_inversify();
    var ERROR_MSGS = __importStar(require_error_msgs());
    var literal_types_1 = require_literal_types();
    var factory_type_1 = require_factory_type();
    var multiBindToService = function(container2) {
      return function(service) {
        return function() {
          var types = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            types[_i] = arguments[_i];
          }
          return types.forEach(function(t) {
            return container2.bind(t).toService(service);
          });
        };
      };
    };
    exports.multiBindToService = multiBindToService;
    var ensureFullyBound = function(binding) {
      var boundValue = null;
      switch (binding.type) {
        case literal_types_1.BindingTypeEnum.ConstantValue:
        case literal_types_1.BindingTypeEnum.Function:
          boundValue = binding.cache;
          break;
        case literal_types_1.BindingTypeEnum.Constructor:
        case literal_types_1.BindingTypeEnum.Instance:
          boundValue = binding.implementationType;
          break;
        case literal_types_1.BindingTypeEnum.DynamicValue:
          boundValue = binding.dynamicValue;
          break;
        case literal_types_1.BindingTypeEnum.Provider:
          boundValue = binding.provider;
          break;
        case literal_types_1.BindingTypeEnum.Factory:
          boundValue = binding.factory;
          break;
      }
      if (boundValue === null) {
        var serviceIdentifierAsString = (0, inversify_1.getServiceIdentifierAsString)(binding.serviceIdentifier);
        throw new Error(ERROR_MSGS.INVALID_BINDING_TYPE + " " + serviceIdentifierAsString);
      }
    };
    exports.ensureFullyBound = ensureFullyBound;
    var getFactoryDetails = function(binding) {
      switch (binding.type) {
        case literal_types_1.BindingTypeEnum.Factory:
          return { factory: binding.factory, factoryType: factory_type_1.FactoryType.Factory };
        case literal_types_1.BindingTypeEnum.Provider:
          return { factory: binding.provider, factoryType: factory_type_1.FactoryType.Provider };
        case literal_types_1.BindingTypeEnum.DynamicValue:
          return { factory: binding.dynamicValue, factoryType: factory_type_1.FactoryType.DynamicValue };
        default:
          throw new Error("Unexpected factory type " + binding.type);
      }
    };
    exports.getFactoryDetails = getFactoryDetails;
  }
});

// node_modules/inversify/lib/resolution/instantiation.js
var require_instantiation = __commonJS({
  "node_modules/inversify/lib/resolution/instantiation.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveInstance = void 0;
    var error_msgs_1 = require_error_msgs();
    var literal_types_1 = require_literal_types();
    var METADATA_KEY = __importStar(require_metadata_keys());
    var async_1 = require_async();
    function _resolveRequests(childRequests, resolveRequest) {
      return childRequests.reduce(function(resolvedRequests, childRequest) {
        var injection = resolveRequest(childRequest);
        var targetType = childRequest.target.type;
        if (targetType === literal_types_1.TargetTypeEnum.ConstructorArgument) {
          resolvedRequests.constructorInjections.push(injection);
        } else {
          resolvedRequests.propertyRequests.push(childRequest);
          resolvedRequests.propertyInjections.push(injection);
        }
        if (!resolvedRequests.isAsync) {
          resolvedRequests.isAsync = (0, async_1.isPromiseOrContainsPromise)(injection);
        }
        return resolvedRequests;
      }, { constructorInjections: [], propertyInjections: [], propertyRequests: [], isAsync: false });
    }
    function _createInstance(constr, childRequests, resolveRequest) {
      var result;
      if (childRequests.length > 0) {
        var resolved = _resolveRequests(childRequests, resolveRequest);
        var createInstanceWithInjectionsArg = __assign(__assign({}, resolved), { constr });
        if (resolved.isAsync) {
          result = createInstanceWithInjectionsAsync(createInstanceWithInjectionsArg);
        } else {
          result = createInstanceWithInjections(createInstanceWithInjectionsArg);
        }
      } else {
        result = new constr();
      }
      return result;
    }
    function createInstanceWithInjections(args) {
      var _a;
      var instance = new ((_a = args.constr).bind.apply(_a, __spreadArray([void 0], args.constructorInjections, false)))();
      args.propertyRequests.forEach(function(r, index) {
        var property = r.target.identifier;
        var injection = args.propertyInjections[index];
        instance[property] = injection;
      });
      return instance;
    }
    function createInstanceWithInjectionsAsync(args) {
      return __awaiter(this, void 0, void 0, function() {
        var constructorInjections, propertyInjections;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, possiblyWaitInjections(args.constructorInjections)];
            case 1:
              constructorInjections = _a.sent();
              return [4, possiblyWaitInjections(args.propertyInjections)];
            case 2:
              propertyInjections = _a.sent();
              return [2, createInstanceWithInjections(__assign(__assign({}, args), { constructorInjections, propertyInjections }))];
          }
        });
      });
    }
    function possiblyWaitInjections(possiblePromiseinjections) {
      return __awaiter(this, void 0, void 0, function() {
        var injections, _i, possiblePromiseinjections_1, injection;
        return __generator(this, function(_a) {
          injections = [];
          for (_i = 0, possiblePromiseinjections_1 = possiblePromiseinjections; _i < possiblePromiseinjections_1.length; _i++) {
            injection = possiblePromiseinjections_1[_i];
            if (Array.isArray(injection)) {
              injections.push(Promise.all(injection));
            } else {
              injections.push(injection);
            }
          }
          return [2, Promise.all(injections)];
        });
      });
    }
    function _getInstanceAfterPostConstruct(constr, result) {
      var postConstructResult = _postConstruct(constr, result);
      if ((0, async_1.isPromise)(postConstructResult)) {
        return postConstructResult.then(function() {
          return result;
        });
      } else {
        return result;
      }
    }
    function _postConstruct(constr, instance) {
      var _a, _b;
      if (Reflect.hasMetadata(METADATA_KEY.POST_CONSTRUCT, constr)) {
        var data = Reflect.getMetadata(METADATA_KEY.POST_CONSTRUCT, constr);
        try {
          return (_b = (_a = instance)[data.value]) === null || _b === void 0 ? void 0 : _b.call(_a);
        } catch (e) {
          throw new Error((0, error_msgs_1.POST_CONSTRUCT_ERROR)(constr.name, e.message));
        }
      }
    }
    function _validateInstanceResolution(binding, constr) {
      if (binding.scope !== literal_types_1.BindingScopeEnum.Singleton) {
        _throwIfHandlingDeactivation(binding, constr);
      }
    }
    function _throwIfHandlingDeactivation(binding, constr) {
      var scopeErrorMessage = "Class cannot be instantiated in " + (binding.scope === literal_types_1.BindingScopeEnum.Request ? "request" : "transient") + " scope.";
      if (typeof binding.onDeactivation === "function") {
        throw new Error((0, error_msgs_1.ON_DEACTIVATION_ERROR)(constr.name, scopeErrorMessage));
      }
      if (Reflect.hasMetadata(METADATA_KEY.PRE_DESTROY, constr)) {
        throw new Error((0, error_msgs_1.PRE_DESTROY_ERROR)(constr.name, scopeErrorMessage));
      }
    }
    function resolveInstance(binding, constr, childRequests, resolveRequest) {
      _validateInstanceResolution(binding, constr);
      var result = _createInstance(constr, childRequests, resolveRequest);
      if ((0, async_1.isPromise)(result)) {
        return result.then(function(resolvedResult) {
          return _getInstanceAfterPostConstruct(constr, resolvedResult);
        });
      } else {
        return _getInstanceAfterPostConstruct(constr, result);
      }
    }
    exports.resolveInstance = resolveInstance;
  }
});

// node_modules/inversify/lib/resolution/resolver.js
var require_resolver = __commonJS({
  "node_modules/inversify/lib/resolution/resolver.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolve = void 0;
    var ERROR_MSGS = __importStar(require_error_msgs());
    var literal_types_1 = require_literal_types();
    var planner_1 = require_planner();
    var scope_1 = require_scope();
    var async_1 = require_async();
    var binding_utils_1 = require_binding_utils();
    var exceptions_1 = require_exceptions();
    var instantiation_1 = require_instantiation();
    var _resolveRequest = function(requestScope) {
      return function(request) {
        request.parentContext.setCurrentRequest(request);
        var bindings = request.bindings;
        var childRequests = request.childRequests;
        var targetIsAnArray = request.target && request.target.isArray();
        var targetParentIsNotAnArray = !request.parentRequest || !request.parentRequest.target || !request.target || !request.parentRequest.target.matchesArray(request.target.serviceIdentifier);
        if (targetIsAnArray && targetParentIsNotAnArray) {
          return childRequests.map(function(childRequest) {
            var _f = _resolveRequest(requestScope);
            return _f(childRequest);
          });
        } else {
          if (request.target.isOptional() && bindings.length === 0) {
            return void 0;
          }
          var binding = bindings[0];
          return _resolveBinding(requestScope, request, binding);
        }
      };
    };
    var _resolveFactoryFromBinding = function(binding, context) {
      var factoryDetails = (0, binding_utils_1.getFactoryDetails)(binding);
      return (0, exceptions_1.tryAndThrowErrorIfStackOverflow)(function() {
        return factoryDetails.factory.bind(binding)(context);
      }, function() {
        return new Error(ERROR_MSGS.CIRCULAR_DEPENDENCY_IN_FACTORY(factoryDetails.factoryType, context.currentRequest.serviceIdentifier.toString()));
      });
    };
    var _getResolvedFromBinding = function(requestScope, request, binding) {
      var result;
      var childRequests = request.childRequests;
      (0, binding_utils_1.ensureFullyBound)(binding);
      switch (binding.type) {
        case literal_types_1.BindingTypeEnum.ConstantValue:
        case literal_types_1.BindingTypeEnum.Function:
          result = binding.cache;
          break;
        case literal_types_1.BindingTypeEnum.Constructor:
          result = binding.implementationType;
          break;
        case literal_types_1.BindingTypeEnum.Instance:
          result = (0, instantiation_1.resolveInstance)(binding, binding.implementationType, childRequests, _resolveRequest(requestScope));
          break;
        default:
          result = _resolveFactoryFromBinding(binding, request.parentContext);
      }
      return result;
    };
    var _resolveInScope = function(requestScope, binding, resolveFromBinding) {
      var result = (0, scope_1.tryGetFromScope)(requestScope, binding);
      if (result !== null) {
        return result;
      }
      result = resolveFromBinding();
      (0, scope_1.saveToScope)(requestScope, binding, result);
      return result;
    };
    var _resolveBinding = function(requestScope, request, binding) {
      return _resolveInScope(requestScope, binding, function() {
        var result = _getResolvedFromBinding(requestScope, request, binding);
        if ((0, async_1.isPromise)(result)) {
          result = result.then(function(resolved) {
            return _onActivation(request, binding, resolved);
          });
        } else {
          result = _onActivation(request, binding, result);
        }
        return result;
      });
    };
    function _onActivation(request, binding, resolved) {
      var result = _bindingActivation(request.parentContext, binding, resolved);
      var containersIterator = _getContainersIterator(request.parentContext.container);
      var container2;
      var containersIteratorResult = containersIterator.next();
      do {
        container2 = containersIteratorResult.value;
        var context_1 = request.parentContext;
        var serviceIdentifier = request.serviceIdentifier;
        var activationsIterator = _getContainerActivationsForService(container2, serviceIdentifier);
        if ((0, async_1.isPromise)(result)) {
          result = _activateContainerAsync(activationsIterator, context_1, result);
        } else {
          result = _activateContainer(activationsIterator, context_1, result);
        }
        containersIteratorResult = containersIterator.next();
      } while (containersIteratorResult.done !== true && !(0, planner_1.getBindingDictionary)(container2).hasKey(request.serviceIdentifier));
      return result;
    }
    var _bindingActivation = function(context, binding, previousResult) {
      var result;
      if (typeof binding.onActivation === "function") {
        result = binding.onActivation(context, previousResult);
      } else {
        result = previousResult;
      }
      return result;
    };
    var _activateContainer = function(activationsIterator, context, result) {
      var activation = activationsIterator.next();
      while (!activation.done) {
        result = activation.value(context, result);
        if ((0, async_1.isPromise)(result)) {
          return _activateContainerAsync(activationsIterator, context, result);
        }
        activation = activationsIterator.next();
      }
      return result;
    };
    var _activateContainerAsync = function(activationsIterator, context, resultPromise) {
      return __awaiter(void 0, void 0, void 0, function() {
        var result, activation;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, resultPromise];
            case 1:
              result = _a.sent();
              activation = activationsIterator.next();
              _a.label = 2;
            case 2:
              if (!!activation.done)
                return [3, 4];
              return [4, activation.value(context, result)];
            case 3:
              result = _a.sent();
              activation = activationsIterator.next();
              return [3, 2];
            case 4:
              return [2, result];
          }
        });
      });
    };
    var _getContainerActivationsForService = function(container2, serviceIdentifier) {
      var activations = container2._activations;
      return activations.hasKey(serviceIdentifier) ? activations.get(serviceIdentifier).values() : [].values();
    };
    var _getContainersIterator = function(container2) {
      var containersStack = [container2];
      var parent = container2.parent;
      while (parent !== null) {
        containersStack.push(parent);
        parent = parent.parent;
      }
      var getNextContainer = function() {
        var nextContainer = containersStack.pop();
        if (nextContainer !== void 0) {
          return { done: false, value: nextContainer };
        } else {
          return { done: true, value: void 0 };
        }
      };
      var containersIterator = {
        next: getNextContainer
      };
      return containersIterator;
    };
    function resolve(context) {
      var _f = _resolveRequest(context.plan.rootRequest.requestScope);
      return _f(context.plan.rootRequest);
    }
    exports.resolve = resolve;
  }
});

// node_modules/inversify/lib/syntax/constraint_helpers.js
var require_constraint_helpers = __commonJS({
  "node_modules/inversify/lib/syntax/constraint_helpers.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.typeConstraint = exports.namedConstraint = exports.taggedConstraint = exports.traverseAncerstors = void 0;
    var METADATA_KEY = __importStar(require_metadata_keys());
    var metadata_1 = require_metadata();
    var traverseAncerstors = function(request, constraint) {
      var parent = request.parentRequest;
      if (parent !== null) {
        return constraint(parent) ? true : traverseAncerstors(parent, constraint);
      } else {
        return false;
      }
    };
    exports.traverseAncerstors = traverseAncerstors;
    var taggedConstraint = function(key) {
      return function(value) {
        var constraint = function(request) {
          return request !== null && request.target !== null && request.target.matchesTag(key)(value);
        };
        constraint.metaData = new metadata_1.Metadata(key, value);
        return constraint;
      };
    };
    exports.taggedConstraint = taggedConstraint;
    var namedConstraint = taggedConstraint(METADATA_KEY.NAMED_TAG);
    exports.namedConstraint = namedConstraint;
    var typeConstraint = function(type) {
      return function(request) {
        var binding = null;
        if (request !== null) {
          binding = request.bindings[0];
          if (typeof type === "string") {
            var serviceIdentifier = binding.serviceIdentifier;
            return serviceIdentifier === type;
          } else {
            var constructor = request.bindings[0].implementationType;
            return type === constructor;
          }
        }
        return false;
      };
    };
    exports.typeConstraint = typeConstraint;
  }
});

// node_modules/inversify/lib/syntax/binding_when_syntax.js
var require_binding_when_syntax = __commonJS({
  "node_modules/inversify/lib/syntax/binding_when_syntax.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BindingWhenSyntax = void 0;
    var binding_on_syntax_1 = require_binding_on_syntax();
    var constraint_helpers_1 = require_constraint_helpers();
    var BindingWhenSyntax = function() {
      function BindingWhenSyntax2(binding) {
        this._binding = binding;
      }
      BindingWhenSyntax2.prototype.when = function(constraint) {
        this._binding.constraint = constraint;
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenTargetNamed = function(name) {
        this._binding.constraint = (0, constraint_helpers_1.namedConstraint)(name);
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenTargetIsDefault = function() {
        this._binding.constraint = function(request) {
          if (request === null) {
            return false;
          }
          var targetIsDefault = request.target !== null && !request.target.isNamed() && !request.target.isTagged();
          return targetIsDefault;
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenTargetTagged = function(tag, value) {
        this._binding.constraint = (0, constraint_helpers_1.taggedConstraint)(tag)(value);
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenInjectedInto = function(parent) {
        this._binding.constraint = function(request) {
          return request !== null && (0, constraint_helpers_1.typeConstraint)(parent)(request.parentRequest);
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenParentNamed = function(name) {
        this._binding.constraint = function(request) {
          return request !== null && (0, constraint_helpers_1.namedConstraint)(name)(request.parentRequest);
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenParentTagged = function(tag, value) {
        this._binding.constraint = function(request) {
          return request !== null && (0, constraint_helpers_1.taggedConstraint)(tag)(value)(request.parentRequest);
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenAnyAncestorIs = function(ancestor) {
        this._binding.constraint = function(request) {
          return request !== null && (0, constraint_helpers_1.traverseAncerstors)(request, (0, constraint_helpers_1.typeConstraint)(ancestor));
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenNoAncestorIs = function(ancestor) {
        this._binding.constraint = function(request) {
          return request !== null && !(0, constraint_helpers_1.traverseAncerstors)(request, (0, constraint_helpers_1.typeConstraint)(ancestor));
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenAnyAncestorNamed = function(name) {
        this._binding.constraint = function(request) {
          return request !== null && (0, constraint_helpers_1.traverseAncerstors)(request, (0, constraint_helpers_1.namedConstraint)(name));
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenNoAncestorNamed = function(name) {
        this._binding.constraint = function(request) {
          return request !== null && !(0, constraint_helpers_1.traverseAncerstors)(request, (0, constraint_helpers_1.namedConstraint)(name));
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenAnyAncestorTagged = function(tag, value) {
        this._binding.constraint = function(request) {
          return request !== null && (0, constraint_helpers_1.traverseAncerstors)(request, (0, constraint_helpers_1.taggedConstraint)(tag)(value));
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenNoAncestorTagged = function(tag, value) {
        this._binding.constraint = function(request) {
          return request !== null && !(0, constraint_helpers_1.traverseAncerstors)(request, (0, constraint_helpers_1.taggedConstraint)(tag)(value));
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenAnyAncestorMatches = function(constraint) {
        this._binding.constraint = function(request) {
          return request !== null && (0, constraint_helpers_1.traverseAncerstors)(request, constraint);
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenNoAncestorMatches = function(constraint) {
        this._binding.constraint = function(request) {
          return request !== null && !(0, constraint_helpers_1.traverseAncerstors)(request, constraint);
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      return BindingWhenSyntax2;
    }();
    exports.BindingWhenSyntax = BindingWhenSyntax;
  }
});

// node_modules/inversify/lib/syntax/binding_on_syntax.js
var require_binding_on_syntax = __commonJS({
  "node_modules/inversify/lib/syntax/binding_on_syntax.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BindingOnSyntax = void 0;
    var binding_when_syntax_1 = require_binding_when_syntax();
    var BindingOnSyntax = function() {
      function BindingOnSyntax2(binding) {
        this._binding = binding;
      }
      BindingOnSyntax2.prototype.onActivation = function(handler) {
        this._binding.onActivation = handler;
        return new binding_when_syntax_1.BindingWhenSyntax(this._binding);
      };
      BindingOnSyntax2.prototype.onDeactivation = function(handler) {
        this._binding.onDeactivation = handler;
        return new binding_when_syntax_1.BindingWhenSyntax(this._binding);
      };
      return BindingOnSyntax2;
    }();
    exports.BindingOnSyntax = BindingOnSyntax;
  }
});

// node_modules/inversify/lib/syntax/binding_when_on_syntax.js
var require_binding_when_on_syntax = __commonJS({
  "node_modules/inversify/lib/syntax/binding_when_on_syntax.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BindingWhenOnSyntax = void 0;
    var binding_on_syntax_1 = require_binding_on_syntax();
    var binding_when_syntax_1 = require_binding_when_syntax();
    var BindingWhenOnSyntax = function() {
      function BindingWhenOnSyntax2(binding) {
        this._binding = binding;
        this._bindingWhenSyntax = new binding_when_syntax_1.BindingWhenSyntax(this._binding);
        this._bindingOnSyntax = new binding_on_syntax_1.BindingOnSyntax(this._binding);
      }
      BindingWhenOnSyntax2.prototype.when = function(constraint) {
        return this._bindingWhenSyntax.when(constraint);
      };
      BindingWhenOnSyntax2.prototype.whenTargetNamed = function(name) {
        return this._bindingWhenSyntax.whenTargetNamed(name);
      };
      BindingWhenOnSyntax2.prototype.whenTargetIsDefault = function() {
        return this._bindingWhenSyntax.whenTargetIsDefault();
      };
      BindingWhenOnSyntax2.prototype.whenTargetTagged = function(tag, value) {
        return this._bindingWhenSyntax.whenTargetTagged(tag, value);
      };
      BindingWhenOnSyntax2.prototype.whenInjectedInto = function(parent) {
        return this._bindingWhenSyntax.whenInjectedInto(parent);
      };
      BindingWhenOnSyntax2.prototype.whenParentNamed = function(name) {
        return this._bindingWhenSyntax.whenParentNamed(name);
      };
      BindingWhenOnSyntax2.prototype.whenParentTagged = function(tag, value) {
        return this._bindingWhenSyntax.whenParentTagged(tag, value);
      };
      BindingWhenOnSyntax2.prototype.whenAnyAncestorIs = function(ancestor) {
        return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
      };
      BindingWhenOnSyntax2.prototype.whenNoAncestorIs = function(ancestor) {
        return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
      };
      BindingWhenOnSyntax2.prototype.whenAnyAncestorNamed = function(name) {
        return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
      };
      BindingWhenOnSyntax2.prototype.whenAnyAncestorTagged = function(tag, value) {
        return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
      };
      BindingWhenOnSyntax2.prototype.whenNoAncestorNamed = function(name) {
        return this._bindingWhenSyntax.whenNoAncestorNamed(name);
      };
      BindingWhenOnSyntax2.prototype.whenNoAncestorTagged = function(tag, value) {
        return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
      };
      BindingWhenOnSyntax2.prototype.whenAnyAncestorMatches = function(constraint) {
        return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
      };
      BindingWhenOnSyntax2.prototype.whenNoAncestorMatches = function(constraint) {
        return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
      };
      BindingWhenOnSyntax2.prototype.onActivation = function(handler) {
        return this._bindingOnSyntax.onActivation(handler);
      };
      BindingWhenOnSyntax2.prototype.onDeactivation = function(handler) {
        return this._bindingOnSyntax.onDeactivation(handler);
      };
      return BindingWhenOnSyntax2;
    }();
    exports.BindingWhenOnSyntax = BindingWhenOnSyntax;
  }
});

// node_modules/inversify/lib/syntax/binding_in_syntax.js
var require_binding_in_syntax = __commonJS({
  "node_modules/inversify/lib/syntax/binding_in_syntax.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BindingInSyntax = void 0;
    var literal_types_1 = require_literal_types();
    var binding_when_on_syntax_1 = require_binding_when_on_syntax();
    var BindingInSyntax = function() {
      function BindingInSyntax2(binding) {
        this._binding = binding;
      }
      BindingInSyntax2.prototype.inRequestScope = function() {
        this._binding.scope = literal_types_1.BindingScopeEnum.Request;
        return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
      };
      BindingInSyntax2.prototype.inSingletonScope = function() {
        this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
        return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
      };
      BindingInSyntax2.prototype.inTransientScope = function() {
        this._binding.scope = literal_types_1.BindingScopeEnum.Transient;
        return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
      };
      return BindingInSyntax2;
    }();
    exports.BindingInSyntax = BindingInSyntax;
  }
});

// node_modules/inversify/lib/syntax/binding_in_when_on_syntax.js
var require_binding_in_when_on_syntax = __commonJS({
  "node_modules/inversify/lib/syntax/binding_in_when_on_syntax.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BindingInWhenOnSyntax = void 0;
    var binding_in_syntax_1 = require_binding_in_syntax();
    var binding_on_syntax_1 = require_binding_on_syntax();
    var binding_when_syntax_1 = require_binding_when_syntax();
    var BindingInWhenOnSyntax = function() {
      function BindingInWhenOnSyntax2(binding) {
        this._binding = binding;
        this._bindingWhenSyntax = new binding_when_syntax_1.BindingWhenSyntax(this._binding);
        this._bindingOnSyntax = new binding_on_syntax_1.BindingOnSyntax(this._binding);
        this._bindingInSyntax = new binding_in_syntax_1.BindingInSyntax(binding);
      }
      BindingInWhenOnSyntax2.prototype.inRequestScope = function() {
        return this._bindingInSyntax.inRequestScope();
      };
      BindingInWhenOnSyntax2.prototype.inSingletonScope = function() {
        return this._bindingInSyntax.inSingletonScope();
      };
      BindingInWhenOnSyntax2.prototype.inTransientScope = function() {
        return this._bindingInSyntax.inTransientScope();
      };
      BindingInWhenOnSyntax2.prototype.when = function(constraint) {
        return this._bindingWhenSyntax.when(constraint);
      };
      BindingInWhenOnSyntax2.prototype.whenTargetNamed = function(name) {
        return this._bindingWhenSyntax.whenTargetNamed(name);
      };
      BindingInWhenOnSyntax2.prototype.whenTargetIsDefault = function() {
        return this._bindingWhenSyntax.whenTargetIsDefault();
      };
      BindingInWhenOnSyntax2.prototype.whenTargetTagged = function(tag, value) {
        return this._bindingWhenSyntax.whenTargetTagged(tag, value);
      };
      BindingInWhenOnSyntax2.prototype.whenInjectedInto = function(parent) {
        return this._bindingWhenSyntax.whenInjectedInto(parent);
      };
      BindingInWhenOnSyntax2.prototype.whenParentNamed = function(name) {
        return this._bindingWhenSyntax.whenParentNamed(name);
      };
      BindingInWhenOnSyntax2.prototype.whenParentTagged = function(tag, value) {
        return this._bindingWhenSyntax.whenParentTagged(tag, value);
      };
      BindingInWhenOnSyntax2.prototype.whenAnyAncestorIs = function(ancestor) {
        return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
      };
      BindingInWhenOnSyntax2.prototype.whenNoAncestorIs = function(ancestor) {
        return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
      };
      BindingInWhenOnSyntax2.prototype.whenAnyAncestorNamed = function(name) {
        return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
      };
      BindingInWhenOnSyntax2.prototype.whenAnyAncestorTagged = function(tag, value) {
        return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
      };
      BindingInWhenOnSyntax2.prototype.whenNoAncestorNamed = function(name) {
        return this._bindingWhenSyntax.whenNoAncestorNamed(name);
      };
      BindingInWhenOnSyntax2.prototype.whenNoAncestorTagged = function(tag, value) {
        return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
      };
      BindingInWhenOnSyntax2.prototype.whenAnyAncestorMatches = function(constraint) {
        return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
      };
      BindingInWhenOnSyntax2.prototype.whenNoAncestorMatches = function(constraint) {
        return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
      };
      BindingInWhenOnSyntax2.prototype.onActivation = function(handler) {
        return this._bindingOnSyntax.onActivation(handler);
      };
      BindingInWhenOnSyntax2.prototype.onDeactivation = function(handler) {
        return this._bindingOnSyntax.onDeactivation(handler);
      };
      return BindingInWhenOnSyntax2;
    }();
    exports.BindingInWhenOnSyntax = BindingInWhenOnSyntax;
  }
});

// node_modules/inversify/lib/syntax/binding_to_syntax.js
var require_binding_to_syntax = __commonJS({
  "node_modules/inversify/lib/syntax/binding_to_syntax.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BindingToSyntax = void 0;
    var ERROR_MSGS = __importStar(require_error_msgs());
    var literal_types_1 = require_literal_types();
    var binding_in_when_on_syntax_1 = require_binding_in_when_on_syntax();
    var binding_when_on_syntax_1 = require_binding_when_on_syntax();
    var BindingToSyntax = function() {
      function BindingToSyntax2(binding) {
        this._binding = binding;
      }
      BindingToSyntax2.prototype.to = function(constructor) {
        this._binding.type = literal_types_1.BindingTypeEnum.Instance;
        this._binding.implementationType = constructor;
        return new binding_in_when_on_syntax_1.BindingInWhenOnSyntax(this._binding);
      };
      BindingToSyntax2.prototype.toSelf = function() {
        if (typeof this._binding.serviceIdentifier !== "function") {
          throw new Error("" + ERROR_MSGS.INVALID_TO_SELF_VALUE);
        }
        var self2 = this._binding.serviceIdentifier;
        return this.to(self2);
      };
      BindingToSyntax2.prototype.toConstantValue = function(value) {
        this._binding.type = literal_types_1.BindingTypeEnum.ConstantValue;
        this._binding.cache = value;
        this._binding.dynamicValue = null;
        this._binding.implementationType = null;
        this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
        return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
      };
      BindingToSyntax2.prototype.toDynamicValue = function(func) {
        this._binding.type = literal_types_1.BindingTypeEnum.DynamicValue;
        this._binding.cache = null;
        this._binding.dynamicValue = func;
        this._binding.implementationType = null;
        return new binding_in_when_on_syntax_1.BindingInWhenOnSyntax(this._binding);
      };
      BindingToSyntax2.prototype.toConstructor = function(constructor) {
        this._binding.type = literal_types_1.BindingTypeEnum.Constructor;
        this._binding.implementationType = constructor;
        this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
        return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
      };
      BindingToSyntax2.prototype.toFactory = function(factory) {
        this._binding.type = literal_types_1.BindingTypeEnum.Factory;
        this._binding.factory = factory;
        this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
        return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
      };
      BindingToSyntax2.prototype.toFunction = function(func) {
        if (typeof func !== "function") {
          throw new Error(ERROR_MSGS.INVALID_FUNCTION_BINDING);
        }
        var bindingWhenOnSyntax = this.toConstantValue(func);
        this._binding.type = literal_types_1.BindingTypeEnum.Function;
        this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
        return bindingWhenOnSyntax;
      };
      BindingToSyntax2.prototype.toAutoFactory = function(serviceIdentifier) {
        this._binding.type = literal_types_1.BindingTypeEnum.Factory;
        this._binding.factory = function(context) {
          var autofactory = function() {
            return context.container.get(serviceIdentifier);
          };
          return autofactory;
        };
        this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
        return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
      };
      BindingToSyntax2.prototype.toAutoNamedFactory = function(serviceIdentifier) {
        this._binding.type = literal_types_1.BindingTypeEnum.Factory;
        this._binding.factory = function(context) {
          return function(named2) {
            return context.container.getNamed(serviceIdentifier, named2);
          };
        };
        return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
      };
      BindingToSyntax2.prototype.toProvider = function(provider) {
        this._binding.type = literal_types_1.BindingTypeEnum.Provider;
        this._binding.provider = provider;
        this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
        return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
      };
      BindingToSyntax2.prototype.toService = function(service) {
        this.toDynamicValue(function(context) {
          return context.container.get(service);
        });
      };
      return BindingToSyntax2;
    }();
    exports.BindingToSyntax = BindingToSyntax;
  }
});

// node_modules/inversify/lib/container/container_snapshot.js
var require_container_snapshot = __commonJS({
  "node_modules/inversify/lib/container/container_snapshot.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContainerSnapshot = void 0;
    var ContainerSnapshot = function() {
      function ContainerSnapshot2() {
      }
      ContainerSnapshot2.of = function(bindings, middleware, activations, deactivations, moduleActivationStore) {
        var snapshot = new ContainerSnapshot2();
        snapshot.bindings = bindings;
        snapshot.middleware = middleware;
        snapshot.deactivations = deactivations;
        snapshot.activations = activations;
        snapshot.moduleActivationStore = moduleActivationStore;
        return snapshot;
      };
      return ContainerSnapshot2;
    }();
    exports.ContainerSnapshot = ContainerSnapshot;
  }
});

// node_modules/inversify/lib/utils/clonable.js
var require_clonable = __commonJS({
  "node_modules/inversify/lib/utils/clonable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isClonable = void 0;
    function isClonable(obj) {
      return typeof obj === "object" && obj !== null && "clone" in obj && typeof obj.clone === "function";
    }
    exports.isClonable = isClonable;
  }
});

// node_modules/inversify/lib/container/lookup.js
var require_lookup = __commonJS({
  "node_modules/inversify/lib/container/lookup.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Lookup = void 0;
    var ERROR_MSGS = __importStar(require_error_msgs());
    var clonable_1 = require_clonable();
    var Lookup = function() {
      function Lookup2() {
        this._map = /* @__PURE__ */ new Map();
      }
      Lookup2.prototype.getMap = function() {
        return this._map;
      };
      Lookup2.prototype.add = function(serviceIdentifier, value) {
        if (serviceIdentifier === null || serviceIdentifier === void 0) {
          throw new Error(ERROR_MSGS.NULL_ARGUMENT);
        }
        if (value === null || value === void 0) {
          throw new Error(ERROR_MSGS.NULL_ARGUMENT);
        }
        var entry = this._map.get(serviceIdentifier);
        if (entry !== void 0) {
          entry.push(value);
        } else {
          this._map.set(serviceIdentifier, [value]);
        }
      };
      Lookup2.prototype.get = function(serviceIdentifier) {
        if (serviceIdentifier === null || serviceIdentifier === void 0) {
          throw new Error(ERROR_MSGS.NULL_ARGUMENT);
        }
        var entry = this._map.get(serviceIdentifier);
        if (entry !== void 0) {
          return entry;
        } else {
          throw new Error(ERROR_MSGS.KEY_NOT_FOUND);
        }
      };
      Lookup2.prototype.remove = function(serviceIdentifier) {
        if (serviceIdentifier === null || serviceIdentifier === void 0) {
          throw new Error(ERROR_MSGS.NULL_ARGUMENT);
        }
        if (!this._map.delete(serviceIdentifier)) {
          throw new Error(ERROR_MSGS.KEY_NOT_FOUND);
        }
      };
      Lookup2.prototype.removeIntersection = function(lookup) {
        var _this = this;
        this.traverse(function(serviceIdentifier, value) {
          var lookupActivations = lookup.hasKey(serviceIdentifier) ? lookup.get(serviceIdentifier) : void 0;
          if (lookupActivations !== void 0) {
            var filteredValues = value.filter(function(lookupValue) {
              return !lookupActivations.some(function(moduleActivation) {
                return lookupValue === moduleActivation;
              });
            });
            _this._setValue(serviceIdentifier, filteredValues);
          }
        });
      };
      Lookup2.prototype.removeByCondition = function(condition) {
        var _this = this;
        var removals = [];
        this._map.forEach(function(entries, key) {
          var updatedEntries = [];
          for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
            var entry = entries_1[_i];
            var remove = condition(entry);
            if (remove) {
              removals.push(entry);
            } else {
              updatedEntries.push(entry);
            }
          }
          _this._setValue(key, updatedEntries);
        });
        return removals;
      };
      Lookup2.prototype.hasKey = function(serviceIdentifier) {
        if (serviceIdentifier === null || serviceIdentifier === void 0) {
          throw new Error(ERROR_MSGS.NULL_ARGUMENT);
        }
        return this._map.has(serviceIdentifier);
      };
      Lookup2.prototype.clone = function() {
        var copy = new Lookup2();
        this._map.forEach(function(value, key) {
          value.forEach(function(b) {
            return copy.add(key, (0, clonable_1.isClonable)(b) ? b.clone() : b);
          });
        });
        return copy;
      };
      Lookup2.prototype.traverse = function(func) {
        this._map.forEach(function(value, key) {
          func(key, value);
        });
      };
      Lookup2.prototype._setValue = function(serviceIdentifier, value) {
        if (value.length > 0) {
          this._map.set(serviceIdentifier, value);
        } else {
          this._map.delete(serviceIdentifier);
        }
      };
      return Lookup2;
    }();
    exports.Lookup = Lookup;
  }
});

// node_modules/inversify/lib/container/module_activation_store.js
var require_module_activation_store = __commonJS({
  "node_modules/inversify/lib/container/module_activation_store.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ModuleActivationStore = void 0;
    var lookup_1 = require_lookup();
    var ModuleActivationStore = function() {
      function ModuleActivationStore2() {
        this._map = /* @__PURE__ */ new Map();
      }
      ModuleActivationStore2.prototype.remove = function(moduleId) {
        if (this._map.has(moduleId)) {
          var handlers = this._map.get(moduleId);
          this._map.delete(moduleId);
          return handlers;
        }
        return this._getEmptyHandlersStore();
      };
      ModuleActivationStore2.prototype.addDeactivation = function(moduleId, serviceIdentifier, onDeactivation) {
        this._getModuleActivationHandlers(moduleId).onDeactivations.add(serviceIdentifier, onDeactivation);
      };
      ModuleActivationStore2.prototype.addActivation = function(moduleId, serviceIdentifier, onActivation) {
        this._getModuleActivationHandlers(moduleId).onActivations.add(serviceIdentifier, onActivation);
      };
      ModuleActivationStore2.prototype.clone = function() {
        var clone = new ModuleActivationStore2();
        this._map.forEach(function(handlersStore, moduleId) {
          clone._map.set(moduleId, {
            onActivations: handlersStore.onActivations.clone(),
            onDeactivations: handlersStore.onDeactivations.clone()
          });
        });
        return clone;
      };
      ModuleActivationStore2.prototype._getModuleActivationHandlers = function(moduleId) {
        var moduleActivationHandlers = this._map.get(moduleId);
        if (moduleActivationHandlers === void 0) {
          moduleActivationHandlers = this._getEmptyHandlersStore();
          this._map.set(moduleId, moduleActivationHandlers);
        }
        return moduleActivationHandlers;
      };
      ModuleActivationStore2.prototype._getEmptyHandlersStore = function() {
        var handlersStore = {
          onActivations: new lookup_1.Lookup(),
          onDeactivations: new lookup_1.Lookup()
        };
        return handlersStore;
      };
      return ModuleActivationStore2;
    }();
    exports.ModuleActivationStore = ModuleActivationStore;
  }
});

// node_modules/inversify/lib/container/container.js
var require_container = __commonJS({
  "node_modules/inversify/lib/container/container.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Container = void 0;
    var binding_1 = require_binding();
    var ERROR_MSGS = __importStar(require_error_msgs());
    var literal_types_1 = require_literal_types();
    var METADATA_KEY = __importStar(require_metadata_keys());
    var metadata_reader_1 = require_metadata_reader();
    var planner_1 = require_planner();
    var resolver_1 = require_resolver();
    var binding_to_syntax_1 = require_binding_to_syntax();
    var async_1 = require_async();
    var id_1 = require_id();
    var serialization_1 = require_serialization();
    var container_snapshot_1 = require_container_snapshot();
    var lookup_1 = require_lookup();
    var module_activation_store_1 = require_module_activation_store();
    var Container2 = function() {
      function Container3(containerOptions) {
        var options = containerOptions || {};
        if (typeof options !== "object") {
          throw new Error("" + ERROR_MSGS.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT);
        }
        if (options.defaultScope === void 0) {
          options.defaultScope = literal_types_1.BindingScopeEnum.Transient;
        } else if (options.defaultScope !== literal_types_1.BindingScopeEnum.Singleton && options.defaultScope !== literal_types_1.BindingScopeEnum.Transient && options.defaultScope !== literal_types_1.BindingScopeEnum.Request) {
          throw new Error("" + ERROR_MSGS.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE);
        }
        if (options.autoBindInjectable === void 0) {
          options.autoBindInjectable = false;
        } else if (typeof options.autoBindInjectable !== "boolean") {
          throw new Error("" + ERROR_MSGS.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE);
        }
        if (options.skipBaseClassChecks === void 0) {
          options.skipBaseClassChecks = false;
        } else if (typeof options.skipBaseClassChecks !== "boolean") {
          throw new Error("" + ERROR_MSGS.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK);
        }
        this.options = {
          autoBindInjectable: options.autoBindInjectable,
          defaultScope: options.defaultScope,
          skipBaseClassChecks: options.skipBaseClassChecks
        };
        this.id = (0, id_1.id)();
        this._bindingDictionary = new lookup_1.Lookup();
        this._snapshots = [];
        this._middleware = null;
        this._activations = new lookup_1.Lookup();
        this._deactivations = new lookup_1.Lookup();
        this.parent = null;
        this._metadataReader = new metadata_reader_1.MetadataReader();
        this._moduleActivationStore = new module_activation_store_1.ModuleActivationStore();
      }
      Container3.merge = function(container1, container2) {
        var containers = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          containers[_i - 2] = arguments[_i];
        }
        var container3 = new Container3();
        var targetContainers = __spreadArray([container1, container2], containers, true).map(function(targetContainer) {
          return (0, planner_1.getBindingDictionary)(targetContainer);
        });
        var bindingDictionary = (0, planner_1.getBindingDictionary)(container3);
        function copyDictionary(origin, destination) {
          origin.traverse(function(_key, value) {
            value.forEach(function(binding) {
              destination.add(binding.serviceIdentifier, binding.clone());
            });
          });
        }
        targetContainers.forEach(function(targetBindingDictionary) {
          copyDictionary(targetBindingDictionary, bindingDictionary);
        });
        return container3;
      };
      Container3.prototype.load = function() {
        var modules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          modules[_i] = arguments[_i];
        }
        var getHelpers = this._getContainerModuleHelpersFactory();
        for (var _a = 0, modules_1 = modules; _a < modules_1.length; _a++) {
          var currentModule = modules_1[_a];
          var containerModuleHelpers = getHelpers(currentModule.id);
          currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction, containerModuleHelpers.unbindAsyncFunction, containerModuleHelpers.onActivationFunction, containerModuleHelpers.onDeactivationFunction);
        }
      };
      Container3.prototype.loadAsync = function() {
        var modules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          modules[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function() {
          var getHelpers, _a, modules_2, currentModule, containerModuleHelpers;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                getHelpers = this._getContainerModuleHelpersFactory();
                _a = 0, modules_2 = modules;
                _b.label = 1;
              case 1:
                if (!(_a < modules_2.length))
                  return [3, 4];
                currentModule = modules_2[_a];
                containerModuleHelpers = getHelpers(currentModule.id);
                return [4, currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction, containerModuleHelpers.unbindAsyncFunction, containerModuleHelpers.onActivationFunction, containerModuleHelpers.onDeactivationFunction)];
              case 2:
                _b.sent();
                _b.label = 3;
              case 3:
                _a++;
                return [3, 1];
              case 4:
                return [2];
            }
          });
        });
      };
      Container3.prototype.unload = function() {
        var _this = this;
        var modules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          modules[_i] = arguments[_i];
        }
        modules.forEach(function(module3) {
          var deactivations = _this._removeModuleBindings(module3.id);
          _this._deactivateSingletons(deactivations);
          _this._removeModuleHandlers(module3.id);
        });
      };
      Container3.prototype.unloadAsync = function() {
        var modules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          modules[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function() {
          var _a, modules_3, module_1, deactivations;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                _a = 0, modules_3 = modules;
                _b.label = 1;
              case 1:
                if (!(_a < modules_3.length))
                  return [3, 4];
                module_1 = modules_3[_a];
                deactivations = this._removeModuleBindings(module_1.id);
                return [4, this._deactivateSingletonsAsync(deactivations)];
              case 2:
                _b.sent();
                this._removeModuleHandlers(module_1.id);
                _b.label = 3;
              case 3:
                _a++;
                return [3, 1];
              case 4:
                return [2];
            }
          });
        });
      };
      Container3.prototype.bind = function(serviceIdentifier) {
        var scope = this.options.defaultScope || literal_types_1.BindingScopeEnum.Transient;
        var binding = new binding_1.Binding(serviceIdentifier, scope);
        this._bindingDictionary.add(serviceIdentifier, binding);
        return new binding_to_syntax_1.BindingToSyntax(binding);
      };
      Container3.prototype.rebind = function(serviceIdentifier) {
        this.unbind(serviceIdentifier);
        return this.bind(serviceIdentifier);
      };
      Container3.prototype.rebindAsync = function(serviceIdentifier) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.unbindAsync(serviceIdentifier)];
              case 1:
                _a.sent();
                return [2, this.bind(serviceIdentifier)];
            }
          });
        });
      };
      Container3.prototype.unbind = function(serviceIdentifier) {
        if (this._bindingDictionary.hasKey(serviceIdentifier)) {
          var bindings = this._bindingDictionary.get(serviceIdentifier);
          this._deactivateSingletons(bindings);
        }
        this._removeServiceFromDictionary(serviceIdentifier);
      };
      Container3.prototype.unbindAsync = function(serviceIdentifier) {
        return __awaiter(this, void 0, void 0, function() {
          var bindings;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!this._bindingDictionary.hasKey(serviceIdentifier))
                  return [3, 2];
                bindings = this._bindingDictionary.get(serviceIdentifier);
                return [4, this._deactivateSingletonsAsync(bindings)];
              case 1:
                _a.sent();
                _a.label = 2;
              case 2:
                this._removeServiceFromDictionary(serviceIdentifier);
                return [2];
            }
          });
        });
      };
      Container3.prototype.unbindAll = function() {
        var _this = this;
        this._bindingDictionary.traverse(function(_key, value) {
          _this._deactivateSingletons(value);
        });
        this._bindingDictionary = new lookup_1.Lookup();
      };
      Container3.prototype.unbindAllAsync = function() {
        return __awaiter(this, void 0, void 0, function() {
          var promises;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                promises = [];
                this._bindingDictionary.traverse(function(_key, value) {
                  promises.push(_this._deactivateSingletonsAsync(value));
                });
                return [4, Promise.all(promises)];
              case 1:
                _a.sent();
                this._bindingDictionary = new lookup_1.Lookup();
                return [2];
            }
          });
        });
      };
      Container3.prototype.onActivation = function(serviceIdentifier, onActivation) {
        this._activations.add(serviceIdentifier, onActivation);
      };
      Container3.prototype.onDeactivation = function(serviceIdentifier, onDeactivation) {
        this._deactivations.add(serviceIdentifier, onDeactivation);
      };
      Container3.prototype.isBound = function(serviceIdentifier) {
        var bound = this._bindingDictionary.hasKey(serviceIdentifier);
        if (!bound && this.parent) {
          bound = this.parent.isBound(serviceIdentifier);
        }
        return bound;
      };
      Container3.prototype.isCurrentBound = function(serviceIdentifier) {
        return this._bindingDictionary.hasKey(serviceIdentifier);
      };
      Container3.prototype.isBoundNamed = function(serviceIdentifier, named2) {
        return this.isBoundTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named2);
      };
      Container3.prototype.isBoundTagged = function(serviceIdentifier, key, value) {
        var bound = false;
        if (this._bindingDictionary.hasKey(serviceIdentifier)) {
          var bindings = this._bindingDictionary.get(serviceIdentifier);
          var request_1 = (0, planner_1.createMockRequest)(this, serviceIdentifier, key, value);
          bound = bindings.some(function(b) {
            return b.constraint(request_1);
          });
        }
        if (!bound && this.parent) {
          bound = this.parent.isBoundTagged(serviceIdentifier, key, value);
        }
        return bound;
      };
      Container3.prototype.snapshot = function() {
        this._snapshots.push(container_snapshot_1.ContainerSnapshot.of(this._bindingDictionary.clone(), this._middleware, this._activations.clone(), this._deactivations.clone(), this._moduleActivationStore.clone()));
      };
      Container3.prototype.restore = function() {
        var snapshot = this._snapshots.pop();
        if (snapshot === void 0) {
          throw new Error(ERROR_MSGS.NO_MORE_SNAPSHOTS_AVAILABLE);
        }
        this._bindingDictionary = snapshot.bindings;
        this._activations = snapshot.activations;
        this._deactivations = snapshot.deactivations;
        this._middleware = snapshot.middleware;
        this._moduleActivationStore = snapshot.moduleActivationStore;
      };
      Container3.prototype.createChild = function(containerOptions) {
        var child = new Container3(containerOptions || this.options);
        child.parent = this;
        return child;
      };
      Container3.prototype.applyMiddleware = function() {
        var middlewares = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          middlewares[_i] = arguments[_i];
        }
        var initial = this._middleware ? this._middleware : this._planAndResolve();
        this._middleware = middlewares.reduce(function(prev, curr) {
          return curr(prev);
        }, initial);
      };
      Container3.prototype.applyCustomMetadataReader = function(metadataReader) {
        this._metadataReader = metadataReader;
      };
      Container3.prototype.get = function(serviceIdentifier) {
        var getArgs = this._getNotAllArgs(serviceIdentifier, false);
        return this._getButThrowIfAsync(getArgs);
      };
      Container3.prototype.getAsync = function(serviceIdentifier) {
        return __awaiter(this, void 0, void 0, function() {
          var getArgs;
          return __generator(this, function(_a) {
            getArgs = this._getNotAllArgs(serviceIdentifier, false);
            return [2, this._get(getArgs)];
          });
        });
      };
      Container3.prototype.getTagged = function(serviceIdentifier, key, value) {
        var getArgs = this._getNotAllArgs(serviceIdentifier, false, key, value);
        return this._getButThrowIfAsync(getArgs);
      };
      Container3.prototype.getTaggedAsync = function(serviceIdentifier, key, value) {
        return __awaiter(this, void 0, void 0, function() {
          var getArgs;
          return __generator(this, function(_a) {
            getArgs = this._getNotAllArgs(serviceIdentifier, false, key, value);
            return [2, this._get(getArgs)];
          });
        });
      };
      Container3.prototype.getNamed = function(serviceIdentifier, named2) {
        return this.getTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named2);
      };
      Container3.prototype.getNamedAsync = function(serviceIdentifier, named2) {
        return this.getTaggedAsync(serviceIdentifier, METADATA_KEY.NAMED_TAG, named2);
      };
      Container3.prototype.getAll = function(serviceIdentifier) {
        var getArgs = this._getAllArgs(serviceIdentifier);
        return this._getButThrowIfAsync(getArgs);
      };
      Container3.prototype.getAllAsync = function(serviceIdentifier) {
        var getArgs = this._getAllArgs(serviceIdentifier);
        return this._getAll(getArgs);
      };
      Container3.prototype.getAllTagged = function(serviceIdentifier, key, value) {
        var getArgs = this._getNotAllArgs(serviceIdentifier, true, key, value);
        return this._getButThrowIfAsync(getArgs);
      };
      Container3.prototype.getAllTaggedAsync = function(serviceIdentifier, key, value) {
        var getArgs = this._getNotAllArgs(serviceIdentifier, true, key, value);
        return this._getAll(getArgs);
      };
      Container3.prototype.getAllNamed = function(serviceIdentifier, named2) {
        return this.getAllTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named2);
      };
      Container3.prototype.getAllNamedAsync = function(serviceIdentifier, named2) {
        return this.getAllTaggedAsync(serviceIdentifier, METADATA_KEY.NAMED_TAG, named2);
      };
      Container3.prototype.resolve = function(constructorFunction) {
        var isBound = this.isBound(constructorFunction);
        if (!isBound) {
          this.bind(constructorFunction).toSelf();
        }
        var resolved = this.get(constructorFunction);
        if (!isBound) {
          this.unbind(constructorFunction);
        }
        return resolved;
      };
      Container3.prototype._preDestroy = function(constructor, instance) {
        if (Reflect.hasMetadata(METADATA_KEY.PRE_DESTROY, constructor)) {
          var data = Reflect.getMetadata(METADATA_KEY.PRE_DESTROY, constructor);
          return instance[data.value]();
        }
      };
      Container3.prototype._removeModuleHandlers = function(moduleId) {
        var moduleActivationsHandlers = this._moduleActivationStore.remove(moduleId);
        this._activations.removeIntersection(moduleActivationsHandlers.onActivations);
        this._deactivations.removeIntersection(moduleActivationsHandlers.onDeactivations);
      };
      Container3.prototype._removeModuleBindings = function(moduleId) {
        return this._bindingDictionary.removeByCondition(function(binding) {
          return binding.moduleId === moduleId;
        });
      };
      Container3.prototype._deactivate = function(binding, instance) {
        var _this = this;
        var constructor = Object.getPrototypeOf(instance).constructor;
        try {
          if (this._deactivations.hasKey(binding.serviceIdentifier)) {
            var result = this._deactivateContainer(instance, this._deactivations.get(binding.serviceIdentifier).values());
            if ((0, async_1.isPromise)(result)) {
              return this._handleDeactivationError(result.then(function() {
                return _this._propagateContainerDeactivationThenBindingAndPreDestroyAsync(binding, instance, constructor);
              }), constructor);
            }
          }
          var propagateDeactivationResult = this._propagateContainerDeactivationThenBindingAndPreDestroy(binding, instance, constructor);
          if ((0, async_1.isPromise)(propagateDeactivationResult)) {
            return this._handleDeactivationError(propagateDeactivationResult, constructor);
          }
        } catch (ex) {
          throw new Error(ERROR_MSGS.ON_DEACTIVATION_ERROR(constructor.name, ex.message));
        }
      };
      Container3.prototype._handleDeactivationError = function(asyncResult, constructor) {
        return __awaiter(this, void 0, void 0, function() {
          var ex_1;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                _a.trys.push([0, 2, , 3]);
                return [4, asyncResult];
              case 1:
                _a.sent();
                return [3, 3];
              case 2:
                ex_1 = _a.sent();
                throw new Error(ERROR_MSGS.ON_DEACTIVATION_ERROR(constructor.name, ex_1.message));
              case 3:
                return [2];
            }
          });
        });
      };
      Container3.prototype._deactivateContainer = function(instance, deactivationsIterator) {
        var _this = this;
        var deactivation = deactivationsIterator.next();
        while (deactivation.value) {
          var result = deactivation.value(instance);
          if ((0, async_1.isPromise)(result)) {
            return result.then(function() {
              return _this._deactivateContainerAsync(instance, deactivationsIterator);
            });
          }
          deactivation = deactivationsIterator.next();
        }
      };
      Container3.prototype._deactivateContainerAsync = function(instance, deactivationsIterator) {
        return __awaiter(this, void 0, void 0, function() {
          var deactivation;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                deactivation = deactivationsIterator.next();
                _a.label = 1;
              case 1:
                if (!deactivation.value)
                  return [3, 3];
                return [4, deactivation.value(instance)];
              case 2:
                _a.sent();
                deactivation = deactivationsIterator.next();
                return [3, 1];
              case 3:
                return [2];
            }
          });
        });
      };
      Container3.prototype._getContainerModuleHelpersFactory = function() {
        var _this = this;
        var setModuleId = function(bindingToSyntax, moduleId) {
          bindingToSyntax._binding.moduleId = moduleId;
        };
        var getBindFunction = function(moduleId) {
          return function(serviceIdentifier) {
            var bindingToSyntax = _this.bind(serviceIdentifier);
            setModuleId(bindingToSyntax, moduleId);
            return bindingToSyntax;
          };
        };
        var getUnbindFunction = function() {
          return function(serviceIdentifier) {
            return _this.unbind(serviceIdentifier);
          };
        };
        var getUnbindAsyncFunction = function() {
          return function(serviceIdentifier) {
            return _this.unbindAsync(serviceIdentifier);
          };
        };
        var getIsboundFunction = function() {
          return function(serviceIdentifier) {
            return _this.isBound(serviceIdentifier);
          };
        };
        var getRebindFunction = function(moduleId) {
          return function(serviceIdentifier) {
            var bindingToSyntax = _this.rebind(serviceIdentifier);
            setModuleId(bindingToSyntax, moduleId);
            return bindingToSyntax;
          };
        };
        var getOnActivationFunction = function(moduleId) {
          return function(serviceIdentifier, onActivation) {
            _this._moduleActivationStore.addActivation(moduleId, serviceIdentifier, onActivation);
            _this.onActivation(serviceIdentifier, onActivation);
          };
        };
        var getOnDeactivationFunction = function(moduleId) {
          return function(serviceIdentifier, onDeactivation) {
            _this._moduleActivationStore.addDeactivation(moduleId, serviceIdentifier, onDeactivation);
            _this.onDeactivation(serviceIdentifier, onDeactivation);
          };
        };
        return function(mId) {
          return {
            bindFunction: getBindFunction(mId),
            isboundFunction: getIsboundFunction(),
            onActivationFunction: getOnActivationFunction(mId),
            onDeactivationFunction: getOnDeactivationFunction(mId),
            rebindFunction: getRebindFunction(mId),
            unbindFunction: getUnbindFunction(),
            unbindAsyncFunction: getUnbindAsyncFunction()
          };
        };
      };
      Container3.prototype._getAll = function(getArgs) {
        return Promise.all(this._get(getArgs));
      };
      Container3.prototype._get = function(getArgs) {
        var planAndResolveArgs = __assign(__assign({}, getArgs), { contextInterceptor: function(context) {
          return context;
        }, targetType: literal_types_1.TargetTypeEnum.Variable });
        if (this._middleware) {
          var middlewareResult = this._middleware(planAndResolveArgs);
          if (middlewareResult === void 0 || middlewareResult === null) {
            throw new Error(ERROR_MSGS.INVALID_MIDDLEWARE_RETURN);
          }
          return middlewareResult;
        }
        return this._planAndResolve()(planAndResolveArgs);
      };
      Container3.prototype._getButThrowIfAsync = function(getArgs) {
        var result = this._get(getArgs);
        if ((0, async_1.isPromiseOrContainsPromise)(result)) {
          throw new Error(ERROR_MSGS.LAZY_IN_SYNC(getArgs.serviceIdentifier));
        }
        return result;
      };
      Container3.prototype._getAllArgs = function(serviceIdentifier) {
        var getAllArgs = {
          avoidConstraints: true,
          isMultiInject: true,
          serviceIdentifier
        };
        return getAllArgs;
      };
      Container3.prototype._getNotAllArgs = function(serviceIdentifier, isMultiInject, key, value) {
        var getNotAllArgs = {
          avoidConstraints: false,
          isMultiInject,
          serviceIdentifier,
          key,
          value
        };
        return getNotAllArgs;
      };
      Container3.prototype._planAndResolve = function() {
        var _this = this;
        return function(args) {
          var context = (0, planner_1.plan)(_this._metadataReader, _this, args.isMultiInject, args.targetType, args.serviceIdentifier, args.key, args.value, args.avoidConstraints);
          context = args.contextInterceptor(context);
          var result = (0, resolver_1.resolve)(context);
          return result;
        };
      };
      Container3.prototype._deactivateIfSingleton = function(binding) {
        var _this = this;
        if (!binding.activated) {
          return;
        }
        if ((0, async_1.isPromise)(binding.cache)) {
          return binding.cache.then(function(resolved) {
            return _this._deactivate(binding, resolved);
          });
        }
        return this._deactivate(binding, binding.cache);
      };
      Container3.prototype._deactivateSingletons = function(bindings) {
        for (var _i = 0, bindings_1 = bindings; _i < bindings_1.length; _i++) {
          var binding = bindings_1[_i];
          var result = this._deactivateIfSingleton(binding);
          if ((0, async_1.isPromise)(result)) {
            throw new Error(ERROR_MSGS.ASYNC_UNBIND_REQUIRED);
          }
        }
      };
      Container3.prototype._deactivateSingletonsAsync = function(bindings) {
        return __awaiter(this, void 0, void 0, function() {
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, Promise.all(bindings.map(function(b) {
                  return _this._deactivateIfSingleton(b);
                }))];
              case 1:
                _a.sent();
                return [2];
            }
          });
        });
      };
      Container3.prototype._propagateContainerDeactivationThenBindingAndPreDestroy = function(binding, instance, constructor) {
        if (this.parent) {
          return this._deactivate.bind(this.parent)(binding, instance);
        } else {
          return this._bindingDeactivationAndPreDestroy(binding, instance, constructor);
        }
      };
      Container3.prototype._propagateContainerDeactivationThenBindingAndPreDestroyAsync = function(binding, instance, constructor) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!this.parent)
                  return [3, 2];
                return [4, this._deactivate.bind(this.parent)(binding, instance)];
              case 1:
                _a.sent();
                return [3, 4];
              case 2:
                return [4, this._bindingDeactivationAndPreDestroyAsync(binding, instance, constructor)];
              case 3:
                _a.sent();
                _a.label = 4;
              case 4:
                return [2];
            }
          });
        });
      };
      Container3.prototype._removeServiceFromDictionary = function(serviceIdentifier) {
        try {
          this._bindingDictionary.remove(serviceIdentifier);
        } catch (e) {
          throw new Error(ERROR_MSGS.CANNOT_UNBIND + " " + (0, serialization_1.getServiceIdentifierAsString)(serviceIdentifier));
        }
      };
      Container3.prototype._bindingDeactivationAndPreDestroy = function(binding, instance, constructor) {
        var _this = this;
        if (typeof binding.onDeactivation === "function") {
          var result = binding.onDeactivation(instance);
          if ((0, async_1.isPromise)(result)) {
            return result.then(function() {
              return _this._preDestroy(constructor, instance);
            });
          }
        }
        return this._preDestroy(constructor, instance);
      };
      Container3.prototype._bindingDeactivationAndPreDestroyAsync = function(binding, instance, constructor) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!(typeof binding.onDeactivation === "function"))
                  return [3, 2];
                return [4, binding.onDeactivation(instance)];
              case 1:
                _a.sent();
                _a.label = 2;
              case 2:
                return [4, this._preDestroy(constructor, instance)];
              case 3:
                _a.sent();
                return [2];
            }
          });
        });
      };
      return Container3;
    }();
    exports.Container = Container2;
  }
});

// node_modules/inversify/lib/container/container_module.js
var require_container_module = __commonJS({
  "node_modules/inversify/lib/container/container_module.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncContainerModule = exports.ContainerModule = void 0;
    var id_1 = require_id();
    var ContainerModule = function() {
      function ContainerModule2(registry) {
        this.id = (0, id_1.id)();
        this.registry = registry;
      }
      return ContainerModule2;
    }();
    exports.ContainerModule = ContainerModule;
    var AsyncContainerModule = function() {
      function AsyncContainerModule2(registry) {
        this.id = (0, id_1.id)();
        this.registry = registry;
      }
      return AsyncContainerModule2;
    }();
    exports.AsyncContainerModule = AsyncContainerModule;
  }
});

// node_modules/inversify/lib/utils/js.js
var require_js = __commonJS({
  "node_modules/inversify/lib/utils/js.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFirstArrayDuplicate = void 0;
    function getFirstArrayDuplicate(array) {
      var seenValues = /* @__PURE__ */ new Set();
      for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
        var entry = array_1[_i];
        if (seenValues.has(entry)) {
          return entry;
        } else {
          seenValues.add(entry);
        }
      }
      return void 0;
    }
    exports.getFirstArrayDuplicate = getFirstArrayDuplicate;
  }
});

// node_modules/inversify/lib/annotation/decorator_utils.js
var require_decorator_utils = __commonJS({
  "node_modules/inversify/lib/annotation/decorator_utils.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTaggedDecorator = exports.tagProperty = exports.tagParameter = exports.decorate = void 0;
    var ERROR_MSGS = __importStar(require_error_msgs());
    var METADATA_KEY = __importStar(require_metadata_keys());
    var js_1 = require_js();
    function targetIsConstructorFunction(target) {
      return target.prototype !== void 0;
    }
    function _throwIfMethodParameter(parameterName) {
      if (parameterName !== void 0) {
        throw new Error(ERROR_MSGS.INVALID_DECORATOR_OPERATION);
      }
    }
    function tagParameter(annotationTarget, parameterName, parameterIndex, metadata) {
      _throwIfMethodParameter(parameterName);
      _tagParameterOrProperty(METADATA_KEY.TAGGED, annotationTarget, parameterIndex.toString(), metadata);
    }
    exports.tagParameter = tagParameter;
    function tagProperty(annotationTarget, propertyName, metadata) {
      if (targetIsConstructorFunction(annotationTarget)) {
        throw new Error(ERROR_MSGS.INVALID_DECORATOR_OPERATION);
      }
      _tagParameterOrProperty(METADATA_KEY.TAGGED_PROP, annotationTarget.constructor, propertyName, metadata);
    }
    exports.tagProperty = tagProperty;
    function _ensureNoMetadataKeyDuplicates(metadata) {
      var metadatas = [];
      if (Array.isArray(metadata)) {
        metadatas = metadata;
        var duplicate = (0, js_1.getFirstArrayDuplicate)(metadatas.map(function(md) {
          return md.key;
        }));
        if (duplicate !== void 0) {
          throw new Error(ERROR_MSGS.DUPLICATED_METADATA + " " + duplicate.toString());
        }
      } else {
        metadatas = [metadata];
      }
      return metadatas;
    }
    function _tagParameterOrProperty(metadataKey, annotationTarget, key, metadata) {
      var metadatas = _ensureNoMetadataKeyDuplicates(metadata);
      var paramsOrPropertiesMetadata = {};
      if (Reflect.hasOwnMetadata(metadataKey, annotationTarget)) {
        paramsOrPropertiesMetadata = Reflect.getMetadata(metadataKey, annotationTarget);
      }
      var paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];
      if (paramOrPropertyMetadata === void 0) {
        paramOrPropertyMetadata = [];
      } else {
        var _loop_1 = function(m2) {
          if (metadatas.some(function(md) {
            return md.key === m2.key;
          })) {
            throw new Error(ERROR_MSGS.DUPLICATED_METADATA + " " + m2.key.toString());
          }
        };
        for (var _i = 0, paramOrPropertyMetadata_1 = paramOrPropertyMetadata; _i < paramOrPropertyMetadata_1.length; _i++) {
          var m = paramOrPropertyMetadata_1[_i];
          _loop_1(m);
        }
      }
      paramOrPropertyMetadata.push.apply(paramOrPropertyMetadata, metadatas);
      paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata;
      Reflect.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
    }
    function createTaggedDecorator(metadata) {
      return function(target, targetKey, indexOrPropertyDescriptor) {
        if (typeof indexOrPropertyDescriptor === "number") {
          tagParameter(target, targetKey, indexOrPropertyDescriptor, metadata);
        } else {
          tagProperty(target, targetKey, metadata);
        }
      };
    }
    exports.createTaggedDecorator = createTaggedDecorator;
    function _decorate(decorators, target) {
      Reflect.decorate(decorators, target);
    }
    function _param(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    }
    function decorate(decorator, target, parameterIndexOrProperty) {
      if (typeof parameterIndexOrProperty === "number") {
        _decorate([_param(parameterIndexOrProperty, decorator)], target);
      } else if (typeof parameterIndexOrProperty === "string") {
        Reflect.decorate([decorator], target, parameterIndexOrProperty);
      } else {
        _decorate([decorator], target);
      }
    }
    exports.decorate = decorate;
  }
});

// node_modules/inversify/lib/annotation/injectable.js
var require_injectable = __commonJS({
  "node_modules/inversify/lib/annotation/injectable.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.injectable = void 0;
    var ERRORS_MSGS = __importStar(require_error_msgs());
    var METADATA_KEY = __importStar(require_metadata_keys());
    function injectable4() {
      return function(target) {
        if (Reflect.hasOwnMetadata(METADATA_KEY.PARAM_TYPES, target)) {
          throw new Error(ERRORS_MSGS.DUPLICATED_INJECTABLE_DECORATOR);
        }
        var types = Reflect.getMetadata(METADATA_KEY.DESIGN_PARAM_TYPES, target) || [];
        Reflect.defineMetadata(METADATA_KEY.PARAM_TYPES, types, target);
        return target;
      };
    }
    exports.injectable = injectable4;
  }
});

// node_modules/inversify/lib/annotation/tagged.js
var require_tagged = __commonJS({
  "node_modules/inversify/lib/annotation/tagged.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tagged = void 0;
    var metadata_1 = require_metadata();
    var decorator_utils_1 = require_decorator_utils();
    function tagged(metadataKey, metadataValue) {
      return (0, decorator_utils_1.createTaggedDecorator)(new metadata_1.Metadata(metadataKey, metadataValue));
    }
    exports.tagged = tagged;
  }
});

// node_modules/inversify/lib/annotation/named.js
var require_named = __commonJS({
  "node_modules/inversify/lib/annotation/named.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.named = void 0;
    var METADATA_KEY = __importStar(require_metadata_keys());
    var metadata_1 = require_metadata();
    var decorator_utils_1 = require_decorator_utils();
    function named2(name) {
      return (0, decorator_utils_1.createTaggedDecorator)(new metadata_1.Metadata(METADATA_KEY.NAMED_TAG, name));
    }
    exports.named = named2;
  }
});

// node_modules/inversify/lib/annotation/inject_base.js
var require_inject_base = __commonJS({
  "node_modules/inversify/lib/annotation/inject_base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.injectBase = void 0;
    var error_msgs_1 = require_error_msgs();
    var metadata_1 = require_metadata();
    var decorator_utils_1 = require_decorator_utils();
    function injectBase(metadataKey) {
      return function(serviceIdentifier) {
        return function(target, targetKey, indexOrPropertyDescriptor) {
          if (serviceIdentifier === void 0) {
            var className = typeof target === "function" ? target.name : target.constructor.name;
            throw new Error((0, error_msgs_1.UNDEFINED_INJECT_ANNOTATION)(className));
          }
          return (0, decorator_utils_1.createTaggedDecorator)(new metadata_1.Metadata(metadataKey, serviceIdentifier))(target, targetKey, indexOrPropertyDescriptor);
        };
      };
    }
    exports.injectBase = injectBase;
  }
});

// node_modules/inversify/lib/annotation/inject.js
var require_inject = __commonJS({
  "node_modules/inversify/lib/annotation/inject.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.inject = void 0;
    var METADATA_KEY = __importStar(require_metadata_keys());
    var inject_base_1 = require_inject_base();
    var inject2 = (0, inject_base_1.injectBase)(METADATA_KEY.INJECT_TAG);
    exports.inject = inject2;
  }
});

// node_modules/inversify/lib/annotation/optional.js
var require_optional = __commonJS({
  "node_modules/inversify/lib/annotation/optional.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.optional = void 0;
    var METADATA_KEY = __importStar(require_metadata_keys());
    var metadata_1 = require_metadata();
    var decorator_utils_1 = require_decorator_utils();
    function optional() {
      return (0, decorator_utils_1.createTaggedDecorator)(new metadata_1.Metadata(METADATA_KEY.OPTIONAL_TAG, true));
    }
    exports.optional = optional;
  }
});

// node_modules/inversify/lib/annotation/unmanaged.js
var require_unmanaged = __commonJS({
  "node_modules/inversify/lib/annotation/unmanaged.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unmanaged = void 0;
    var METADATA_KEY = __importStar(require_metadata_keys());
    var metadata_1 = require_metadata();
    var decorator_utils_1 = require_decorator_utils();
    function unmanaged() {
      return function(target, targetKey, index) {
        var metadata = new metadata_1.Metadata(METADATA_KEY.UNMANAGED_TAG, true);
        (0, decorator_utils_1.tagParameter)(target, targetKey, index, metadata);
      };
    }
    exports.unmanaged = unmanaged;
  }
});

// node_modules/inversify/lib/annotation/multi_inject.js
var require_multi_inject = __commonJS({
  "node_modules/inversify/lib/annotation/multi_inject.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.multiInject = void 0;
    var METADATA_KEY = __importStar(require_metadata_keys());
    var inject_base_1 = require_inject_base();
    var multiInject = (0, inject_base_1.injectBase)(METADATA_KEY.MULTI_INJECT_TAG);
    exports.multiInject = multiInject;
  }
});

// node_modules/inversify/lib/annotation/target_name.js
var require_target_name = __commonJS({
  "node_modules/inversify/lib/annotation/target_name.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.targetName = void 0;
    var METADATA_KEY = __importStar(require_metadata_keys());
    var metadata_1 = require_metadata();
    var decorator_utils_1 = require_decorator_utils();
    function targetName(name) {
      return function(target, targetKey, index) {
        var metadata = new metadata_1.Metadata(METADATA_KEY.NAME_TAG, name);
        (0, decorator_utils_1.tagParameter)(target, targetKey, index, metadata);
      };
    }
    exports.targetName = targetName;
  }
});

// node_modules/inversify/lib/annotation/property_event_decorator.js
var require_property_event_decorator = __commonJS({
  "node_modules/inversify/lib/annotation/property_event_decorator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.propertyEventDecorator = void 0;
    var metadata_1 = require_metadata();
    function propertyEventDecorator(eventKey, errorMessage) {
      return function() {
        return function(target, propertyKey) {
          var metadata = new metadata_1.Metadata(eventKey, propertyKey);
          if (Reflect.hasOwnMetadata(eventKey, target.constructor)) {
            throw new Error(errorMessage);
          }
          Reflect.defineMetadata(eventKey, metadata, target.constructor);
        };
      };
    }
    exports.propertyEventDecorator = propertyEventDecorator;
  }
});

// node_modules/inversify/lib/annotation/post_construct.js
var require_post_construct = __commonJS({
  "node_modules/inversify/lib/annotation/post_construct.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.postConstruct = void 0;
    var ERRORS_MSGS = __importStar(require_error_msgs());
    var METADATA_KEY = __importStar(require_metadata_keys());
    var property_event_decorator_1 = require_property_event_decorator();
    var postConstruct = (0, property_event_decorator_1.propertyEventDecorator)(METADATA_KEY.POST_CONSTRUCT, ERRORS_MSGS.MULTIPLE_POST_CONSTRUCT_METHODS);
    exports.postConstruct = postConstruct;
  }
});

// node_modules/inversify/lib/annotation/pre_destroy.js
var require_pre_destroy = __commonJS({
  "node_modules/inversify/lib/annotation/pre_destroy.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.preDestroy = void 0;
    var ERRORS_MSGS = __importStar(require_error_msgs());
    var METADATA_KEY = __importStar(require_metadata_keys());
    var property_event_decorator_1 = require_property_event_decorator();
    var preDestroy = (0, property_event_decorator_1.propertyEventDecorator)(METADATA_KEY.PRE_DESTROY, ERRORS_MSGS.MULTIPLE_PRE_DESTROY_METHODS);
    exports.preDestroy = preDestroy;
  }
});

// node_modules/inversify/lib/interfaces/interfaces.js
var require_interfaces = __commonJS({
  "node_modules/inversify/lib/interfaces/interfaces.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.interfaces = void 0;
    var interfaces;
    (function(interfaces2) {
      ;
    })(interfaces || (interfaces = {}));
    exports.interfaces = interfaces;
  }
});

// node_modules/inversify/lib/inversify.js
var require_inversify = __commonJS({
  "node_modules/inversify/lib/inversify.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.multiBindToService = exports.getServiceIdentifierAsString = exports.typeConstraint = exports.namedConstraint = exports.taggedConstraint = exports.traverseAncerstors = exports.decorate = exports.interfaces = exports.id = exports.MetadataReader = exports.preDestroy = exports.postConstruct = exports.targetName = exports.multiInject = exports.unmanaged = exports.optional = exports.LazyServiceIdentifer = exports.inject = exports.named = exports.tagged = exports.injectable = exports.createTaggedDecorator = exports.ContainerModule = exports.AsyncContainerModule = exports.TargetTypeEnum = exports.BindingTypeEnum = exports.BindingScopeEnum = exports.Container = exports.METADATA_KEY = void 0;
    var keys = __importStar(require_metadata_keys());
    exports.METADATA_KEY = keys;
    var container_1 = require_container();
    Object.defineProperty(exports, "Container", { enumerable: true, get: function() {
      return container_1.Container;
    } });
    var literal_types_1 = require_literal_types();
    Object.defineProperty(exports, "BindingScopeEnum", { enumerable: true, get: function() {
      return literal_types_1.BindingScopeEnum;
    } });
    Object.defineProperty(exports, "BindingTypeEnum", { enumerable: true, get: function() {
      return literal_types_1.BindingTypeEnum;
    } });
    Object.defineProperty(exports, "TargetTypeEnum", { enumerable: true, get: function() {
      return literal_types_1.TargetTypeEnum;
    } });
    var container_module_1 = require_container_module();
    Object.defineProperty(exports, "AsyncContainerModule", { enumerable: true, get: function() {
      return container_module_1.AsyncContainerModule;
    } });
    Object.defineProperty(exports, "ContainerModule", { enumerable: true, get: function() {
      return container_module_1.ContainerModule;
    } });
    var decorator_utils_1 = require_decorator_utils();
    Object.defineProperty(exports, "createTaggedDecorator", { enumerable: true, get: function() {
      return decorator_utils_1.createTaggedDecorator;
    } });
    var injectable_1 = require_injectable();
    Object.defineProperty(exports, "injectable", { enumerable: true, get: function() {
      return injectable_1.injectable;
    } });
    var tagged_1 = require_tagged();
    Object.defineProperty(exports, "tagged", { enumerable: true, get: function() {
      return tagged_1.tagged;
    } });
    var named_1 = require_named();
    Object.defineProperty(exports, "named", { enumerable: true, get: function() {
      return named_1.named;
    } });
    var inject_1 = require_inject();
    Object.defineProperty(exports, "inject", { enumerable: true, get: function() {
      return inject_1.inject;
    } });
    var lazy_service_identifier_1 = require_lazy_service_identifier();
    Object.defineProperty(exports, "LazyServiceIdentifer", { enumerable: true, get: function() {
      return lazy_service_identifier_1.LazyServiceIdentifer;
    } });
    var optional_1 = require_optional();
    Object.defineProperty(exports, "optional", { enumerable: true, get: function() {
      return optional_1.optional;
    } });
    var unmanaged_1 = require_unmanaged();
    Object.defineProperty(exports, "unmanaged", { enumerable: true, get: function() {
      return unmanaged_1.unmanaged;
    } });
    var multi_inject_1 = require_multi_inject();
    Object.defineProperty(exports, "multiInject", { enumerable: true, get: function() {
      return multi_inject_1.multiInject;
    } });
    var target_name_1 = require_target_name();
    Object.defineProperty(exports, "targetName", { enumerable: true, get: function() {
      return target_name_1.targetName;
    } });
    var post_construct_1 = require_post_construct();
    Object.defineProperty(exports, "postConstruct", { enumerable: true, get: function() {
      return post_construct_1.postConstruct;
    } });
    var pre_destroy_1 = require_pre_destroy();
    Object.defineProperty(exports, "preDestroy", { enumerable: true, get: function() {
      return pre_destroy_1.preDestroy;
    } });
    var metadata_reader_1 = require_metadata_reader();
    Object.defineProperty(exports, "MetadataReader", { enumerable: true, get: function() {
      return metadata_reader_1.MetadataReader;
    } });
    var id_1 = require_id();
    Object.defineProperty(exports, "id", { enumerable: true, get: function() {
      return id_1.id;
    } });
    var interfaces_1 = require_interfaces();
    Object.defineProperty(exports, "interfaces", { enumerable: true, get: function() {
      return interfaces_1.interfaces;
    } });
    var decorator_utils_2 = require_decorator_utils();
    Object.defineProperty(exports, "decorate", { enumerable: true, get: function() {
      return decorator_utils_2.decorate;
    } });
    var constraint_helpers_1 = require_constraint_helpers();
    Object.defineProperty(exports, "traverseAncerstors", { enumerable: true, get: function() {
      return constraint_helpers_1.traverseAncerstors;
    } });
    Object.defineProperty(exports, "taggedConstraint", { enumerable: true, get: function() {
      return constraint_helpers_1.taggedConstraint;
    } });
    Object.defineProperty(exports, "namedConstraint", { enumerable: true, get: function() {
      return constraint_helpers_1.namedConstraint;
    } });
    Object.defineProperty(exports, "typeConstraint", { enumerable: true, get: function() {
      return constraint_helpers_1.typeConstraint;
    } });
    var serialization_1 = require_serialization();
    Object.defineProperty(exports, "getServiceIdentifierAsString", { enumerable: true, get: function() {
      return serialization_1.getServiceIdentifierAsString;
    } });
    var binding_utils_1 = require_binding_utils();
    Object.defineProperty(exports, "multiBindToService", { enumerable: true, get: function() {
      return binding_utils_1.multiBindToService;
    } });
  }
});

// node_modules/rollbar/package.json
var require_package = __commonJS({
  "node_modules/rollbar/package.json"(exports, module2) {
    module2.exports = {
      name: "rollbar",
      version: "2.25.0",
      repository: {
        type: "git",
        url: "http://github.com/rollbar/rollbar.js"
      },
      description: "Error tracking and logging from JS to Rollbar",
      license: "MIT",
      main: "src/server/rollbar.js",
      browser: "dist/rollbar.umd.min.js",
      types: "./index.d.ts",
      dependencies: {
        async: "~3.2.3",
        "console-polyfill": "0.3.0",
        "error-stack-parser": "^2.0.4",
        "json-stringify-safe": "~5.0.0",
        "lru-cache": "~2.2.1",
        "request-ip": "~2.0.1",
        "source-map": "^0.5.7"
      },
      devDependencies: {
        "babel-core": "^6.26.3",
        "babel-eslint": "^10.0.3",
        "babel-loader": "^8.0.4",
        bluebird: "^3.3.5",
        "browserstack-api": "0.0.5",
        chai: "^4.2.0",
        chalk: "^1.1.1",
        eslint: "^6.8.0",
        "eslint-loader": "^3.0.3",
        express: "^4.16.4",
        glob: "^5.0.14",
        grunt: "^1.1.0",
        "grunt-bumpup": "^0.6.3",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-concat": "~0.3.0",
        "grunt-contrib-connect": "^2.1.0",
        "grunt-contrib-copy": "~0.5.0",
        "grunt-contrib-jshint": "^2.1.0",
        "grunt-contrib-uglify": "^4.0.0",
        "grunt-contrib-watch": "^1.1.0",
        "grunt-karma": "^3.0.2",
        "grunt-parallel": "^0.5.1",
        "grunt-text-replace": "^0.4.0",
        "grunt-vows": "^0.4.2",
        "grunt-webpack": "^3.1.3",
        "istanbul-instrumenter-loader": "^3.0.1",
        jade: "~0.27.7",
        "jasmine-core": "^2.3.4",
        "jquery-mockjax": "^2.5.0",
        karma: "^5.0.4",
        "karma-browserstack-launcher": "^1.5.1",
        "karma-chai": "^0.1.0",
        "karma-chrome-launcher": "^2.2.0",
        "karma-expect": "^1.1.0",
        "karma-firefox-launcher": "^0.1.6",
        "karma-html2js-preprocessor": "^1.1.0",
        "karma-jquery": "^0.1.0",
        "karma-mocha": "^2.0.1",
        "karma-mocha-reporter": "^2.2.5",
        "karma-requirejs": "^0.2.2",
        "karma-safari-launcher": "^0.1.1",
        "karma-sinon": "^1.0.4",
        "karma-sourcemap-loader": "^0.3.5",
        "karma-webpack": "^4.0.2",
        mocha: "^7.1.2",
        natives: "^1.1.6",
        nock: "^11.9.1",
        "node-libs-browser": "^0.5.2",
        request: "^2.88.0",
        requirejs: "^2.1.20",
        "script-loader": "0.6.1",
        sinon: "^8.1.1",
        stackframe: "^0.2.2",
        "strict-loader": "^1.2.0",
        "time-grunt": "^1.0.0",
        vows: "^0.8.3",
        webpack: "^4.46.0"
      },
      optionalDependencies: {
        decache: "^3.0.5"
      },
      scripts: {
        build: "./node_modules/.bin/grunt",
        test: "./node_modules/.bin/grunt test",
        "test-browser": "./node_modules/.bin/grunt test-browser",
        "test-server": "./node_modules/.bin/grunt test-server",
        test_ci: "./node_modules/.bin/grunt test",
        lint: "./node_modules/.bin/eslint . --ext .js"
      },
      cdn: {
        host: "cdn.rollbar.com"
      },
      defaults: {
        endpoint: "api.rollbar.com/api/1/item/",
        server: {
          scrubHeaders: [
            "authorization",
            "www-authorization",
            "http_authorization",
            "omniauth.auth",
            "cookie",
            "oauth-access-token",
            "x-access-token",
            "x_csrf_token",
            "http_x_csrf_token",
            "x-csrf-token"
          ],
          scrubFields: [
            "pw",
            "pass",
            "passwd",
            "password",
            "password_confirmation",
            "passwordConfirmation",
            "confirm_password",
            "confirmPassword",
            "secret",
            "secret_token",
            "secretToken",
            "secret_key",
            "secretKey",
            "api_key",
            "access_token",
            "accessToken",
            "authenticity_token",
            "oauth_token",
            "token",
            "user_session_secret",
            "request.session.csrf",
            "request.session._csrf",
            "request.params._csrf",
            "request.cookie",
            "request.cookies"
          ]
        },
        reactNative: {
          rewriteFilenamePatterns: [
            "^.*/[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}/[^/]*.app/(.*)$",
            "^.*/[0-9A-Fa-f]{64}/codepush_ios/(.*)$",
            "^.*/[0-9A-Fa-f]{64}/codepush_android/(.*)$",
            "^.*/[0-9A-Fa-f]{64}/CodePush/(.*)$"
          ]
        },
        logLevel: "debug",
        reportLevel: "debug",
        uncaughtErrorLevel: "error",
        maxItems: 0,
        itemsPerMin: 60
      },
      plugins: {
        jquery: {
          version: "0.0.8"
        }
      }
    };
  }
});

// node_modules/rollbar/src/merge.js
var require_merge = __commonJS({
  "node_modules/rollbar/src/merge.js"(exports, module2) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var isPlainObject = function isPlainObject2(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    };
    function merge() {
      var i, src, copy, clone, name, result = {}, current = null, length = arguments.length;
      for (i = 0; i < length; i++) {
        current = arguments[i];
        if (current == null) {
          continue;
        }
        for (name in current) {
          src = result[name];
          copy = current[name];
          if (result !== copy) {
            if (copy && isPlainObject(copy)) {
              clone = src && isPlainObject(src) ? src : {};
              result[name] = merge(clone, copy);
            } else if (typeof copy !== "undefined") {
              result[name] = copy;
            }
          }
        }
      }
      return result;
    }
    module2.exports = merge;
  }
});

// node_modules/rollbar/src/utility.js
var require_utility = __commonJS({
  "node_modules/rollbar/src/utility.js"(exports, module2) {
    var merge = require_merge();
    var RollbarJSON = {};
    function setupJSON(polyfillJSON) {
      if (isFunction(RollbarJSON.stringify) && isFunction(RollbarJSON.parse)) {
        return;
      }
      if (isDefined(JSON)) {
        if (polyfillJSON) {
          if (isNativeFunction(JSON.stringify)) {
            RollbarJSON.stringify = JSON.stringify;
          }
          if (isNativeFunction(JSON.parse)) {
            RollbarJSON.parse = JSON.parse;
          }
        } else {
          if (isFunction(JSON.stringify)) {
            RollbarJSON.stringify = JSON.stringify;
          }
          if (isFunction(JSON.parse)) {
            RollbarJSON.parse = JSON.parse;
          }
        }
      }
      if (!isFunction(RollbarJSON.stringify) || !isFunction(RollbarJSON.parse)) {
        polyfillJSON && polyfillJSON(RollbarJSON);
      }
    }
    function isType(x, t) {
      return t === typeName(x);
    }
    function typeName(x) {
      var name = typeof x;
      if (name !== "object") {
        return name;
      }
      if (!x) {
        return "null";
      }
      if (x instanceof Error) {
        return "error";
      }
      return {}.toString.call(x).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
    }
    function isFunction(f) {
      return isType(f, "function");
    }
    function isNativeFunction(f) {
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var funcMatchString = Function.prototype.toString.call(Object.prototype.hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?");
      var reIsNative = RegExp("^" + funcMatchString + "$");
      return isObject(f) && reIsNative.test(f);
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isString2(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFiniteNumber(n) {
      return Number.isFinite(n);
    }
    function isDefined(u) {
      return !isType(u, "undefined");
    }
    function isIterable(i) {
      var type = typeName(i);
      return type === "object" || type === "array";
    }
    function isError(e) {
      return isType(e, "error") || isType(e, "exception");
    }
    function isPromise(p) {
      return isObject(p) && isType(p.then, "function");
    }
    function redact() {
      return "********";
    }
    function uuid4() {
      var d = now();
      var uuid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        var r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c === "x" ? r : r & 7 | 8).toString(16);
      });
      return uuid;
    }
    var LEVELS = {
      debug: 0,
      info: 1,
      warning: 2,
      error: 3,
      critical: 4
    };
    function sanitizeUrl(url) {
      var baseUrlParts = parseUri(url);
      if (!baseUrlParts) {
        return "(unknown)";
      }
      if (baseUrlParts.anchor === "") {
        baseUrlParts.source = baseUrlParts.source.replace("#", "");
      }
      url = baseUrlParts.source.replace("?" + baseUrlParts.query, "");
      return url;
    }
    var parseUriOptions = {
      strictMode: false,
      key: [
        "source",
        "protocol",
        "authority",
        "userInfo",
        "user",
        "password",
        "host",
        "port",
        "relative",
        "path",
        "directory",
        "file",
        "query",
        "anchor"
      ],
      q: {
        name: "queryKey",
        parser: /(?:^|&)([^&=]*)=?([^&]*)/g
      },
      parser: {
        strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
        loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
      }
    };
    function parseUri(str) {
      if (!isType(str, "string")) {
        return void 0;
      }
      var o = parseUriOptions;
      var m = o.parser[o.strictMode ? "strict" : "loose"].exec(str);
      var uri = {};
      for (var i = 0, l = o.key.length; i < l; ++i) {
        uri[o.key[i]] = m[i] || "";
      }
      uri[o.q.name] = {};
      uri[o.key[12]].replace(o.q.parser, function($0, $1, $2) {
        if ($1) {
          uri[o.q.name][$1] = $2;
        }
      });
      return uri;
    }
    function addParamsAndAccessTokenToPath(accessToken, options, params) {
      params = params || {};
      params.access_token = accessToken;
      var paramsArray = [];
      var k;
      for (k in params) {
        if (Object.prototype.hasOwnProperty.call(params, k)) {
          paramsArray.push([k, params[k]].join("="));
        }
      }
      var query = "?" + paramsArray.sort().join("&");
      options = options || {};
      options.path = options.path || "";
      var qs = options.path.indexOf("?");
      var h = options.path.indexOf("#");
      var p;
      if (qs !== -1 && (h === -1 || h > qs)) {
        p = options.path;
        options.path = p.substring(0, qs) + query + "&" + p.substring(qs + 1);
      } else {
        if (h !== -1) {
          p = options.path;
          options.path = p.substring(0, h) + query + p.substring(h);
        } else {
          options.path = options.path + query;
        }
      }
    }
    function formatUrl(u, protocol) {
      protocol = protocol || u.protocol;
      if (!protocol && u.port) {
        if (u.port === 80) {
          protocol = "http:";
        } else if (u.port === 443) {
          protocol = "https:";
        }
      }
      protocol = protocol || "https:";
      if (!u.hostname) {
        return null;
      }
      var result = protocol + "//" + u.hostname;
      if (u.port) {
        result = result + ":" + u.port;
      }
      if (u.path) {
        result = result + u.path;
      }
      return result;
    }
    function stringify(obj, backup) {
      var value, error;
      try {
        value = RollbarJSON.stringify(obj);
      } catch (jsonError) {
        if (backup && isFunction(backup)) {
          try {
            value = backup(obj);
          } catch (backupError) {
            error = backupError;
          }
        } else {
          error = jsonError;
        }
      }
      return { error, value };
    }
    function maxByteSize(string) {
      var count = 0;
      var length = string.length;
      for (var i = 0; i < length; i++) {
        var code = string.charCodeAt(i);
        if (code < 128) {
          count = count + 1;
        } else if (code < 2048) {
          count = count + 2;
        } else if (code < 65536) {
          count = count + 3;
        }
      }
      return count;
    }
    function jsonParse(s) {
      var value, error;
      try {
        value = RollbarJSON.parse(s);
      } catch (e) {
        error = e;
      }
      return { error, value };
    }
    function makeUnhandledStackInfo(message, url, lineno, colno, error, mode, backupMessage, errorParser) {
      var location = {
        url: url || "",
        line: lineno,
        column: colno
      };
      location.func = errorParser.guessFunctionName(location.url, location.line);
      location.context = errorParser.gatherContext(location.url, location.line);
      var href = typeof document !== "undefined" && document && document.location && document.location.href;
      var useragent = typeof window !== "undefined" && window && window.navigator && window.navigator.userAgent;
      return {
        "mode": mode,
        "message": error ? String(error) : message || backupMessage,
        "url": href,
        "stack": [location],
        "useragent": useragent
      };
    }
    function wrapCallback(logger, f) {
      return function(err, resp) {
        try {
          f(err, resp);
        } catch (e) {
          logger.error(e);
        }
      };
    }
    function nonCircularClone(obj) {
      var seen = [obj];
      function clone(obj2, seen2) {
        var value, name, newSeen, result = {};
        try {
          for (name in obj2) {
            value = obj2[name];
            if (value && (isType(value, "object") || isType(value, "array"))) {
              if (seen2.includes(value)) {
                result[name] = "Removed circular reference: " + typeName(value);
              } else {
                newSeen = seen2.slice();
                newSeen.push(value);
                result[name] = clone(value, newSeen);
              }
              continue;
            }
            result[name] = value;
          }
        } catch (e) {
          result = "Failed cloning custom data: " + e.message;
        }
        return result;
      }
      return clone(obj, seen);
    }
    function createItem(args, logger, notifier, requestKeys, lambdaContext) {
      var message, err, custom, callback, request;
      var arg;
      var extraArgs = [];
      var diagnostic = {};
      var argTypes = [];
      for (var i = 0, l = args.length; i < l; ++i) {
        arg = args[i];
        var typ = typeName(arg);
        argTypes.push(typ);
        switch (typ) {
          case "undefined":
            break;
          case "string":
            message ? extraArgs.push(arg) : message = arg;
            break;
          case "function":
            callback = wrapCallback(logger, arg);
            break;
          case "date":
            extraArgs.push(arg);
            break;
          case "error":
          case "domexception":
          case "exception":
            err ? extraArgs.push(arg) : err = arg;
            break;
          case "object":
          case "array":
            if (arg instanceof Error || typeof DOMException !== "undefined" && arg instanceof DOMException) {
              err ? extraArgs.push(arg) : err = arg;
              break;
            }
            if (requestKeys && typ === "object" && !request) {
              for (var j = 0, len = requestKeys.length; j < len; ++j) {
                if (arg[requestKeys[j]] !== void 0) {
                  request = arg;
                  break;
                }
              }
              if (request) {
                break;
              }
            }
            custom ? extraArgs.push(arg) : custom = arg;
            break;
          default:
            if (arg instanceof Error || typeof DOMException !== "undefined" && arg instanceof DOMException) {
              err ? extraArgs.push(arg) : err = arg;
              break;
            }
            extraArgs.push(arg);
        }
      }
      if (custom)
        custom = nonCircularClone(custom);
      if (extraArgs.length > 0) {
        if (!custom)
          custom = nonCircularClone({});
        custom.extraArgs = nonCircularClone(extraArgs);
      }
      var item = {
        message,
        err,
        custom,
        timestamp: now(),
        callback,
        notifier,
        diagnostic,
        uuid: uuid4()
      };
      setCustomItemKeys(item, custom);
      if (requestKeys && request) {
        item.request = request;
      }
      if (lambdaContext) {
        item.lambdaContext = lambdaContext;
      }
      item._originalArgs = args;
      item.diagnostic.original_arg_types = argTypes;
      return item;
    }
    function setCustomItemKeys(item, custom) {
      if (custom && custom.level !== void 0) {
        item.level = custom.level;
        delete custom.level;
      }
      if (custom && custom.skipFrames !== void 0) {
        item.skipFrames = custom.skipFrames;
        delete custom.skipFrames;
      }
    }
    function addErrorContext(item, errors) {
      var custom = item.data.custom || {};
      var contextAdded = false;
      try {
        for (var i = 0; i < errors.length; ++i) {
          if (errors[i].hasOwnProperty("rollbarContext")) {
            custom = merge(custom, nonCircularClone(errors[i].rollbarContext));
            contextAdded = true;
          }
        }
        if (contextAdded) {
          item.data.custom = custom;
        }
      } catch (e) {
        item.diagnostic.error_context = "Failed: " + e.message;
      }
    }
    var TELEMETRY_TYPES = ["log", "network", "dom", "navigation", "error", "manual"];
    var TELEMETRY_LEVELS = ["critical", "error", "warning", "info", "debug"];
    function arrayIncludes(arr, val) {
      for (var k = 0; k < arr.length; ++k) {
        if (arr[k] === val) {
          return true;
        }
      }
      return false;
    }
    function createTelemetryEvent(args) {
      var type, metadata, level;
      var arg;
      for (var i = 0, l = args.length; i < l; ++i) {
        arg = args[i];
        var typ = typeName(arg);
        switch (typ) {
          case "string":
            if (!type && arrayIncludes(TELEMETRY_TYPES, arg)) {
              type = arg;
            } else if (!level && arrayIncludes(TELEMETRY_LEVELS, arg)) {
              level = arg;
            }
            break;
          case "object":
            metadata = arg;
            break;
          default:
            break;
        }
      }
      var event = {
        type: type || "manual",
        metadata: metadata || {},
        level
      };
      return event;
    }
    function get(obj, path3) {
      if (!obj) {
        return void 0;
      }
      var keys = path3.split(".");
      var result = obj;
      try {
        for (var i = 0, len = keys.length; i < len; ++i) {
          result = result[keys[i]];
        }
      } catch (e) {
        result = void 0;
      }
      return result;
    }
    function set(obj, path3, value) {
      if (!obj) {
        return;
      }
      var keys = path3.split(".");
      var len = keys.length;
      if (len < 1) {
        return;
      }
      if (len === 1) {
        obj[keys[0]] = value;
        return;
      }
      try {
        var temp = obj[keys[0]] || {};
        var replacement = temp;
        for (var i = 1; i < len - 1; ++i) {
          temp[keys[i]] = temp[keys[i]] || {};
          temp = temp[keys[i]];
        }
        temp[keys[len - 1]] = value;
        obj[keys[0]] = replacement;
      } catch (e) {
        return;
      }
    }
    function formatArgsAsString(args) {
      var i, len, arg;
      var result = [];
      for (i = 0, len = args.length; i < len; ++i) {
        arg = args[i];
        switch (typeName(arg)) {
          case "object":
            arg = stringify(arg);
            arg = arg.error || arg.value;
            if (arg.length > 500) {
              arg = arg.substr(0, 497) + "...";
            }
            break;
          case "null":
            arg = "null";
            break;
          case "undefined":
            arg = "undefined";
            break;
          case "symbol":
            arg = arg.toString();
            break;
        }
        result.push(arg);
      }
      return result.join(" ");
    }
    function now() {
      if (Date.now) {
        return +Date.now();
      }
      return +new Date();
    }
    function filterIp(requestData, captureIp) {
      if (!requestData || !requestData["user_ip"] || captureIp === true) {
        return;
      }
      var newIp = requestData["user_ip"];
      if (!captureIp) {
        newIp = null;
      } else {
        try {
          var parts;
          if (newIp.indexOf(".") !== -1) {
            parts = newIp.split(".");
            parts.pop();
            parts.push("0");
            newIp = parts.join(".");
          } else if (newIp.indexOf(":") !== -1) {
            parts = newIp.split(":");
            if (parts.length > 2) {
              var beginning = parts.slice(0, 3);
              var slashIdx = beginning[2].indexOf("/");
              if (slashIdx !== -1) {
                beginning[2] = beginning[2].substring(0, slashIdx);
              }
              var terminal = "0000:0000:0000:0000:0000";
              newIp = beginning.concat(terminal).join(":");
            }
          } else {
            newIp = null;
          }
        } catch (e) {
          newIp = null;
        }
      }
      requestData["user_ip"] = newIp;
    }
    function handleOptions(current, input, payload, logger) {
      var result = merge(current, input, payload);
      result = updateDeprecatedOptions(result, logger);
      if (!input || input.overwriteScrubFields) {
        return result;
      }
      if (input.scrubFields) {
        result.scrubFields = (current.scrubFields || []).concat(input.scrubFields);
      }
      return result;
    }
    function updateDeprecatedOptions(options, logger) {
      if (options.hostWhiteList && !options.hostSafeList) {
        options.hostSafeList = options.hostWhiteList;
        options.hostWhiteList = void 0;
        logger && logger.log("hostWhiteList is deprecated. Use hostSafeList.");
      }
      if (options.hostBlackList && !options.hostBlockList) {
        options.hostBlockList = options.hostBlackList;
        options.hostBlackList = void 0;
        logger && logger.log("hostBlackList is deprecated. Use hostBlockList.");
      }
      return options;
    }
    module2.exports = {
      addParamsAndAccessTokenToPath,
      createItem,
      addErrorContext,
      createTelemetryEvent,
      filterIp,
      formatArgsAsString,
      formatUrl,
      get,
      handleOptions,
      isError,
      isFiniteNumber,
      isFunction,
      isIterable,
      isNativeFunction,
      isObject,
      isString: isString2,
      isType,
      isPromise,
      jsonParse,
      LEVELS,
      makeUnhandledStackInfo,
      merge,
      now,
      redact,
      RollbarJSON,
      sanitizeUrl,
      set,
      setupJSON,
      stringify,
      maxByteSize,
      typeName,
      uuid4
    };
  }
});

// node_modules/rollbar/src/rateLimiter.js
var require_rateLimiter = __commonJS({
  "node_modules/rollbar/src/rateLimiter.js"(exports, module2) {
    var _ = require_utility();
    function RateLimiter(options) {
      this.startTime = _.now();
      this.counter = 0;
      this.perMinCounter = 0;
      this.platform = null;
      this.platformOptions = {};
      this.configureGlobal(options);
    }
    RateLimiter.globalSettings = {
      startTime: _.now(),
      maxItems: void 0,
      itemsPerMinute: void 0
    };
    RateLimiter.prototype.configureGlobal = function(options) {
      if (options.startTime !== void 0) {
        RateLimiter.globalSettings.startTime = options.startTime;
      }
      if (options.maxItems !== void 0) {
        RateLimiter.globalSettings.maxItems = options.maxItems;
      }
      if (options.itemsPerMinute !== void 0) {
        RateLimiter.globalSettings.itemsPerMinute = options.itemsPerMinute;
      }
    };
    RateLimiter.prototype.shouldSend = function(item, now) {
      now = now || _.now();
      var elapsedTime = now - this.startTime;
      if (elapsedTime < 0 || elapsedTime >= 6e4) {
        this.startTime = now;
        this.perMinCounter = 0;
      }
      var globalRateLimit = RateLimiter.globalSettings.maxItems;
      var globalRateLimitPerMin = RateLimiter.globalSettings.itemsPerMinute;
      if (checkRate(item, globalRateLimit, this.counter)) {
        return shouldSendValue(this.platform, this.platformOptions, globalRateLimit + " max items reached", false);
      } else if (checkRate(item, globalRateLimitPerMin, this.perMinCounter)) {
        return shouldSendValue(this.platform, this.platformOptions, globalRateLimitPerMin + " items per minute reached", false);
      }
      this.counter++;
      this.perMinCounter++;
      var shouldSend = !checkRate(item, globalRateLimit, this.counter);
      var perMinute = shouldSend;
      shouldSend = shouldSend && !checkRate(item, globalRateLimitPerMin, this.perMinCounter);
      return shouldSendValue(this.platform, this.platformOptions, null, shouldSend, globalRateLimit, globalRateLimitPerMin, perMinute);
    };
    RateLimiter.prototype.setPlatformOptions = function(platform, options) {
      this.platform = platform;
      this.platformOptions = options;
    };
    function checkRate(item, limit, counter) {
      return !item.ignoreRateLimit && limit >= 1 && counter > limit;
    }
    function shouldSendValue(platform, options, error, shouldSend, globalRateLimit, limitPerMin, perMinute) {
      var payload = null;
      if (error) {
        error = new Error(error);
      }
      if (!error && !shouldSend) {
        payload = rateLimitPayload(platform, options, globalRateLimit, limitPerMin, perMinute);
      }
      return { error, shouldSend, payload };
    }
    function rateLimitPayload(platform, options, globalRateLimit, limitPerMin, perMinute) {
      var environment = options.environment || options.payload && options.payload.environment;
      var msg;
      if (perMinute) {
        msg = "item per minute limit reached, ignoring errors until timeout";
      } else {
        msg = "maxItems has been hit, ignoring errors until reset.";
      }
      var item = {
        body: {
          message: {
            body: msg,
            extra: {
              maxItems: globalRateLimit,
              itemsPerMinute: limitPerMin
            }
          }
        },
        language: "javascript",
        environment,
        notifier: {
          version: options.notifier && options.notifier.version || options.version
        }
      };
      if (platform === "browser") {
        item.platform = "browser";
        item.framework = "browser-js";
        item.notifier.name = "rollbar-browser-js";
      } else if (platform === "server") {
        item.framework = options.framework || "node-js";
        item.notifier.name = options.notifier.name;
      } else if (platform === "react-native") {
        item.framework = options.framework || "react-native";
        item.notifier.name = options.notifier.name;
      }
      return item;
    }
    module2.exports = RateLimiter;
  }
});

// node_modules/rollbar/src/queue.js
var require_queue = __commonJS({
  "node_modules/rollbar/src/queue.js"(exports, module2) {
    var _ = require_utility();
    function Queue(rateLimiter, api, logger, options) {
      this.rateLimiter = rateLimiter;
      this.api = api;
      this.logger = logger;
      this.options = options;
      this.predicates = [];
      this.pendingItems = [];
      this.pendingRequests = [];
      this.retryQueue = [];
      this.retryHandle = null;
      this.waitCallback = null;
      this.waitIntervalID = null;
    }
    Queue.prototype.configure = function(options) {
      this.api && this.api.configure(options);
      var oldOptions = this.options;
      this.options = _.merge(oldOptions, options);
      return this;
    };
    Queue.prototype.addPredicate = function(predicate) {
      if (_.isFunction(predicate)) {
        this.predicates.push(predicate);
      }
      return this;
    };
    Queue.prototype.addPendingItem = function(item) {
      this.pendingItems.push(item);
    };
    Queue.prototype.removePendingItem = function(item) {
      var idx = this.pendingItems.indexOf(item);
      if (idx !== -1) {
        this.pendingItems.splice(idx, 1);
      }
    };
    Queue.prototype.addItem = function(item, callback, originalError, originalItem) {
      if (!callback || !_.isFunction(callback)) {
        callback = function() {
          return;
        };
      }
      var predicateResult = this._applyPredicates(item);
      if (predicateResult.stop) {
        this.removePendingItem(originalItem);
        callback(predicateResult.err);
        return;
      }
      this._maybeLog(item, originalError);
      this.removePendingItem(originalItem);
      if (!this.options.transmit) {
        callback(new Error("Transmit disabled"));
        return;
      }
      this.pendingRequests.push(item);
      try {
        this._makeApiRequest(item, function(err, resp) {
          this._dequeuePendingRequest(item);
          callback(err, resp);
        }.bind(this));
      } catch (e) {
        this._dequeuePendingRequest(item);
        callback(e);
      }
    };
    Queue.prototype.wait = function(callback) {
      if (!_.isFunction(callback)) {
        return;
      }
      this.waitCallback = callback;
      if (this._maybeCallWait()) {
        return;
      }
      if (this.waitIntervalID) {
        this.waitIntervalID = clearInterval(this.waitIntervalID);
      }
      this.waitIntervalID = setInterval(function() {
        this._maybeCallWait();
      }.bind(this), 500);
    };
    Queue.prototype._applyPredicates = function(item) {
      var p = null;
      for (var i = 0, len = this.predicates.length; i < len; i++) {
        p = this.predicates[i](item, this.options);
        if (!p || p.err !== void 0) {
          return { stop: true, err: p.err };
        }
      }
      return { stop: false, err: null };
    };
    Queue.prototype._makeApiRequest = function(item, callback) {
      var rateLimitResponse = this.rateLimiter.shouldSend(item);
      if (rateLimitResponse.shouldSend) {
        this.api.postItem(item, function(err, resp) {
          if (err) {
            this._maybeRetry(err, item, callback);
          } else {
            callback(err, resp);
          }
        }.bind(this));
      } else if (rateLimitResponse.error) {
        callback(rateLimitResponse.error);
      } else {
        this.api.postItem(rateLimitResponse.payload, callback);
      }
    };
    var RETRIABLE_ERRORS = ["ECONNRESET", "ENOTFOUND", "ESOCKETTIMEDOUT", "ETIMEDOUT", "ECONNREFUSED", "EHOSTUNREACH", "EPIPE", "EAI_AGAIN"];
    Queue.prototype._maybeRetry = function(err, item, callback) {
      var shouldRetry = false;
      if (this.options.retryInterval) {
        for (var i = 0, len = RETRIABLE_ERRORS.length; i < len; i++) {
          if (err.code === RETRIABLE_ERRORS[i]) {
            shouldRetry = true;
            break;
          }
        }
        if (shouldRetry && _.isFiniteNumber(this.options.maxRetries)) {
          item.retries = item.retries ? item.retries + 1 : 1;
          if (item.retries > this.options.maxRetries) {
            shouldRetry = false;
          }
        }
      }
      if (shouldRetry) {
        this._retryApiRequest(item, callback);
      } else {
        callback(err);
      }
    };
    Queue.prototype._retryApiRequest = function(item, callback) {
      this.retryQueue.push({ item, callback });
      if (!this.retryHandle) {
        this.retryHandle = setInterval(function() {
          while (this.retryQueue.length) {
            var retryObject = this.retryQueue.shift();
            this._makeApiRequest(retryObject.item, retryObject.callback);
          }
        }.bind(this), this.options.retryInterval);
      }
    };
    Queue.prototype._dequeuePendingRequest = function(item) {
      var idx = this.pendingRequests.indexOf(item);
      if (idx !== -1) {
        this.pendingRequests.splice(idx, 1);
        this._maybeCallWait();
      }
    };
    Queue.prototype._maybeLog = function(data, originalError) {
      if (this.logger && this.options.verbose) {
        var message = originalError;
        message = message || _.get(data, "body.trace.exception.message");
        message = message || _.get(data, "body.trace_chain.0.exception.message");
        if (message) {
          this.logger.error(message);
          return;
        }
        message = _.get(data, "body.message.body");
        if (message) {
          this.logger.log(message);
        }
      }
    };
    Queue.prototype._maybeCallWait = function() {
      if (_.isFunction(this.waitCallback) && this.pendingItems.length === 0 && this.pendingRequests.length === 0) {
        if (this.waitIntervalID) {
          this.waitIntervalID = clearInterval(this.waitIntervalID);
        }
        this.waitCallback();
        return true;
      }
      return false;
    };
    module2.exports = Queue;
  }
});

// node_modules/rollbar/src/notifier.js
var require_notifier = __commonJS({
  "node_modules/rollbar/src/notifier.js"(exports, module2) {
    var _ = require_utility();
    function Notifier(queue, options) {
      this.queue = queue;
      this.options = options;
      this.transforms = [];
      this.diagnostic = {};
    }
    Notifier.prototype.configure = function(options) {
      this.queue && this.queue.configure(options);
      var oldOptions = this.options;
      this.options = _.merge(oldOptions, options);
      return this;
    };
    Notifier.prototype.addTransform = function(transform) {
      if (_.isFunction(transform)) {
        this.transforms.push(transform);
      }
      return this;
    };
    Notifier.prototype.log = function(item, callback) {
      if (!callback || !_.isFunction(callback)) {
        callback = function() {
        };
      }
      if (!this.options.enabled) {
        return callback(new Error("Rollbar is not enabled"));
      }
      this.queue.addPendingItem(item);
      var originalError = item.err;
      this._applyTransforms(item, function(err, i) {
        if (err) {
          this.queue.removePendingItem(item);
          return callback(err, null);
        }
        this.queue.addItem(i, callback, originalError, item);
      }.bind(this));
    };
    Notifier.prototype._applyTransforms = function(item, callback) {
      var transformIndex = -1;
      var transformsLength = this.transforms.length;
      var transforms = this.transforms;
      var options = this.options;
      var cb = function(err, i) {
        if (err) {
          callback(err, null);
          return;
        }
        transformIndex++;
        if (transformIndex === transformsLength) {
          callback(null, i);
          return;
        }
        transforms[transformIndex](i, options, cb);
      };
      cb(null, item);
    };
    module2.exports = Notifier;
  }
});

// node_modules/rollbar/src/rollbar.js
var require_rollbar = __commonJS({
  "node_modules/rollbar/src/rollbar.js"(exports, module2) {
    var RateLimiter = require_rateLimiter();
    var Queue = require_queue();
    var Notifier = require_notifier();
    var _ = require_utility();
    function Rollbar2(options, api, logger, telemeter, platform) {
      this.options = _.merge(options);
      this.logger = logger;
      Rollbar2.rateLimiter.configureGlobal(this.options);
      Rollbar2.rateLimiter.setPlatformOptions(platform, this.options);
      this.api = api;
      this.queue = new Queue(Rollbar2.rateLimiter, api, logger, this.options);
      var tracer = this.options.tracer || null;
      if (validateTracer(tracer)) {
        this.tracer = tracer;
        this.options.tracer = "opentracing-tracer-enabled";
        this.options._configuredOptions.tracer = "opentracing-tracer-enabled";
      } else {
        this.tracer = null;
      }
      this.notifier = new Notifier(this.queue, this.options);
      this.telemeter = telemeter;
      setStackTraceLimit(options);
      this.lastError = null;
      this.lastErrorHash = "none";
    }
    var defaultOptions = {
      maxItems: 0,
      itemsPerMinute: 60
    };
    Rollbar2.rateLimiter = new RateLimiter(defaultOptions);
    Rollbar2.prototype.global = function(options) {
      Rollbar2.rateLimiter.configureGlobal(options);
      return this;
    };
    Rollbar2.prototype.configure = function(options, payloadData) {
      var oldOptions = this.options;
      var payload = {};
      if (payloadData) {
        payload = { payload: payloadData };
      }
      this.options = _.merge(oldOptions, options, payload);
      var tracer = this.options.tracer || null;
      if (validateTracer(tracer)) {
        this.tracer = tracer;
        this.options.tracer = "opentracing-tracer-enabled";
        this.options._configuredOptions.tracer = "opentracing-tracer-enabled";
      } else {
        this.tracer = null;
      }
      this.notifier && this.notifier.configure(this.options);
      this.telemeter && this.telemeter.configure(this.options);
      setStackTraceLimit(options);
      this.global(this.options);
      if (validateTracer(options.tracer)) {
        this.tracer = options.tracer;
      }
      return this;
    };
    Rollbar2.prototype.log = function(item) {
      var level = this._defaultLogLevel();
      return this._log(level, item);
    };
    Rollbar2.prototype.debug = function(item) {
      this._log("debug", item);
    };
    Rollbar2.prototype.info = function(item) {
      this._log("info", item);
    };
    Rollbar2.prototype.warn = function(item) {
      this._log("warning", item);
    };
    Rollbar2.prototype.warning = function(item) {
      this._log("warning", item);
    };
    Rollbar2.prototype.error = function(item) {
      this._log("error", item);
    };
    Rollbar2.prototype.critical = function(item) {
      this._log("critical", item);
    };
    Rollbar2.prototype.wait = function(callback) {
      this.queue.wait(callback);
    };
    Rollbar2.prototype.captureEvent = function(type, metadata, level) {
      return this.telemeter && this.telemeter.captureEvent(type, metadata, level);
    };
    Rollbar2.prototype.captureDomContentLoaded = function(ts) {
      return this.telemeter && this.telemeter.captureDomContentLoaded(ts);
    };
    Rollbar2.prototype.captureLoad = function(ts) {
      return this.telemeter && this.telemeter.captureLoad(ts);
    };
    Rollbar2.prototype.buildJsonPayload = function(item) {
      return this.api.buildJsonPayload(item);
    };
    Rollbar2.prototype.sendJsonPayload = function(jsonPayload) {
      this.api.postJsonPayload(jsonPayload);
    };
    Rollbar2.prototype._log = function(defaultLevel, item) {
      var callback;
      if (item.callback) {
        callback = item.callback;
        delete item.callback;
      }
      if (this.options.ignoreDuplicateErrors && this._sameAsLastError(item)) {
        if (callback) {
          var error = new Error("ignored identical item");
          error.item = item;
          callback(error);
        }
        return;
      }
      try {
        this._addTracingInfo(item);
        item.level = item.level || defaultLevel;
        this.telemeter && this.telemeter._captureRollbarItem(item);
        item.telemetryEvents = this.telemeter && this.telemeter.copyEvents() || [];
        this.notifier.log(item, callback);
      } catch (e) {
        if (callback) {
          callback(e);
        }
        this.logger.error(e);
      }
    };
    Rollbar2.prototype._defaultLogLevel = function() {
      return this.options.logLevel || "debug";
    };
    Rollbar2.prototype._sameAsLastError = function(item) {
      if (!item._isUncaught) {
        return false;
      }
      var itemHash = generateItemHash(item);
      if (this.lastErrorHash === itemHash) {
        return true;
      }
      this.lastError = item.err;
      this.lastErrorHash = itemHash;
      return false;
    };
    Rollbar2.prototype._addTracingInfo = function(item) {
      if (this.tracer) {
        var span = this.tracer.scope().active();
        if (validateSpan(span)) {
          span.setTag("rollbar.error_uuid", item.uuid);
          span.setTag("rollbar.has_error", true);
          span.setTag("error", true);
          span.setTag("rollbar.item_url", `https://rollbar.com/item/uuid/?uuid=${item.uuid}`);
          span.setTag("rollbar.occurrence_url", `https://rollbar.com/occurrence/uuid/?uuid=${item.uuid}`);
          var opentracingSpanId = span.context().toSpanId();
          var opentracingTraceId = span.context().toTraceId();
          if (item.custom) {
            item.custom.opentracing_span_id = opentracingSpanId;
            item.custom.opentracing_trace_id = opentracingTraceId;
          } else {
            item.custom = {
              opentracing_span_id: opentracingSpanId,
              opentracing_trace_id: opentracingTraceId
            };
          }
        }
      }
    };
    function generateItemHash(item) {
      var message = item.message || "";
      var stack = (item.err || {}).stack || String(item.err);
      return message + "::" + stack;
    }
    function setStackTraceLimit(options) {
      if (options.stackTraceLimit) {
        Error.stackTraceLimit = options.stackTraceLimit;
      }
    }
    function validateTracer(tracer) {
      if (!tracer) {
        return false;
      }
      if (!tracer.scope || typeof tracer.scope !== "function") {
        return false;
      }
      var scope = tracer.scope();
      if (!scope || !scope.active || typeof scope.active !== "function") {
        return false;
      }
      return true;
    }
    function validateSpan(span) {
      if (!span || !span.context || typeof span.context !== "function") {
        return false;
      }
      var spanContext = span.context();
      if (!spanContext || !spanContext.toSpanId || !spanContext.toTraceId || typeof spanContext.toSpanId !== "function" || typeof spanContext.toTraceId !== "function") {
        return false;
      }
      return true;
    }
    module2.exports = Rollbar2;
  }
});

// node_modules/rollbar/src/apiUtility.js
var require_apiUtility = __commonJS({
  "node_modules/rollbar/src/apiUtility.js"(exports, module2) {
    var _ = require_utility();
    function buildPayload(accessToken, data, jsonBackup) {
      if (!_.isType(data.context, "string")) {
        var contextResult = _.stringify(data.context, jsonBackup);
        if (contextResult.error) {
          data.context = "Error: could not serialize 'context'";
        } else {
          data.context = contextResult.value || "";
        }
        if (data.context.length > 255) {
          data.context = data.context.substr(0, 255);
        }
      }
      return {
        access_token: accessToken,
        data
      };
    }
    function getTransportFromOptions(options, defaults, url) {
      var hostname = defaults.hostname;
      var protocol = defaults.protocol;
      var port = defaults.port;
      var path3 = defaults.path;
      var search = defaults.search;
      var timeout = options.timeout;
      var proxy = options.proxy;
      if (options.endpoint) {
        var opts = url.parse(options.endpoint);
        hostname = opts.hostname;
        protocol = opts.protocol;
        port = opts.port;
        path3 = opts.pathname;
        search = opts.search;
      }
      return {
        timeout,
        hostname,
        protocol,
        port,
        path: path3,
        search,
        proxy
      };
    }
    function transportOptions(transport, method) {
      var protocol = transport.protocol || "https:";
      var port = transport.port || (protocol === "http:" ? 80 : protocol === "https:" ? 443 : void 0);
      var hostname = transport.hostname;
      var path3 = transport.path;
      var timeout = transport.timeout;
      if (transport.search) {
        path3 = path3 + transport.search;
      }
      if (transport.proxy) {
        path3 = protocol + "//" + hostname + path3;
        hostname = transport.proxy.host || transport.proxy.hostname;
        port = transport.proxy.port;
        protocol = transport.proxy.protocol || protocol;
      }
      return {
        timeout,
        protocol,
        hostname,
        path: path3,
        port,
        method
      };
    }
    function appendPathToPath(base, path3) {
      var baseTrailingSlash = /\/$/.test(base);
      var pathBeginningSlash = /^\//.test(path3);
      if (baseTrailingSlash && pathBeginningSlash) {
        path3 = path3.substring(1);
      } else if (!baseTrailingSlash && !pathBeginningSlash) {
        path3 = "/" + path3;
      }
      return base + path3;
    }
    module2.exports = {
      buildPayload,
      getTransportFromOptions,
      transportOptions,
      appendPathToPath
    };
  }
});

// node_modules/rollbar/src/api.js
var require_api = __commonJS({
  "node_modules/rollbar/src/api.js"(exports, module2) {
    var _ = require_utility();
    var helpers = require_apiUtility();
    var defaultOptions = {
      hostname: "api.rollbar.com",
      path: "/api/1/item/",
      search: null,
      version: "1",
      protocol: "https:",
      port: 443
    };
    function Api(options, transport, urllib, truncation, jsonBackup) {
      this.options = options;
      this.transport = transport;
      this.url = urllib;
      this.truncation = truncation;
      this.jsonBackup = jsonBackup;
      this.accessToken = options.accessToken;
      this.transportOptions = _getTransport(options, urllib);
    }
    Api.prototype.postItem = function(data, callback) {
      var transportOptions = helpers.transportOptions(this.transportOptions, "POST");
      var payload = helpers.buildPayload(this.accessToken, data, this.jsonBackup);
      this.transport.post(this.accessToken, transportOptions, payload, callback);
    };
    Api.prototype.buildJsonPayload = function(data, callback) {
      var payload = helpers.buildPayload(this.accessToken, data, this.jsonBackup);
      var stringifyResult;
      if (this.truncation) {
        stringifyResult = this.truncation.truncate(payload);
      } else {
        stringifyResult = _.stringify(payload);
      }
      if (stringifyResult.error) {
        if (callback) {
          callback(stringifyResult.error);
        }
        return null;
      }
      return stringifyResult.value;
    };
    Api.prototype.postJsonPayload = function(jsonPayload, callback) {
      var transportOptions = helpers.transportOptions(this.transportOptions, "POST");
      this.transport.postJsonPayload(this.accessToken, transportOptions, jsonPayload, callback);
    };
    Api.prototype.configure = function(options) {
      var oldOptions = this.oldOptions;
      this.options = _.merge(oldOptions, options);
      this.transportOptions = _getTransport(this.options, this.url);
      if (this.options.accessToken !== void 0) {
        this.accessToken = this.options.accessToken;
      }
      return this;
    };
    function _getTransport(options, url) {
      return helpers.getTransportFromOptions(options, defaultOptions, url);
    }
    module2.exports = Api;
  }
});

// node_modules/rollbar/src/server/logger.js
var require_logger = __commonJS({
  "node_modules/rollbar/src/server/logger.js"(exports, module2) {
    "use strict";
    var verbose = true;
    var logger = {
      log: function() {
        if (verbose) {
          console.log.apply(console, arguments);
        }
      },
      error: function() {
        if (verbose) {
          console.error.apply(console, arguments);
        }
      },
      setVerbose: function(val) {
        verbose = val;
      }
    };
    module2.exports = logger;
  }
});

// node_modules/rollbar/src/utility/traverse.js
var require_traverse = __commonJS({
  "node_modules/rollbar/src/utility/traverse.js"(exports, module2) {
    var _ = require_utility();
    function traverse(obj, func, seen) {
      var k, v, i;
      var isObj = _.isType(obj, "object");
      var isArray = _.isType(obj, "array");
      var keys = [];
      var seenIndex;
      seen = seen || { obj: [], mapped: [] };
      if (isObj) {
        seenIndex = seen.obj.indexOf(obj);
        if (isObj && seenIndex !== -1) {
          return seen.mapped[seenIndex] || seen.obj[seenIndex];
        }
        seen.obj.push(obj);
        seenIndex = seen.obj.length - 1;
      }
      if (isObj) {
        for (k in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, k)) {
            keys.push(k);
          }
        }
      } else if (isArray) {
        for (i = 0; i < obj.length; ++i) {
          keys.push(i);
        }
      }
      var result = isObj ? {} : [];
      var same = true;
      for (i = 0; i < keys.length; ++i) {
        k = keys[i];
        v = obj[k];
        result[k] = func(k, v, seen);
        same = same && result[k] === obj[k];
      }
      if (isObj && !same) {
        seen.mapped[seenIndex] = result;
      }
      return !same ? result : obj;
    }
    module2.exports = traverse;
  }
});

// node_modules/rollbar/src/truncation.js
var require_truncation = __commonJS({
  "node_modules/rollbar/src/truncation.js"(exports, module2) {
    var _ = require_utility();
    var traverse = require_traverse();
    function raw(payload, jsonBackup) {
      return [payload, _.stringify(payload, jsonBackup)];
    }
    function selectFrames(frames, range) {
      var len = frames.length;
      if (len > range * 2) {
        return frames.slice(0, range).concat(frames.slice(len - range));
      }
      return frames;
    }
    function truncateFrames(payload, jsonBackup, range) {
      range = typeof range === "undefined" ? 30 : range;
      var body = payload.data.body;
      var frames;
      if (body.trace_chain) {
        var chain = body.trace_chain;
        for (var i = 0; i < chain.length; i++) {
          frames = chain[i].frames;
          frames = selectFrames(frames, range);
          chain[i].frames = frames;
        }
      } else if (body.trace) {
        frames = body.trace.frames;
        frames = selectFrames(frames, range);
        body.trace.frames = frames;
      }
      return [payload, _.stringify(payload, jsonBackup)];
    }
    function maybeTruncateValue(len, val) {
      if (!val) {
        return val;
      }
      if (val.length > len) {
        return val.slice(0, len - 3).concat("...");
      }
      return val;
    }
    function truncateStrings(len, payload, jsonBackup) {
      function truncator(k, v, seen) {
        switch (_.typeName(v)) {
          case "string":
            return maybeTruncateValue(len, v);
          case "object":
          case "array":
            return traverse(v, truncator, seen);
          default:
            return v;
        }
      }
      payload = traverse(payload, truncator);
      return [payload, _.stringify(payload, jsonBackup)];
    }
    function truncateTraceData(traceData) {
      if (traceData.exception) {
        delete traceData.exception.description;
        traceData.exception.message = maybeTruncateValue(255, traceData.exception.message);
      }
      traceData.frames = selectFrames(traceData.frames, 1);
      return traceData;
    }
    function minBody(payload, jsonBackup) {
      var body = payload.data.body;
      if (body.trace_chain) {
        var chain = body.trace_chain;
        for (var i = 0; i < chain.length; i++) {
          chain[i] = truncateTraceData(chain[i]);
        }
      } else if (body.trace) {
        body.trace = truncateTraceData(body.trace);
      }
      return [payload, _.stringify(payload, jsonBackup)];
    }
    function needsTruncation(payload, maxSize) {
      return _.maxByteSize(payload) > maxSize;
    }
    function truncate(payload, jsonBackup, maxSize) {
      maxSize = typeof maxSize === "undefined" ? 512 * 1024 : maxSize;
      var strategies = [
        raw,
        truncateFrames,
        truncateStrings.bind(null, 1024),
        truncateStrings.bind(null, 512),
        truncateStrings.bind(null, 256),
        minBody
      ];
      var strategy, results, result;
      while (strategy = strategies.shift()) {
        results = strategy(payload, jsonBackup);
        payload = results[0];
        result = results[1];
        if (result.error || !needsTruncation(result.value, maxSize)) {
          return result;
        }
      }
      return result;
    }
    module2.exports = {
      truncate,
      raw,
      truncateFrames,
      truncateStrings,
      maybeTruncateValue
    };
  }
});

// node_modules/json-stringify-safe/stringify.js
var require_stringify = __commonJS({
  "node_modules/json-stringify-safe/stringify.js"(exports, module2) {
    exports = module2.exports = stringify;
    exports.getSerialize = serializer;
    function stringify(obj, replacer, spaces, cycleReplacer) {
      return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces);
    }
    function serializer(replacer, cycleReplacer) {
      var stack = [], keys = [];
      if (cycleReplacer == null)
        cycleReplacer = function(key, value) {
          if (stack[0] === value)
            return "[Circular ~]";
          return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
        };
      return function(key, value) {
        if (stack.length > 0) {
          var thisPos = stack.indexOf(this);
          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
          ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
          if (~stack.indexOf(value))
            value = cycleReplacer.call(this, key, value);
        } else
          stack.push(value);
        return replacer == null ? value : replacer.call(this, key, value);
      };
    }
  }
});

// node_modules/rollbar/src/server/transport.js
var require_transport = __commonJS({
  "node_modules/rollbar/src/server/transport.js"(exports, module2) {
    var _ = require_utility();
    var truncation = require_truncation();
    var logger = require_logger();
    var http = require("http");
    var https = require("https");
    var jsonBackup = require_stringify();
    var MAX_RATE_LIMIT_INTERVAL = 60;
    function Transport() {
      this.rateLimitExpires = 0;
    }
    Transport.prototype.get = function(accessToken, options, params, callback, transportFactory) {
      var t;
      if (!callback || !_.isFunction(callback)) {
        callback = function() {
        };
      }
      options = options || {};
      _.addParamsAndAccessTokenToPath(accessToken, options, params);
      options.headers = _headers(accessToken, options);
      if (transportFactory) {
        t = transportFactory(options);
      } else {
        t = _transport(options);
      }
      if (!t) {
        logger.error("Unknown transport based on given protocol: " + options.protocol);
        return callback(new Error("Unknown transport"));
      }
      var req = t.request(options, function(resp) {
        this.handleResponse(resp, callback);
      }.bind(this));
      req.on("error", function(err) {
        callback(err);
      });
      req.end();
    };
    Transport.prototype.post = function(accessToken, options, payload, callback, transportFactory) {
      var t;
      if (!callback || !_.isFunction(callback)) {
        callback = function() {
        };
      }
      if (_currentTime() < this.rateLimitExpires) {
        return callback(new Error("Exceeded rate limit"));
      }
      options = options || {};
      if (!payload) {
        return callback(new Error("Cannot send empty request"));
      }
      var stringifyResult = truncation.truncate(payload, jsonBackup);
      if (stringifyResult.error) {
        logger.error("Problem stringifying payload. Giving up");
        return callback(stringifyResult.error);
      }
      var writeData = stringifyResult.value;
      options.headers = _headers(accessToken, options, writeData);
      if (transportFactory) {
        t = transportFactory(options);
      } else {
        t = _transport(options);
      }
      if (!t) {
        logger.error("Unknown transport based on given protocol: " + options.protocol);
        return callback(new Error("Unknown transport"));
      }
      var req = t.request(options, function(resp) {
        this.handleResponse(resp, _wrapPostCallback(callback));
      }.bind(this));
      req.on("error", function(err) {
        callback(err);
      });
      if (writeData) {
        req.write(writeData);
      }
      req.end();
    };
    Transport.prototype.updateRateLimit = function(resp) {
      var remaining = parseInt(resp.headers["x-rate-limit-remaining"] || 0);
      var remainingSeconds = Math.min(MAX_RATE_LIMIT_INTERVAL, resp.headers["x-rate-limit-remaining-seconds"] || 0);
      var currentTime = _currentTime();
      if (resp.statusCode === 429 && remaining === 0) {
        this.rateLimitExpires = currentTime + remainingSeconds;
      } else {
        this.rateLimitExpires = currentTime;
      }
    };
    Transport.prototype.handleResponse = function(resp, callback) {
      this.updateRateLimit(resp);
      var respData = [];
      resp.setEncoding("utf8");
      resp.on("data", function(chunk) {
        respData.push(chunk);
      });
      resp.on("end", function() {
        respData = respData.join("");
        _parseApiResponse(respData, callback);
      });
    };
    function _headers(accessToken, options, data) {
      var headers = options && options.headers || {};
      headers["Content-Type"] = "application/json";
      if (data) {
        try {
          headers["Content-Length"] = Buffer.byteLength(data, "utf8");
        } catch (e) {
          logger.error("Could not get the content length of the data");
        }
      }
      headers["X-Rollbar-Access-Token"] = accessToken;
      return headers;
    }
    function _transport(options) {
      return { "http:": http, "https:": https }[options.protocol];
    }
    function _parseApiResponse(data, callback) {
      var parsedData = _.jsonParse(data);
      if (parsedData.error) {
        logger.error("Could not parse api response, err: " + parsedData.error);
        return callback(parsedData.error);
      }
      data = parsedData.value;
      if (data.err) {
        logger.error("Received error: " + data.message);
        return callback(new Error("Api error: " + (data.message || "Unknown error")));
      }
      callback(null, data);
    }
    function _wrapPostCallback(callback) {
      return function(err, data) {
        if (err) {
          return callback(err);
        }
        if (data.result && data.result.uuid) {
          logger.log([
            "Successful api response.",
            " Link: https://rollbar.com/occurrence/uuid/?uuid=" + data.result.uuid
          ].join(""));
        } else {
          logger.log("Successful api response");
        }
        callback(null, data.result);
      };
    }
    function _currentTime() {
      return Math.floor(Date.now() / 1e3);
    }
    module2.exports = Transport;
  }
});

// node_modules/rollbar/src/telemetry.js
var require_telemetry = __commonJS({
  "node_modules/rollbar/src/telemetry.js"(exports, module2) {
    var _ = require_utility();
    var MAX_EVENTS = 100;
    function Telemeter(options) {
      this.queue = [];
      this.options = _.merge(options);
      var maxTelemetryEvents = this.options.maxTelemetryEvents || MAX_EVENTS;
      this.maxQueueSize = Math.max(0, Math.min(maxTelemetryEvents, MAX_EVENTS));
    }
    Telemeter.prototype.configure = function(options) {
      var oldOptions = this.options;
      this.options = _.merge(oldOptions, options);
      var maxTelemetryEvents = this.options.maxTelemetryEvents || MAX_EVENTS;
      var newMaxEvents = Math.max(0, Math.min(maxTelemetryEvents, MAX_EVENTS));
      var deleteCount = 0;
      if (this.maxQueueSize > newMaxEvents) {
        deleteCount = this.maxQueueSize - newMaxEvents;
      }
      this.maxQueueSize = newMaxEvents;
      this.queue.splice(0, deleteCount);
    };
    Telemeter.prototype.copyEvents = function() {
      var events = Array.prototype.slice.call(this.queue, 0);
      if (_.isFunction(this.options.filterTelemetry)) {
        try {
          var i = events.length;
          while (i--) {
            if (this.options.filterTelemetry(events[i])) {
              events.splice(i, 1);
            }
          }
        } catch (e) {
          this.options.filterTelemetry = null;
        }
      }
      return events;
    };
    Telemeter.prototype.capture = function(type, metadata, level, rollbarUUID, timestamp) {
      var e = {
        level: getLevel(type, level),
        type,
        timestamp_ms: timestamp || _.now(),
        body: metadata,
        source: "client"
      };
      if (rollbarUUID) {
        e.uuid = rollbarUUID;
      }
      try {
        if (_.isFunction(this.options.filterTelemetry) && this.options.filterTelemetry(e)) {
          return false;
        }
      } catch (exc) {
        this.options.filterTelemetry = null;
      }
      this.push(e);
      return e;
    };
    Telemeter.prototype.captureEvent = function(type, metadata, level, rollbarUUID) {
      return this.capture(type, metadata, level, rollbarUUID);
    };
    Telemeter.prototype.captureError = function(err, level, rollbarUUID, timestamp) {
      var metadata = {
        message: err.message || String(err)
      };
      if (err.stack) {
        metadata.stack = err.stack;
      }
      return this.capture("error", metadata, level, rollbarUUID, timestamp);
    };
    Telemeter.prototype.captureLog = function(message, level, rollbarUUID, timestamp) {
      return this.capture("log", {
        message
      }, level, rollbarUUID, timestamp);
    };
    Telemeter.prototype.captureNetwork = function(metadata, subtype, rollbarUUID, requestData) {
      subtype = subtype || "xhr";
      metadata.subtype = metadata.subtype || subtype;
      if (requestData) {
        metadata.request = requestData;
      }
      var level = this.levelFromStatus(metadata.status_code);
      return this.capture("network", metadata, level, rollbarUUID);
    };
    Telemeter.prototype.levelFromStatus = function(statusCode) {
      if (statusCode >= 200 && statusCode < 400) {
        return "info";
      }
      if (statusCode === 0 || statusCode >= 400) {
        return "error";
      }
      return "info";
    };
    Telemeter.prototype.captureDom = function(subtype, element, value, checked, rollbarUUID) {
      var metadata = {
        subtype,
        element
      };
      if (value !== void 0) {
        metadata.value = value;
      }
      if (checked !== void 0) {
        metadata.checked = checked;
      }
      return this.capture("dom", metadata, "info", rollbarUUID);
    };
    Telemeter.prototype.captureNavigation = function(from, to, rollbarUUID) {
      return this.capture("navigation", { from, to }, "info", rollbarUUID);
    };
    Telemeter.prototype.captureDomContentLoaded = function(ts) {
      return this.capture("navigation", { subtype: "DOMContentLoaded" }, "info", void 0, ts && ts.getTime());
    };
    Telemeter.prototype.captureLoad = function(ts) {
      return this.capture("navigation", { subtype: "load" }, "info", void 0, ts && ts.getTime());
    };
    Telemeter.prototype.captureConnectivityChange = function(type, rollbarUUID) {
      return this.captureNetwork({ change: type }, "connectivity", rollbarUUID);
    };
    Telemeter.prototype._captureRollbarItem = function(item) {
      if (!this.options.includeItemsInTelemetry) {
        return;
      }
      if (item.err) {
        return this.captureError(item.err, item.level, item.uuid, item.timestamp);
      }
      if (item.message) {
        return this.captureLog(item.message, item.level, item.uuid, item.timestamp);
      }
      if (item.custom) {
        return this.capture("log", item.custom, item.level, item.uuid, item.timestamp);
      }
    };
    Telemeter.prototype.push = function(e) {
      this.queue.push(e);
      if (this.queue.length > this.maxQueueSize) {
        this.queue.shift();
      }
    };
    function getLevel(type, level) {
      if (level) {
        return level;
      }
      var defaultLevel = {
        error: "error",
        manual: "info"
      };
      return defaultLevel[type] || "info";
    }
    module2.exports = Telemeter;
  }
});

// node_modules/rollbar/src/server/telemetry/urlHelpers.js
var require_urlHelpers = __commonJS({
  "node_modules/rollbar/src/server/telemetry/urlHelpers.js"(exports, module2) {
    var url = require("url");
    var { URL } = require("url");
    var merge = require_merge();
    function mergeOptions(input, options, cb) {
      if (typeof input === "string") {
        const urlStr = input;
        input = urlToHttpOptions(new URL(urlStr));
      } else if (input && input[url.searchParamsSymbol] && input[url.searchParamsSymbol][url.searchParamsSymbol]) {
        input = urlToHttpOptions(input);
      } else {
        cb = options;
        options = input;
        input = null;
      }
      if (typeof options === "function") {
        cb = options;
        options = input || {};
      } else {
        options = merge(input || {}, options);
      }
      return { options, cb };
    }
    function urlToHttpOptions(url2) {
      const options = {
        protocol: url2.protocol,
        hostname: typeof url2.hostname === "string" && url2.hostname.startsWith("[") ? url2.hostname.slice(1, -1) : url2.hostname,
        hash: url2.hash,
        search: url2.search,
        pathname: url2.pathname,
        path: `${url2.pathname || ""}${url2.search || ""}`,
        href: url2.href
      };
      if (url2.port !== "") {
        options.port = Number(url2.port);
      }
      if (url2.username || url2.password) {
        options.auth = `${url2.username}:${url2.password}`;
      }
      return options;
    }
    function constructUrl(options) {
      var url2 = options.protocol || "http:";
      url2 += "//";
      if (options.auth) {
        url2 += `${options.auth}@`;
      }
      url2 += options.hostname || options.host || "localhost";
      if (options.port) {
        url2 += `:${options.port}`;
      }
      url2 += options.path || "/";
      return url2;
    }
    module2.exports = {
      mergeOptions,
      constructUrl
    };
  }
});

// node_modules/rollbar/src/server/telemetry.js
var require_telemetry2 = __commonJS({
  "node_modules/rollbar/src/server/telemetry.js"(exports, module2) {
    var http = require("http");
    var https = require("https");
    var _ = require_utility();
    var urlHelpers = require_urlHelpers();
    var defaults = {
      network: true,
      networkResponseHeaders: false,
      networkRequestHeaders: false,
      log: true
    };
    function Instrumenter(options, telemeter, rollbar) {
      this.options = options;
      var autoInstrument = options.autoInstrument;
      if (options.enabled === false || autoInstrument === false) {
        this.autoInstrument = {};
      } else {
        if (!_.isType(autoInstrument, "object")) {
          autoInstrument = defaults;
        }
        this.autoInstrument = _.merge(defaults, autoInstrument);
      }
      this.telemeter = telemeter;
      this.rollbar = rollbar;
      this.diagnostic = rollbar.client.notifier.diagnostic;
      this.replacements = {
        network: [],
        log: []
      };
    }
    Instrumenter.prototype.configure = function(options) {
      this.options = _.merge(this.options, options);
      var autoInstrument = options.autoInstrument;
      var oldSettings = _.merge(this.autoInstrument);
      if (options.enabled === false || autoInstrument === false) {
        this.autoInstrument = {};
      } else {
        if (!_.isType(autoInstrument, "object")) {
          autoInstrument = defaults;
        }
        this.autoInstrument = _.merge(defaults, autoInstrument);
      }
      this.instrument(oldSettings);
    };
    Instrumenter.prototype.instrument = function(oldSettings) {
      if (this.autoInstrument.network && !(oldSettings && oldSettings.network)) {
        this.instrumentNetwork();
      } else if (!this.autoInstrument.network && oldSettings && oldSettings.network) {
        this.deinstrumentNetwork();
      }
      if (this.autoInstrument.log && !(oldSettings && oldSettings.log)) {
        this.instrumentConsole();
      } else if (!this.autoInstrument.log && oldSettings && oldSettings.log) {
        this.deinstrumentConsole();
      }
    };
    Instrumenter.prototype.deinstrumentNetwork = function() {
      restore(this.replacements, "network");
    };
    Instrumenter.prototype.instrumentNetwork = function() {
      replace(http, "request", networkRequestWrapper.bind(this), this.replacements, "network");
      replace(https, "request", networkRequestWrapper.bind(this), this.replacements, "network");
    };
    function networkRequestWrapper(orig) {
      var telemeter = this.telemeter;
      var self2 = this;
      return function(url, options, cb) {
        var mergedOptions = urlHelpers.mergeOptions(url, options, cb);
        var metadata = {
          method: mergedOptions.options.method || "GET",
          url: urlHelpers.constructUrl(mergedOptions.options),
          status_code: null,
          start_time_ms: _.now(),
          end_time_ms: null
        };
        if (self2.autoInstrument.networkRequestHeaders) {
          metadata.request_headers = mergedOptions.options.headers;
        }
        telemeter.captureNetwork(metadata, "http");
        var wrappedArgs = Array.from(arguments);
        var wrappedCallback = responseCallbackWrapper(self2.autoInstrument, metadata, mergedOptions.cb);
        if (mergedOptions.cb) {
          wrappedArgs.pop();
        }
        wrappedArgs.push(wrappedCallback);
        var req = orig.apply(https, wrappedArgs);
        req.on("error", (err) => {
          metadata.status_code = 0;
          metadata.error = [err.name, err.message].join(": ");
        });
        return req;
      };
    }
    function responseCallbackWrapper(options, metadata, callback) {
      return function(res) {
        metadata.end_time_ms = _.now();
        metadata.status_code = res.statusCode;
        metadata.response = {};
        if (options.networkResponseHeaders) {
          metadata.response.headers = res.headers;
        }
        if (callback) {
          return callback.apply(void 0, arguments);
        }
      };
    }
    Instrumenter.prototype.captureNetwork = function(metadata, subtype, rollbarUUID) {
      return this.telemeter.captureNetwork(metadata, subtype, rollbarUUID);
    };
    Instrumenter.prototype.deinstrumentConsole = function() {
      restore(this.replacements, "log");
    };
    Instrumenter.prototype.instrumentConsole = function() {
      var telemeter = this.telemeter;
      var stdout = process.stdout;
      replace(stdout, "write", function(orig) {
        return function(string) {
          telemeter.captureLog(string, "info");
          return orig.apply(stdout, arguments);
        };
      }, this.replacements, "log");
      var stderr = process.stderr;
      replace(stderr, "write", function(orig) {
        return function(string) {
          telemeter.captureLog(string, "error");
          return orig.apply(stderr, arguments);
        };
      }, this.replacements, "log");
    };
    function replace(obj, name, replacement, replacements, type) {
      var orig = obj[name];
      obj[name] = replacement(orig);
      if (replacements) {
        replacements[type].push([obj, name, orig]);
      }
    }
    function restore(replacements, type) {
      var b;
      while (replacements[type].length) {
        b = replacements[type].shift();
        b[0][b[1]] = b[2];
      }
    }
    module2.exports = Instrumenter;
  }
});

// node_modules/async/dist/async.js
var require_async2 = __commonJS({
  "node_modules/async/dist/async.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.async = {});
    })(exports, function(exports2) {
      "use strict";
      function apply(fn, ...args) {
        return (...callArgs) => fn(...args, ...callArgs);
      }
      function initialParams(fn) {
        return function(...args) {
          var callback = args.pop();
          return fn.call(this, args, callback);
        };
      }
      var hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
      var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
      var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
      function fallback(fn) {
        setTimeout(fn, 0);
      }
      function wrap(defer) {
        return (fn, ...args) => defer(() => fn(...args));
      }
      var _defer;
      if (hasQueueMicrotask) {
        _defer = queueMicrotask;
      } else if (hasSetImmediate) {
        _defer = setImmediate;
      } else if (hasNextTick) {
        _defer = process.nextTick;
      } else {
        _defer = fallback;
      }
      var setImmediate$1 = wrap(_defer);
      function asyncify(func) {
        if (isAsync(func)) {
          return function(...args) {
            const callback = args.pop();
            const promise = func.apply(this, args);
            return handlePromise(promise, callback);
          };
        }
        return initialParams(function(args, callback) {
          var result;
          try {
            result = func.apply(this, args);
          } catch (e) {
            return callback(e);
          }
          if (result && typeof result.then === "function") {
            return handlePromise(result, callback);
          } else {
            callback(null, result);
          }
        });
      }
      function handlePromise(promise, callback) {
        return promise.then((value) => {
          invokeCallback(callback, null, value);
        }, (err) => {
          invokeCallback(callback, err && err.message ? err : new Error(err));
        });
      }
      function invokeCallback(callback, error, value) {
        try {
          callback(error, value);
        } catch (err) {
          setImmediate$1((e) => {
            throw e;
          }, err);
        }
      }
      function isAsync(fn) {
        return fn[Symbol.toStringTag] === "AsyncFunction";
      }
      function isAsyncGenerator(fn) {
        return fn[Symbol.toStringTag] === "AsyncGenerator";
      }
      function isAsyncIterable(obj) {
        return typeof obj[Symbol.asyncIterator] === "function";
      }
      function wrapAsync(asyncFn) {
        if (typeof asyncFn !== "function")
          throw new Error("expected a function");
        return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
      }
      function awaitify(asyncFn, arity = asyncFn.length) {
        if (!arity)
          throw new Error("arity is undefined");
        function awaitable(...args) {
          if (typeof args[arity - 1] === "function") {
            return asyncFn.apply(this, args);
          }
          return new Promise((resolve, reject2) => {
            args[arity - 1] = (err, ...cbArgs) => {
              if (err)
                return reject2(err);
              resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
            };
            asyncFn.apply(this, args);
          });
        }
        return awaitable;
      }
      function applyEach(eachfn) {
        return function applyEach2(fns, ...callArgs) {
          const go = awaitify(function(callback) {
            var that = this;
            return eachfn(fns, (fn, cb) => {
              wrapAsync(fn).apply(that, callArgs.concat(cb));
            }, callback);
          });
          return go;
        };
      }
      function _asyncMap(eachfn, arr, iteratee, callback) {
        arr = arr || [];
        var results = [];
        var counter = 0;
        var _iteratee = wrapAsync(iteratee);
        return eachfn(arr, (value, _, iterCb) => {
          var index2 = counter++;
          _iteratee(value, (err, v) => {
            results[index2] = v;
            iterCb(err);
          });
        }, (err) => {
          callback(err, results);
        });
      }
      function isArrayLike(value) {
        return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
      }
      const breakLoop = {};
      function once(fn) {
        function wrapper(...args) {
          if (fn === null)
            return;
          var callFn = fn;
          fn = null;
          callFn.apply(this, args);
        }
        Object.assign(wrapper, fn);
        return wrapper;
      }
      function getIterator(coll) {
        return coll[Symbol.iterator] && coll[Symbol.iterator]();
      }
      function createArrayIterator(coll) {
        var i = -1;
        var len = coll.length;
        return function next() {
          return ++i < len ? { value: coll[i], key: i } : null;
        };
      }
      function createES2015Iterator(iterator) {
        var i = -1;
        return function next() {
          var item = iterator.next();
          if (item.done)
            return null;
          i++;
          return { value: item.value, key: i };
        };
      }
      function createObjectIterator(obj) {
        var okeys = obj ? Object.keys(obj) : [];
        var i = -1;
        var len = okeys.length;
        return function next() {
          var key = okeys[++i];
          if (key === "__proto__") {
            return next();
          }
          return i < len ? { value: obj[key], key } : null;
        };
      }
      function createIterator(coll) {
        if (isArrayLike(coll)) {
          return createArrayIterator(coll);
        }
        var iterator = getIterator(coll);
        return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
      }
      function onlyOnce(fn) {
        return function(...args) {
          if (fn === null)
            throw new Error("Callback was already called.");
          var callFn = fn;
          fn = null;
          callFn.apply(this, args);
        };
      }
      function asyncEachOfLimit(generator, limit, iteratee, callback) {
        let done = false;
        let canceled = false;
        let awaiting = false;
        let running = 0;
        let idx = 0;
        function replenish() {
          if (running >= limit || awaiting || done)
            return;
          awaiting = true;
          generator.next().then(({ value, done: iterDone }) => {
            if (canceled || done)
              return;
            awaiting = false;
            if (iterDone) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running++;
            iteratee(value, idx, iterateeCallback);
            idx++;
            replenish();
          }).catch(handleError);
        }
        function iterateeCallback(err, result) {
          running -= 1;
          if (canceled)
            return;
          if (err)
            return handleError(err);
          if (err === false) {
            done = true;
            canceled = true;
            return;
          }
          if (result === breakLoop || done && running <= 0) {
            done = true;
            return callback(null);
          }
          replenish();
        }
        function handleError(err) {
          if (canceled)
            return;
          awaiting = false;
          done = true;
          callback(err);
        }
        replenish();
      }
      var eachOfLimit = (limit) => {
        return (obj, iteratee, callback) => {
          callback = once(callback);
          if (limit <= 0) {
            throw new RangeError("concurrency limit cannot be less than 1");
          }
          if (!obj) {
            return callback(null);
          }
          if (isAsyncGenerator(obj)) {
            return asyncEachOfLimit(obj, limit, iteratee, callback);
          }
          if (isAsyncIterable(obj)) {
            return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback);
          }
          var nextElem = createIterator(obj);
          var done = false;
          var canceled = false;
          var running = 0;
          var looping = false;
          function iterateeCallback(err, value) {
            if (canceled)
              return;
            running -= 1;
            if (err) {
              done = true;
              callback(err);
            } else if (err === false) {
              done = true;
              canceled = true;
            } else if (value === breakLoop || done && running <= 0) {
              done = true;
              return callback(null);
            } else if (!looping) {
              replenish();
            }
          }
          function replenish() {
            looping = true;
            while (running < limit && !done) {
              var elem = nextElem();
              if (elem === null) {
                done = true;
                if (running <= 0) {
                  callback(null);
                }
                return;
              }
              running += 1;
              iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
            }
            looping = false;
          }
          replenish();
        };
      };
      function eachOfLimit$1(coll, limit, iteratee, callback) {
        return eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
      }
      var eachOfLimit$2 = awaitify(eachOfLimit$1, 4);
      function eachOfArrayLike(coll, iteratee, callback) {
        callback = once(callback);
        var index2 = 0, completed = 0, { length } = coll, canceled = false;
        if (length === 0) {
          callback(null);
        }
        function iteratorCallback(err, value) {
          if (err === false) {
            canceled = true;
          }
          if (canceled === true)
            return;
          if (err) {
            callback(err);
          } else if (++completed === length || value === breakLoop) {
            callback(null);
          }
        }
        for (; index2 < length; index2++) {
          iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
        }
      }
      function eachOfGeneric(coll, iteratee, callback) {
        return eachOfLimit$2(coll, Infinity, iteratee, callback);
      }
      function eachOf(coll, iteratee, callback) {
        var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
        return eachOfImplementation(coll, wrapAsync(iteratee), callback);
      }
      var eachOf$1 = awaitify(eachOf, 3);
      function map(coll, iteratee, callback) {
        return _asyncMap(eachOf$1, coll, iteratee, callback);
      }
      var map$1 = awaitify(map, 3);
      var applyEach$1 = applyEach(map$1);
      function eachOfSeries(coll, iteratee, callback) {
        return eachOfLimit$2(coll, 1, iteratee, callback);
      }
      var eachOfSeries$1 = awaitify(eachOfSeries, 3);
      function mapSeries(coll, iteratee, callback) {
        return _asyncMap(eachOfSeries$1, coll, iteratee, callback);
      }
      var mapSeries$1 = awaitify(mapSeries, 3);
      var applyEachSeries = applyEach(mapSeries$1);
      const PROMISE_SYMBOL = Symbol("promiseCallback");
      function promiseCallback() {
        let resolve, reject2;
        function callback(err, ...args) {
          if (err)
            return reject2(err);
          resolve(args.length > 1 ? args : args[0]);
        }
        callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
          resolve = res, reject2 = rej;
        });
        return callback;
      }
      function auto(tasks, concurrency, callback) {
        if (typeof concurrency !== "number") {
          callback = concurrency;
          concurrency = null;
        }
        callback = once(callback || promiseCallback());
        var numTasks = Object.keys(tasks).length;
        if (!numTasks) {
          return callback(null);
        }
        if (!concurrency) {
          concurrency = numTasks;
        }
        var results = {};
        var runningTasks = 0;
        var canceled = false;
        var hasError = false;
        var listeners = /* @__PURE__ */ Object.create(null);
        var readyTasks = [];
        var readyToCheck = [];
        var uncheckedDependencies = {};
        Object.keys(tasks).forEach((key) => {
          var task = tasks[key];
          if (!Array.isArray(task)) {
            enqueueTask(key, [task]);
            readyToCheck.push(key);
            return;
          }
          var dependencies = task.slice(0, task.length - 1);
          var remainingDependencies = dependencies.length;
          if (remainingDependencies === 0) {
            enqueueTask(key, task);
            readyToCheck.push(key);
            return;
          }
          uncheckedDependencies[key] = remainingDependencies;
          dependencies.forEach((dependencyName) => {
            if (!tasks[dependencyName]) {
              throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
            }
            addListener(dependencyName, () => {
              remainingDependencies--;
              if (remainingDependencies === 0) {
                enqueueTask(key, task);
              }
            });
          });
        });
        checkForDeadlocks();
        processQueue();
        function enqueueTask(key, task) {
          readyTasks.push(() => runTask(key, task));
        }
        function processQueue() {
          if (canceled)
            return;
          if (readyTasks.length === 0 && runningTasks === 0) {
            return callback(null, results);
          }
          while (readyTasks.length && runningTasks < concurrency) {
            var run = readyTasks.shift();
            run();
          }
        }
        function addListener(taskName, fn) {
          var taskListeners = listeners[taskName];
          if (!taskListeners) {
            taskListeners = listeners[taskName] = [];
          }
          taskListeners.push(fn);
        }
        function taskComplete(taskName) {
          var taskListeners = listeners[taskName] || [];
          taskListeners.forEach((fn) => fn());
          processQueue();
        }
        function runTask(key, task) {
          if (hasError)
            return;
          var taskCallback = onlyOnce((err, ...result) => {
            runningTasks--;
            if (err === false) {
              canceled = true;
              return;
            }
            if (result.length < 2) {
              [result] = result;
            }
            if (err) {
              var safeResults = {};
              Object.keys(results).forEach((rkey) => {
                safeResults[rkey] = results[rkey];
              });
              safeResults[key] = result;
              hasError = true;
              listeners = /* @__PURE__ */ Object.create(null);
              if (canceled)
                return;
              callback(err, safeResults);
            } else {
              results[key] = result;
              taskComplete(key);
            }
          });
          runningTasks++;
          var taskFn = wrapAsync(task[task.length - 1]);
          if (task.length > 1) {
            taskFn(results, taskCallback);
          } else {
            taskFn(taskCallback);
          }
        }
        function checkForDeadlocks() {
          var currentTask;
          var counter = 0;
          while (readyToCheck.length) {
            currentTask = readyToCheck.pop();
            counter++;
            getDependents(currentTask).forEach((dependent) => {
              if (--uncheckedDependencies[dependent] === 0) {
                readyToCheck.push(dependent);
              }
            });
          }
          if (counter !== numTasks) {
            throw new Error(
              "async.auto cannot execute tasks due to a recursive dependency"
            );
          }
        }
        function getDependents(taskName) {
          var result = [];
          Object.keys(tasks).forEach((key) => {
            const task = tasks[key];
            if (Array.isArray(task) && task.indexOf(taskName) >= 0) {
              result.push(key);
            }
          });
          return result;
        }
        return callback[PROMISE_SYMBOL];
      }
      var FN_ARGS = /^(?:async\s+)?(?:function)?\s*\w*\s*\(\s*([^)]+)\s*\)(?:\s*{)/;
      var ARROW_FN_ARGS = /^(?:async\s+)?\(?\s*([^)=]+)\s*\)?(?:\s*=>)/;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /(=.+)?(\s*)$/;
      function stripComments(string) {
        let stripped = "";
        let index2 = 0;
        let endBlockComment = string.indexOf("*/");
        while (index2 < string.length) {
          if (string[index2] === "/" && string[index2 + 1] === "/") {
            let endIndex = string.indexOf("\n", index2);
            index2 = endIndex === -1 ? string.length : endIndex;
          } else if (endBlockComment !== -1 && string[index2] === "/" && string[index2 + 1] === "*") {
            let endIndex = string.indexOf("*/", index2);
            if (endIndex !== -1) {
              index2 = endIndex + 2;
              endBlockComment = string.indexOf("*/", index2);
            } else {
              stripped += string[index2];
              index2++;
            }
          } else {
            stripped += string[index2];
            index2++;
          }
        }
        return stripped;
      }
      function parseParams(func) {
        const src = stripComments(func.toString());
        let match = src.match(FN_ARGS);
        if (!match) {
          match = src.match(ARROW_FN_ARGS);
        }
        if (!match)
          throw new Error("could not parse args in autoInject\nSource:\n" + src);
        let [, args] = match;
        return args.replace(/\s/g, "").split(FN_ARG_SPLIT).map((arg) => arg.replace(FN_ARG, "").trim());
      }
      function autoInject(tasks, callback) {
        var newTasks = {};
        Object.keys(tasks).forEach((key) => {
          var taskFn = tasks[key];
          var params;
          var fnIsAsync = isAsync(taskFn);
          var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
          if (Array.isArray(taskFn)) {
            params = [...taskFn];
            taskFn = params.pop();
            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
          } else if (hasNoDeps) {
            newTasks[key] = taskFn;
          } else {
            params = parseParams(taskFn);
            if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
              throw new Error("autoInject task functions require explicit parameters.");
            }
            if (!fnIsAsync)
              params.pop();
            newTasks[key] = params.concat(newTask);
          }
          function newTask(results, taskCb) {
            var newArgs = params.map((name) => results[name]);
            newArgs.push(taskCb);
            wrapAsync(taskFn)(...newArgs);
          }
        });
        return auto(newTasks, callback);
      }
      class DLL {
        constructor() {
          this.head = this.tail = null;
          this.length = 0;
        }
        removeLink(node) {
          if (node.prev)
            node.prev.next = node.next;
          else
            this.head = node.next;
          if (node.next)
            node.next.prev = node.prev;
          else
            this.tail = node.prev;
          node.prev = node.next = null;
          this.length -= 1;
          return node;
        }
        empty() {
          while (this.head)
            this.shift();
          return this;
        }
        insertAfter(node, newNode) {
          newNode.prev = node;
          newNode.next = node.next;
          if (node.next)
            node.next.prev = newNode;
          else
            this.tail = newNode;
          node.next = newNode;
          this.length += 1;
        }
        insertBefore(node, newNode) {
          newNode.prev = node.prev;
          newNode.next = node;
          if (node.prev)
            node.prev.next = newNode;
          else
            this.head = newNode;
          node.prev = newNode;
          this.length += 1;
        }
        unshift(node) {
          if (this.head)
            this.insertBefore(this.head, node);
          else
            setInitial(this, node);
        }
        push(node) {
          if (this.tail)
            this.insertAfter(this.tail, node);
          else
            setInitial(this, node);
        }
        shift() {
          return this.head && this.removeLink(this.head);
        }
        pop() {
          return this.tail && this.removeLink(this.tail);
        }
        toArray() {
          return [...this];
        }
        *[Symbol.iterator]() {
          var cur = this.head;
          while (cur) {
            yield cur.data;
            cur = cur.next;
          }
        }
        remove(testFn) {
          var curr = this.head;
          while (curr) {
            var { next } = curr;
            if (testFn(curr)) {
              this.removeLink(curr);
            }
            curr = next;
          }
          return this;
        }
      }
      function setInitial(dll, node) {
        dll.length = 1;
        dll.head = dll.tail = node;
      }
      function queue(worker, concurrency, payload) {
        if (concurrency == null) {
          concurrency = 1;
        } else if (concurrency === 0) {
          throw new RangeError("Concurrency must not be zero");
        }
        var _worker = wrapAsync(worker);
        var numRunning = 0;
        var workersList = [];
        const events = {
          error: [],
          drain: [],
          saturated: [],
          unsaturated: [],
          empty: []
        };
        function on(event, handler) {
          events[event].push(handler);
        }
        function once2(event, handler) {
          const handleAndRemove = (...args) => {
            off(event, handleAndRemove);
            handler(...args);
          };
          events[event].push(handleAndRemove);
        }
        function off(event, handler) {
          if (!event)
            return Object.keys(events).forEach((ev) => events[ev] = []);
          if (!handler)
            return events[event] = [];
          events[event] = events[event].filter((ev) => ev !== handler);
        }
        function trigger(event, ...args) {
          events[event].forEach((handler) => handler(...args));
        }
        var processingScheduled = false;
        function _insert(data, insertAtFront, rejectOnError, callback) {
          if (callback != null && typeof callback !== "function") {
            throw new Error("task callback must be a function");
          }
          q.started = true;
          var res, rej;
          function promiseCallback2(err, ...args) {
            if (err)
              return rejectOnError ? rej(err) : res();
            if (args.length <= 1)
              return res(args[0]);
            res(args);
          }
          var item = {
            data,
            callback: rejectOnError ? promiseCallback2 : callback || promiseCallback2
          };
          if (insertAtFront) {
            q._tasks.unshift(item);
          } else {
            q._tasks.push(item);
          }
          if (!processingScheduled) {
            processingScheduled = true;
            setImmediate$1(() => {
              processingScheduled = false;
              q.process();
            });
          }
          if (rejectOnError || !callback) {
            return new Promise((resolve, reject2) => {
              res = resolve;
              rej = reject2;
            });
          }
        }
        function _createCB(tasks) {
          return function(err, ...args) {
            numRunning -= 1;
            for (var i = 0, l = tasks.length; i < l; i++) {
              var task = tasks[i];
              var index2 = workersList.indexOf(task);
              if (index2 === 0) {
                workersList.shift();
              } else if (index2 > 0) {
                workersList.splice(index2, 1);
              }
              task.callback(err, ...args);
              if (err != null) {
                trigger("error", err, task.data);
              }
            }
            if (numRunning <= q.concurrency - q.buffer) {
              trigger("unsaturated");
            }
            if (q.idle()) {
              trigger("drain");
            }
            q.process();
          };
        }
        function _maybeDrain(data) {
          if (data.length === 0 && q.idle()) {
            setImmediate$1(() => trigger("drain"));
            return true;
          }
          return false;
        }
        const eventMethod = (name) => (handler) => {
          if (!handler) {
            return new Promise((resolve, reject2) => {
              once2(name, (err, data) => {
                if (err)
                  return reject2(err);
                resolve(data);
              });
            });
          }
          off(name);
          on(name, handler);
        };
        var isProcessing = false;
        var q = {
          _tasks: new DLL(),
          *[Symbol.iterator]() {
            yield* q._tasks[Symbol.iterator]();
          },
          concurrency,
          payload,
          buffer: concurrency / 4,
          started: false,
          paused: false,
          push(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data))
                return;
              return data.map((datum) => _insert(datum, false, false, callback));
            }
            return _insert(data, false, false, callback);
          },
          pushAsync(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data))
                return;
              return data.map((datum) => _insert(datum, false, true, callback));
            }
            return _insert(data, false, true, callback);
          },
          kill() {
            off();
            q._tasks.empty();
          },
          unshift(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data))
                return;
              return data.map((datum) => _insert(datum, true, false, callback));
            }
            return _insert(data, true, false, callback);
          },
          unshiftAsync(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data))
                return;
              return data.map((datum) => _insert(datum, true, true, callback));
            }
            return _insert(data, true, true, callback);
          },
          remove(testFn) {
            q._tasks.remove(testFn);
          },
          process() {
            if (isProcessing) {
              return;
            }
            isProcessing = true;
            while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
              var tasks = [], data = [];
              var l = q._tasks.length;
              if (q.payload)
                l = Math.min(l, q.payload);
              for (var i = 0; i < l; i++) {
                var node = q._tasks.shift();
                tasks.push(node);
                workersList.push(node);
                data.push(node.data);
              }
              numRunning += 1;
              if (q._tasks.length === 0) {
                trigger("empty");
              }
              if (numRunning === q.concurrency) {
                trigger("saturated");
              }
              var cb = onlyOnce(_createCB(tasks));
              _worker(data, cb);
            }
            isProcessing = false;
          },
          length() {
            return q._tasks.length;
          },
          running() {
            return numRunning;
          },
          workersList() {
            return workersList;
          },
          idle() {
            return q._tasks.length + numRunning === 0;
          },
          pause() {
            q.paused = true;
          },
          resume() {
            if (q.paused === false) {
              return;
            }
            q.paused = false;
            setImmediate$1(q.process);
          }
        };
        Object.defineProperties(q, {
          saturated: {
            writable: false,
            value: eventMethod("saturated")
          },
          unsaturated: {
            writable: false,
            value: eventMethod("unsaturated")
          },
          empty: {
            writable: false,
            value: eventMethod("empty")
          },
          drain: {
            writable: false,
            value: eventMethod("drain")
          },
          error: {
            writable: false,
            value: eventMethod("error")
          }
        });
        return q;
      }
      function cargo(worker, payload) {
        return queue(worker, 1, payload);
      }
      function cargo$1(worker, concurrency, payload) {
        return queue(worker, concurrency, payload);
      }
      function reduce(coll, memo, iteratee, callback) {
        callback = once(callback);
        var _iteratee = wrapAsync(iteratee);
        return eachOfSeries$1(coll, (x, i, iterCb) => {
          _iteratee(memo, x, (err, v) => {
            memo = v;
            iterCb(err);
          });
        }, (err) => callback(err, memo));
      }
      var reduce$1 = awaitify(reduce, 4);
      function seq(...functions) {
        var _functions = functions.map(wrapAsync);
        return function(...args) {
          var that = this;
          var cb = args[args.length - 1];
          if (typeof cb == "function") {
            args.pop();
          } else {
            cb = promiseCallback();
          }
          reduce$1(
            _functions,
            args,
            (newargs, fn, iterCb) => {
              fn.apply(that, newargs.concat((err, ...nextargs) => {
                iterCb(err, nextargs);
              }));
            },
            (err, results) => cb(err, ...results)
          );
          return cb[PROMISE_SYMBOL];
        };
      }
      function compose(...args) {
        return seq(...args.reverse());
      }
      function mapLimit(coll, limit, iteratee, callback) {
        return _asyncMap(eachOfLimit(limit), coll, iteratee, callback);
      }
      var mapLimit$1 = awaitify(mapLimit, 4);
      function concatLimit(coll, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(coll, limit, (val, iterCb) => {
          _iteratee(val, (err, ...args) => {
            if (err)
              return iterCb(err);
            return iterCb(err, args);
          });
        }, (err, mapResults) => {
          var result = [];
          for (var i = 0; i < mapResults.length; i++) {
            if (mapResults[i]) {
              result = result.concat(...mapResults[i]);
            }
          }
          return callback(err, result);
        });
      }
      var concatLimit$1 = awaitify(concatLimit, 4);
      function concat(coll, iteratee, callback) {
        return concatLimit$1(coll, Infinity, iteratee, callback);
      }
      var concat$1 = awaitify(concat, 3);
      function concatSeries(coll, iteratee, callback) {
        return concatLimit$1(coll, 1, iteratee, callback);
      }
      var concatSeries$1 = awaitify(concatSeries, 3);
      function constant(...args) {
        return function(...ignoredArgs) {
          var callback = ignoredArgs.pop();
          return callback(null, ...args);
        };
      }
      function _createTester(check, getResult) {
        return (eachfn, arr, _iteratee, cb) => {
          var testPassed = false;
          var testResult;
          const iteratee = wrapAsync(_iteratee);
          eachfn(arr, (value, _, callback) => {
            iteratee(value, (err, result) => {
              if (err || err === false)
                return callback(err);
              if (check(result) && !testResult) {
                testPassed = true;
                testResult = getResult(true, value);
                return callback(null, breakLoop);
              }
              callback();
            });
          }, (err) => {
            if (err)
              return cb(err);
            cb(null, testPassed ? testResult : getResult(false));
          });
        };
      }
      function detect(coll, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback);
      }
      var detect$1 = awaitify(detect, 3);
      function detectLimit(coll, limit, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOfLimit(limit), coll, iteratee, callback);
      }
      var detectLimit$1 = awaitify(detectLimit, 4);
      function detectSeries(coll, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOfLimit(1), coll, iteratee, callback);
      }
      var detectSeries$1 = awaitify(detectSeries, 3);
      function consoleFunc(name) {
        return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
          if (typeof console === "object") {
            if (err) {
              if (console.error) {
                console.error(err);
              }
            } else if (console[name]) {
              resultArgs.forEach((x) => console[name](x));
            }
          }
        });
      }
      var dir = consoleFunc("dir");
      function doWhilst(iteratee, test, callback) {
        callback = onlyOnce(callback);
        var _fn = wrapAsync(iteratee);
        var _test = wrapAsync(test);
        var results;
        function next(err, ...args) {
          if (err)
            return callback(err);
          if (err === false)
            return;
          results = args;
          _test(...args, check);
        }
        function check(err, truth) {
          if (err)
            return callback(err);
          if (err === false)
            return;
          if (!truth)
            return callback(null, ...results);
          _fn(next);
        }
        return check(null, true);
      }
      var doWhilst$1 = awaitify(doWhilst, 3);
      function doUntil(iteratee, test, callback) {
        const _test = wrapAsync(test);
        return doWhilst$1(iteratee, (...args) => {
          const cb = args.pop();
          _test(...args, (err, truth) => cb(err, !truth));
        }, callback);
      }
      function _withoutIndex(iteratee) {
        return (value, index2, callback) => iteratee(value, callback);
      }
      function eachLimit(coll, iteratee, callback) {
        return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
      }
      var each = awaitify(eachLimit, 3);
      function eachLimit$1(coll, limit, iteratee, callback) {
        return eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
      }
      var eachLimit$2 = awaitify(eachLimit$1, 4);
      function eachSeries(coll, iteratee, callback) {
        return eachLimit$2(coll, 1, iteratee, callback);
      }
      var eachSeries$1 = awaitify(eachSeries, 3);
      function ensureAsync(fn) {
        if (isAsync(fn))
          return fn;
        return function(...args) {
          var callback = args.pop();
          var sync = true;
          args.push((...innerArgs) => {
            if (sync) {
              setImmediate$1(() => callback(...innerArgs));
            } else {
              callback(...innerArgs);
            }
          });
          fn.apply(this, args);
          sync = false;
        };
      }
      function every(coll, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOf$1, coll, iteratee, callback);
      }
      var every$1 = awaitify(every, 3);
      function everyLimit(coll, limit, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOfLimit(limit), coll, iteratee, callback);
      }
      var everyLimit$1 = awaitify(everyLimit, 4);
      function everySeries(coll, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOfSeries$1, coll, iteratee, callback);
      }
      var everySeries$1 = awaitify(everySeries, 3);
      function filterArray(eachfn, arr, iteratee, callback) {
        var truthValues = new Array(arr.length);
        eachfn(arr, (x, index2, iterCb) => {
          iteratee(x, (err, v) => {
            truthValues[index2] = !!v;
            iterCb(err);
          });
        }, (err) => {
          if (err)
            return callback(err);
          var results = [];
          for (var i = 0; i < arr.length; i++) {
            if (truthValues[i])
              results.push(arr[i]);
          }
          callback(null, results);
        });
      }
      function filterGeneric(eachfn, coll, iteratee, callback) {
        var results = [];
        eachfn(coll, (x, index2, iterCb) => {
          iteratee(x, (err, v) => {
            if (err)
              return iterCb(err);
            if (v) {
              results.push({ index: index2, value: x });
            }
            iterCb(err);
          });
        }, (err) => {
          if (err)
            return callback(err);
          callback(null, results.sort((a, b) => a.index - b.index).map((v) => v.value));
        });
      }
      function _filter(eachfn, coll, iteratee, callback) {
        var filter2 = isArrayLike(coll) ? filterArray : filterGeneric;
        return filter2(eachfn, coll, wrapAsync(iteratee), callback);
      }
      function filter(coll, iteratee, callback) {
        return _filter(eachOf$1, coll, iteratee, callback);
      }
      var filter$1 = awaitify(filter, 3);
      function filterLimit(coll, limit, iteratee, callback) {
        return _filter(eachOfLimit(limit), coll, iteratee, callback);
      }
      var filterLimit$1 = awaitify(filterLimit, 4);
      function filterSeries(coll, iteratee, callback) {
        return _filter(eachOfSeries$1, coll, iteratee, callback);
      }
      var filterSeries$1 = awaitify(filterSeries, 3);
      function forever(fn, errback) {
        var done = onlyOnce(errback);
        var task = wrapAsync(ensureAsync(fn));
        function next(err) {
          if (err)
            return done(err);
          if (err === false)
            return;
          task(next);
        }
        return next();
      }
      var forever$1 = awaitify(forever, 2);
      function groupByLimit(coll, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(coll, limit, (val, iterCb) => {
          _iteratee(val, (err, key) => {
            if (err)
              return iterCb(err);
            return iterCb(err, { key, val });
          });
        }, (err, mapResults) => {
          var result = {};
          var { hasOwnProperty } = Object.prototype;
          for (var i = 0; i < mapResults.length; i++) {
            if (mapResults[i]) {
              var { key } = mapResults[i];
              var { val } = mapResults[i];
              if (hasOwnProperty.call(result, key)) {
                result[key].push(val);
              } else {
                result[key] = [val];
              }
            }
          }
          return callback(err, result);
        });
      }
      var groupByLimit$1 = awaitify(groupByLimit, 4);
      function groupBy(coll, iteratee, callback) {
        return groupByLimit$1(coll, Infinity, iteratee, callback);
      }
      function groupBySeries(coll, iteratee, callback) {
        return groupByLimit$1(coll, 1, iteratee, callback);
      }
      var log = consoleFunc("log");
      function mapValuesLimit(obj, limit, iteratee, callback) {
        callback = once(callback);
        var newObj = {};
        var _iteratee = wrapAsync(iteratee);
        return eachOfLimit(limit)(obj, (val, key, next) => {
          _iteratee(val, key, (err, result) => {
            if (err)
              return next(err);
            newObj[key] = result;
            next(err);
          });
        }, (err) => callback(err, newObj));
      }
      var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
      function mapValues(obj, iteratee, callback) {
        return mapValuesLimit$1(obj, Infinity, iteratee, callback);
      }
      function mapValuesSeries(obj, iteratee, callback) {
        return mapValuesLimit$1(obj, 1, iteratee, callback);
      }
      function memoize(fn, hasher = (v) => v) {
        var memo = /* @__PURE__ */ Object.create(null);
        var queues = /* @__PURE__ */ Object.create(null);
        var _fn = wrapAsync(fn);
        var memoized = initialParams((args, callback) => {
          var key = hasher(...args);
          if (key in memo) {
            setImmediate$1(() => callback(null, ...memo[key]));
          } else if (key in queues) {
            queues[key].push(callback);
          } else {
            queues[key] = [callback];
            _fn(...args, (err, ...resultArgs) => {
              if (!err) {
                memo[key] = resultArgs;
              }
              var q = queues[key];
              delete queues[key];
              for (var i = 0, l = q.length; i < l; i++) {
                q[i](err, ...resultArgs);
              }
            });
          }
        });
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
      }
      var _defer$1;
      if (hasNextTick) {
        _defer$1 = process.nextTick;
      } else if (hasSetImmediate) {
        _defer$1 = setImmediate;
      } else {
        _defer$1 = fallback;
      }
      var nextTick = wrap(_defer$1);
      var _parallel = awaitify((eachfn, tasks, callback) => {
        var results = isArrayLike(tasks) ? [] : {};
        eachfn(tasks, (task, key, taskCb) => {
          wrapAsync(task)((err, ...result) => {
            if (result.length < 2) {
              [result] = result;
            }
            results[key] = result;
            taskCb(err);
          });
        }, (err) => callback(err, results));
      }, 3);
      function parallel(tasks, callback) {
        return _parallel(eachOf$1, tasks, callback);
      }
      function parallelLimit(tasks, limit, callback) {
        return _parallel(eachOfLimit(limit), tasks, callback);
      }
      function queue$1(worker, concurrency) {
        var _worker = wrapAsync(worker);
        return queue((items, cb) => {
          _worker(items[0], cb);
        }, concurrency, 1);
      }
      class Heap {
        constructor() {
          this.heap = [];
          this.pushCount = Number.MIN_SAFE_INTEGER;
        }
        get length() {
          return this.heap.length;
        }
        empty() {
          this.heap = [];
          return this;
        }
        percUp(index2) {
          let p;
          while (index2 > 0 && smaller(this.heap[index2], this.heap[p = parent(index2)])) {
            let t = this.heap[index2];
            this.heap[index2] = this.heap[p];
            this.heap[p] = t;
            index2 = p;
          }
        }
        percDown(index2) {
          let l;
          while ((l = leftChi(index2)) < this.heap.length) {
            if (l + 1 < this.heap.length && smaller(this.heap[l + 1], this.heap[l])) {
              l = l + 1;
            }
            if (smaller(this.heap[index2], this.heap[l])) {
              break;
            }
            let t = this.heap[index2];
            this.heap[index2] = this.heap[l];
            this.heap[l] = t;
            index2 = l;
          }
        }
        push(node) {
          node.pushCount = ++this.pushCount;
          this.heap.push(node);
          this.percUp(this.heap.length - 1);
        }
        unshift(node) {
          return this.heap.push(node);
        }
        shift() {
          let [top] = this.heap;
          this.heap[0] = this.heap[this.heap.length - 1];
          this.heap.pop();
          this.percDown(0);
          return top;
        }
        toArray() {
          return [...this];
        }
        *[Symbol.iterator]() {
          for (let i = 0; i < this.heap.length; i++) {
            yield this.heap[i].data;
          }
        }
        remove(testFn) {
          let j = 0;
          for (let i = 0; i < this.heap.length; i++) {
            if (!testFn(this.heap[i])) {
              this.heap[j] = this.heap[i];
              j++;
            }
          }
          this.heap.splice(j);
          for (let i = parent(this.heap.length - 1); i >= 0; i--) {
            this.percDown(i);
          }
          return this;
        }
      }
      function leftChi(i) {
        return (i << 1) + 1;
      }
      function parent(i) {
        return (i + 1 >> 1) - 1;
      }
      function smaller(x, y) {
        if (x.priority !== y.priority) {
          return x.priority < y.priority;
        } else {
          return x.pushCount < y.pushCount;
        }
      }
      function priorityQueue(worker, concurrency) {
        var q = queue$1(worker, concurrency);
        var processingScheduled = false;
        q._tasks = new Heap();
        q.push = function(data, priority = 0, callback = () => {
        }) {
          if (typeof callback !== "function") {
            throw new Error("task callback must be a function");
          }
          q.started = true;
          if (!Array.isArray(data)) {
            data = [data];
          }
          if (data.length === 0 && q.idle()) {
            return setImmediate$1(() => q.drain());
          }
          for (var i = 0, l = data.length; i < l; i++) {
            var item = {
              data: data[i],
              priority,
              callback
            };
            q._tasks.push(item);
          }
          if (!processingScheduled) {
            processingScheduled = true;
            setImmediate$1(() => {
              processingScheduled = false;
              q.process();
            });
          }
        };
        delete q.unshift;
        return q;
      }
      function race(tasks, callback) {
        callback = once(callback);
        if (!Array.isArray(tasks))
          return callback(new TypeError("First argument to race must be an array of functions"));
        if (!tasks.length)
          return callback();
        for (var i = 0, l = tasks.length; i < l; i++) {
          wrapAsync(tasks[i])(callback);
        }
      }
      var race$1 = awaitify(race, 2);
      function reduceRight(array, memo, iteratee, callback) {
        var reversed = [...array].reverse();
        return reduce$1(reversed, memo, iteratee, callback);
      }
      function reflect(fn) {
        var _fn = wrapAsync(fn);
        return initialParams(function reflectOn(args, reflectCallback) {
          args.push((error, ...cbArgs) => {
            let retVal = {};
            if (error) {
              retVal.error = error;
            }
            if (cbArgs.length > 0) {
              var value = cbArgs;
              if (cbArgs.length <= 1) {
                [value] = cbArgs;
              }
              retVal.value = value;
            }
            reflectCallback(null, retVal);
          });
          return _fn.apply(this, args);
        });
      }
      function reflectAll(tasks) {
        var results;
        if (Array.isArray(tasks)) {
          results = tasks.map(reflect);
        } else {
          results = {};
          Object.keys(tasks).forEach((key) => {
            results[key] = reflect.call(this, tasks[key]);
          });
        }
        return results;
      }
      function reject(eachfn, arr, _iteratee, callback) {
        const iteratee = wrapAsync(_iteratee);
        return _filter(eachfn, arr, (value, cb) => {
          iteratee(value, (err, v) => {
            cb(err, !v);
          });
        }, callback);
      }
      function reject$1(coll, iteratee, callback) {
        return reject(eachOf$1, coll, iteratee, callback);
      }
      var reject$2 = awaitify(reject$1, 3);
      function rejectLimit(coll, limit, iteratee, callback) {
        return reject(eachOfLimit(limit), coll, iteratee, callback);
      }
      var rejectLimit$1 = awaitify(rejectLimit, 4);
      function rejectSeries(coll, iteratee, callback) {
        return reject(eachOfSeries$1, coll, iteratee, callback);
      }
      var rejectSeries$1 = awaitify(rejectSeries, 3);
      function constant$1(value) {
        return function() {
          return value;
        };
      }
      const DEFAULT_TIMES = 5;
      const DEFAULT_INTERVAL = 0;
      function retry(opts, task, callback) {
        var options = {
          times: DEFAULT_TIMES,
          intervalFunc: constant$1(DEFAULT_INTERVAL)
        };
        if (arguments.length < 3 && typeof opts === "function") {
          callback = task || promiseCallback();
          task = opts;
        } else {
          parseTimes(options, opts);
          callback = callback || promiseCallback();
        }
        if (typeof task !== "function") {
          throw new Error("Invalid arguments for async.retry");
        }
        var _task = wrapAsync(task);
        var attempt = 1;
        function retryAttempt() {
          _task((err, ...args) => {
            if (err === false)
              return;
            if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err))) {
              setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
            } else {
              callback(err, ...args);
            }
          });
        }
        retryAttempt();
        return callback[PROMISE_SYMBOL];
      }
      function parseTimes(acc, t) {
        if (typeof t === "object") {
          acc.times = +t.times || DEFAULT_TIMES;
          acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL);
          acc.errorFilter = t.errorFilter;
        } else if (typeof t === "number" || typeof t === "string") {
          acc.times = +t || DEFAULT_TIMES;
        } else {
          throw new Error("Invalid arguments for async.retry");
        }
      }
      function retryable(opts, task) {
        if (!task) {
          task = opts;
          opts = null;
        }
        let arity = opts && opts.arity || task.length;
        if (isAsync(task)) {
          arity += 1;
        }
        var _task = wrapAsync(task);
        return initialParams((args, callback) => {
          if (args.length < arity - 1 || callback == null) {
            args.push(callback);
            callback = promiseCallback();
          }
          function taskFn(cb) {
            _task(...args, cb);
          }
          if (opts)
            retry(opts, taskFn, callback);
          else
            retry(taskFn, callback);
          return callback[PROMISE_SYMBOL];
        });
      }
      function series(tasks, callback) {
        return _parallel(eachOfSeries$1, tasks, callback);
      }
      function some(coll, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOf$1, coll, iteratee, callback);
      }
      var some$1 = awaitify(some, 3);
      function someLimit(coll, limit, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOfLimit(limit), coll, iteratee, callback);
      }
      var someLimit$1 = awaitify(someLimit, 4);
      function someSeries(coll, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOfSeries$1, coll, iteratee, callback);
      }
      var someSeries$1 = awaitify(someSeries, 3);
      function sortBy(coll, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return map$1(coll, (x, iterCb) => {
          _iteratee(x, (err, criteria) => {
            if (err)
              return iterCb(err);
            iterCb(err, { value: x, criteria });
          });
        }, (err, results) => {
          if (err)
            return callback(err);
          callback(null, results.sort(comparator).map((v) => v.value));
        });
        function comparator(left, right) {
          var a = left.criteria, b = right.criteria;
          return a < b ? -1 : a > b ? 1 : 0;
        }
      }
      var sortBy$1 = awaitify(sortBy, 3);
      function timeout(asyncFn, milliseconds, info) {
        var fn = wrapAsync(asyncFn);
        return initialParams((args, callback) => {
          var timedOut = false;
          var timer;
          function timeoutCallback() {
            var name = asyncFn.name || "anonymous";
            var error = new Error('Callback function "' + name + '" timed out.');
            error.code = "ETIMEDOUT";
            if (info) {
              error.info = info;
            }
            timedOut = true;
            callback(error);
          }
          args.push((...cbArgs) => {
            if (!timedOut) {
              callback(...cbArgs);
              clearTimeout(timer);
            }
          });
          timer = setTimeout(timeoutCallback, milliseconds);
          fn(...args);
        });
      }
      function range(size) {
        var result = Array(size);
        while (size--) {
          result[size] = size;
        }
        return result;
      }
      function timesLimit(count, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(range(count), limit, _iteratee, callback);
      }
      function times(n, iteratee, callback) {
        return timesLimit(n, Infinity, iteratee, callback);
      }
      function timesSeries(n, iteratee, callback) {
        return timesLimit(n, 1, iteratee, callback);
      }
      function transform(coll, accumulator, iteratee, callback) {
        if (arguments.length <= 3 && typeof accumulator === "function") {
          callback = iteratee;
          iteratee = accumulator;
          accumulator = Array.isArray(coll) ? [] : {};
        }
        callback = once(callback || promiseCallback());
        var _iteratee = wrapAsync(iteratee);
        eachOf$1(coll, (v, k, cb) => {
          _iteratee(accumulator, v, k, cb);
        }, (err) => callback(err, accumulator));
        return callback[PROMISE_SYMBOL];
      }
      function tryEach(tasks, callback) {
        var error = null;
        var result;
        return eachSeries$1(tasks, (task, taskCb) => {
          wrapAsync(task)((err, ...args) => {
            if (err === false)
              return taskCb(err);
            if (args.length < 2) {
              [result] = args;
            } else {
              result = args;
            }
            error = err;
            taskCb(err ? null : {});
          });
        }, () => callback(error, result));
      }
      var tryEach$1 = awaitify(tryEach);
      function unmemoize(fn) {
        return (...args) => {
          return (fn.unmemoized || fn)(...args);
        };
      }
      function whilst(test, iteratee, callback) {
        callback = onlyOnce(callback);
        var _fn = wrapAsync(iteratee);
        var _test = wrapAsync(test);
        var results = [];
        function next(err, ...rest) {
          if (err)
            return callback(err);
          results = rest;
          if (err === false)
            return;
          _test(check);
        }
        function check(err, truth) {
          if (err)
            return callback(err);
          if (err === false)
            return;
          if (!truth)
            return callback(null, ...results);
          _fn(next);
        }
        return _test(check);
      }
      var whilst$1 = awaitify(whilst, 3);
      function until(test, iteratee, callback) {
        const _test = wrapAsync(test);
        return whilst$1((cb) => _test((err, truth) => cb(err, !truth)), iteratee, callback);
      }
      function waterfall(tasks, callback) {
        callback = once(callback);
        if (!Array.isArray(tasks))
          return callback(new Error("First argument to waterfall must be an array of functions"));
        if (!tasks.length)
          return callback();
        var taskIndex = 0;
        function nextTask(args) {
          var task = wrapAsync(tasks[taskIndex++]);
          task(...args, onlyOnce(next));
        }
        function next(err, ...args) {
          if (err === false)
            return;
          if (err || taskIndex === tasks.length) {
            return callback(err, ...args);
          }
          nextTask(args);
        }
        nextTask([]);
      }
      var waterfall$1 = awaitify(waterfall);
      var index = {
        apply,
        applyEach: applyEach$1,
        applyEachSeries,
        asyncify,
        auto,
        autoInject,
        cargo,
        cargoQueue: cargo$1,
        compose,
        concat: concat$1,
        concatLimit: concatLimit$1,
        concatSeries: concatSeries$1,
        constant,
        detect: detect$1,
        detectLimit: detectLimit$1,
        detectSeries: detectSeries$1,
        dir,
        doUntil,
        doWhilst: doWhilst$1,
        each,
        eachLimit: eachLimit$2,
        eachOf: eachOf$1,
        eachOfLimit: eachOfLimit$2,
        eachOfSeries: eachOfSeries$1,
        eachSeries: eachSeries$1,
        ensureAsync,
        every: every$1,
        everyLimit: everyLimit$1,
        everySeries: everySeries$1,
        filter: filter$1,
        filterLimit: filterLimit$1,
        filterSeries: filterSeries$1,
        forever: forever$1,
        groupBy,
        groupByLimit: groupByLimit$1,
        groupBySeries,
        log,
        map: map$1,
        mapLimit: mapLimit$1,
        mapSeries: mapSeries$1,
        mapValues,
        mapValuesLimit: mapValuesLimit$1,
        mapValuesSeries,
        memoize,
        nextTick,
        parallel,
        parallelLimit,
        priorityQueue,
        queue: queue$1,
        race: race$1,
        reduce: reduce$1,
        reduceRight,
        reflect,
        reflectAll,
        reject: reject$2,
        rejectLimit: rejectLimit$1,
        rejectSeries: rejectSeries$1,
        retry,
        retryable,
        seq,
        series,
        setImmediate: setImmediate$1,
        some: some$1,
        someLimit: someLimit$1,
        someSeries: someSeries$1,
        sortBy: sortBy$1,
        timeout,
        times,
        timesLimit,
        timesSeries,
        transform,
        tryEach: tryEach$1,
        unmemoize,
        until,
        waterfall: waterfall$1,
        whilst: whilst$1,
        all: every$1,
        allLimit: everyLimit$1,
        allSeries: everySeries$1,
        any: some$1,
        anyLimit: someLimit$1,
        anySeries: someSeries$1,
        find: detect$1,
        findLimit: detectLimit$1,
        findSeries: detectSeries$1,
        flatMap: concat$1,
        flatMapLimit: concatLimit$1,
        flatMapSeries: concatSeries$1,
        forEach: each,
        forEachSeries: eachSeries$1,
        forEachLimit: eachLimit$2,
        forEachOf: eachOf$1,
        forEachOfSeries: eachOfSeries$1,
        forEachOfLimit: eachOfLimit$2,
        inject: reduce$1,
        foldl: reduce$1,
        foldr: reduceRight,
        select: filter$1,
        selectLimit: filterLimit$1,
        selectSeries: filterSeries$1,
        wrapSync: asyncify,
        during: whilst$1,
        doDuring: doWhilst$1
      };
      exports2.default = index;
      exports2.apply = apply;
      exports2.applyEach = applyEach$1;
      exports2.applyEachSeries = applyEachSeries;
      exports2.asyncify = asyncify;
      exports2.auto = auto;
      exports2.autoInject = autoInject;
      exports2.cargo = cargo;
      exports2.cargoQueue = cargo$1;
      exports2.compose = compose;
      exports2.concat = concat$1;
      exports2.concatLimit = concatLimit$1;
      exports2.concatSeries = concatSeries$1;
      exports2.constant = constant;
      exports2.detect = detect$1;
      exports2.detectLimit = detectLimit$1;
      exports2.detectSeries = detectSeries$1;
      exports2.dir = dir;
      exports2.doUntil = doUntil;
      exports2.doWhilst = doWhilst$1;
      exports2.each = each;
      exports2.eachLimit = eachLimit$2;
      exports2.eachOf = eachOf$1;
      exports2.eachOfLimit = eachOfLimit$2;
      exports2.eachOfSeries = eachOfSeries$1;
      exports2.eachSeries = eachSeries$1;
      exports2.ensureAsync = ensureAsync;
      exports2.every = every$1;
      exports2.everyLimit = everyLimit$1;
      exports2.everySeries = everySeries$1;
      exports2.filter = filter$1;
      exports2.filterLimit = filterLimit$1;
      exports2.filterSeries = filterSeries$1;
      exports2.forever = forever$1;
      exports2.groupBy = groupBy;
      exports2.groupByLimit = groupByLimit$1;
      exports2.groupBySeries = groupBySeries;
      exports2.log = log;
      exports2.map = map$1;
      exports2.mapLimit = mapLimit$1;
      exports2.mapSeries = mapSeries$1;
      exports2.mapValues = mapValues;
      exports2.mapValuesLimit = mapValuesLimit$1;
      exports2.mapValuesSeries = mapValuesSeries;
      exports2.memoize = memoize;
      exports2.nextTick = nextTick;
      exports2.parallel = parallel;
      exports2.parallelLimit = parallelLimit;
      exports2.priorityQueue = priorityQueue;
      exports2.queue = queue$1;
      exports2.race = race$1;
      exports2.reduce = reduce$1;
      exports2.reduceRight = reduceRight;
      exports2.reflect = reflect;
      exports2.reflectAll = reflectAll;
      exports2.reject = reject$2;
      exports2.rejectLimit = rejectLimit$1;
      exports2.rejectSeries = rejectSeries$1;
      exports2.retry = retry;
      exports2.retryable = retryable;
      exports2.seq = seq;
      exports2.series = series;
      exports2.setImmediate = setImmediate$1;
      exports2.some = some$1;
      exports2.someLimit = someLimit$1;
      exports2.someSeries = someSeries$1;
      exports2.sortBy = sortBy$1;
      exports2.timeout = timeout;
      exports2.times = times;
      exports2.timesLimit = timesLimit;
      exports2.timesSeries = timesSeries;
      exports2.transform = transform;
      exports2.tryEach = tryEach$1;
      exports2.unmemoize = unmemoize;
      exports2.until = until;
      exports2.waterfall = waterfall$1;
      exports2.whilst = whilst$1;
      exports2.all = every$1;
      exports2.allLimit = everyLimit$1;
      exports2.allSeries = everySeries$1;
      exports2.any = some$1;
      exports2.anyLimit = someLimit$1;
      exports2.anySeries = someSeries$1;
      exports2.find = detect$1;
      exports2.findLimit = detectLimit$1;
      exports2.findSeries = detectSeries$1;
      exports2.flatMap = concat$1;
      exports2.flatMapLimit = concatLimit$1;
      exports2.flatMapSeries = concatSeries$1;
      exports2.forEach = each;
      exports2.forEachSeries = eachSeries$1;
      exports2.forEachLimit = eachLimit$2;
      exports2.forEachOf = eachOf$1;
      exports2.forEachOfSeries = eachOfSeries$1;
      exports2.forEachOfLimit = eachOfLimit$2;
      exports2.inject = reduce$1;
      exports2.foldl = reduce$1;
      exports2.foldr = reduceRight;
      exports2.select = filter$1;
      exports2.selectLimit = filterLimit$1;
      exports2.selectSeries = filterSeries$1;
      exports2.wrapSync = asyncify;
      exports2.during = whilst$1;
      exports2.doDuring = doWhilst$1;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/rollbar/node_modules/lru-cache/lib/lru-cache.js
var require_lru_cache = __commonJS({
  "node_modules/rollbar/node_modules/lru-cache/lib/lru-cache.js"(exports, module2) {
    (function() {
      if (typeof module2 === "object" && module2.exports) {
        module2.exports = LRUCache;
      } else {
        this.LRUCache = LRUCache;
      }
      function hOP(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
      }
      function naiveLength() {
        return 1;
      }
      function LRUCache(options) {
        if (!(this instanceof LRUCache)) {
          return new LRUCache(options);
        }
        var max;
        if (typeof options === "number") {
          max = options;
          options = { max };
        }
        if (!options)
          options = {};
        max = options.max;
        var lengthCalculator = options.length || naiveLength;
        if (typeof lengthCalculator !== "function") {
          lengthCalculator = naiveLength;
        }
        if (!max || !(typeof max === "number") || max <= 0) {
          max = Infinity;
        }
        var allowStale = options.stale || false;
        var maxAge = options.maxAge || null;
        var dispose = options.dispose;
        var cache = /* @__PURE__ */ Object.create(null), lruList = /* @__PURE__ */ Object.create(null), mru = 0, lru = 0, length = 0, itemCount = 0;
        Object.defineProperty(
          this,
          "max",
          {
            set: function(mL) {
              if (!mL || !(typeof mL === "number") || mL <= 0)
                mL = Infinity;
              max = mL;
              if (length > max)
                trim();
            },
            get: function() {
              return max;
            },
            enumerable: true
          }
        );
        Object.defineProperty(
          this,
          "lengthCalculator",
          {
            set: function(lC) {
              if (typeof lC !== "function") {
                lengthCalculator = naiveLength;
                length = itemCount;
                for (var key in cache) {
                  cache[key].length = 1;
                }
              } else {
                lengthCalculator = lC;
                length = 0;
                for (var key in cache) {
                  cache[key].length = lengthCalculator(cache[key].value);
                  length += cache[key].length;
                }
              }
              if (length > max)
                trim();
            },
            get: function() {
              return lengthCalculator;
            },
            enumerable: true
          }
        );
        Object.defineProperty(
          this,
          "length",
          {
            get: function() {
              return length;
            },
            enumerable: true
          }
        );
        Object.defineProperty(
          this,
          "itemCount",
          {
            get: function() {
              return itemCount;
            },
            enumerable: true
          }
        );
        this.forEach = function(fn, thisp) {
          thisp = thisp || this;
          var i = 0;
          for (var k = mru - 1; k >= 0 && i < itemCount; k--)
            if (lruList[k]) {
              i++;
              var hit = lruList[k];
              fn.call(thisp, hit.value, hit.key, this);
            }
        };
        this.keys = function() {
          var keys = new Array(itemCount);
          var i = 0;
          for (var k = mru - 1; k >= 0 && i < itemCount; k--)
            if (lruList[k]) {
              var hit = lruList[k];
              keys[i++] = hit.key;
            }
          return keys;
        };
        this.values = function() {
          var values = new Array(itemCount);
          var i = 0;
          for (var k = mru - 1; k >= 0 && i < itemCount; k--)
            if (lruList[k]) {
              var hit = lruList[k];
              values[i++] = hit.value;
            }
          return values;
        };
        this.reset = function() {
          if (dispose) {
            for (var k in cache) {
              dispose(k, cache[k].value);
            }
          }
          cache = {};
          lruList = {};
          lru = 0;
          mru = 0;
          length = 0;
          itemCount = 0;
        };
        this.dump = function() {
          return cache;
        };
        this.dumpLru = function() {
          return lruList;
        };
        this.set = function(key, value) {
          if (hOP(cache, key)) {
            if (dispose)
              dispose(key, cache[key].value);
            if (maxAge)
              cache[key].now = Date.now();
            cache[key].value = value;
            this.get(key);
            return true;
          }
          var len = lengthCalculator(value);
          var age = maxAge ? Date.now() : 0;
          var hit = new Entry(key, value, mru++, len, age);
          if (hit.length > max) {
            if (dispose)
              dispose(key, value);
            return false;
          }
          length += hit.length;
          lruList[hit.lu] = cache[key] = hit;
          itemCount++;
          if (length > max)
            trim();
          return true;
        };
        this.has = function(key) {
          if (!hOP(cache, key))
            return false;
          var hit = cache[key];
          if (maxAge && Date.now() - hit.now > maxAge) {
            return false;
          }
          return true;
        };
        this.get = function(key) {
          if (!hOP(cache, key))
            return;
          var hit = cache[key];
          if (maxAge && Date.now() - hit.now > maxAge) {
            this.del(key);
            return allowStale ? hit.value : void 0;
          }
          shiftLU(hit);
          hit.lu = mru++;
          lruList[hit.lu] = hit;
          return hit.value;
        };
        this.del = function(key) {
          del(cache[key]);
        };
        function trim() {
          while (lru < mru && length > max)
            del(lruList[lru]);
        }
        function shiftLU(hit) {
          delete lruList[hit.lu];
          while (lru < mru && !lruList[lru])
            lru++;
        }
        function del(hit) {
          if (hit) {
            if (dispose)
              dispose(hit.key, hit.value);
            length -= hit.length;
            itemCount--;
            delete cache[hit.key];
            shiftLU(hit);
          }
        }
      }
      function Entry(key, value, mru, len, age) {
        this.key = key;
        this.value = value;
        this.lu = mru;
        this.length = len;
        this.now = age;
      }
    })();
  }
});

// node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/source-map/lib/base64.js"(exports) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/source-map/lib/base64-vlq.js"(exports) {
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// node_modules/source-map/lib/util.js
var require_util = __commonJS({
  "node_modules/source-map/lib/util.js"(exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path3 = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path3 = url.path;
      }
      var isAbsolute = exports.isAbsolute(path3);
      var parts = path3.split(/\/+/);
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path3 = parts.join("/");
      if (path3 === "") {
        path3 = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path3;
        return urlGenerate(url);
      }
      return path3;
    }
    exports.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports.join = join;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || !!aPath.match(urlRegexp);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = mappingA.source - mappingB.source;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return mappingA.name - mappingB.name;
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = mappingA.source - mappingB.source;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return mappingA.name - mappingB.name;
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  }
});

// node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/source-map/lib/array-set.js"(exports) {
    var util = require_util();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports.ArraySet = ArraySet;
  }
});

// node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/source-map/lib/mapping-list.js"(exports) {
    var util = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports.MappingList = MappingList;
  }
});

// node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/source-map/lib/source-map-generator.js"(exports) {
    var base64VLQ = require_base64_vlq();
    var util = require_util();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error(
          "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
        );
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports.SourceMapGenerator = SourceMapGenerator;
  }
});

// node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS({
  "node_modules/source-map/lib/binary-search.js"(exports) {
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports.GREATEST_LOWER_BOUND
      );
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  }
});

// node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "node_modules/source-map/lib/quick-sort.js"(exports) {
    function swap(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y];
      ary[y] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator, p, r) {
      if (p < r) {
        var pivotIndex = randomIntInRange(p, r);
        var i = p - 1;
        swap(ary, pivotIndex, r);
        var pivot = ary[r];
        for (var j = p; j < r; j++) {
          if (comparator(ary[j], pivot) <= 0) {
            i += 1;
            swap(ary, i, j);
          }
        }
        swap(ary, i + 1, j);
        var q = i + 1;
        doQuickSort(ary, comparator, p, q - 1);
        doQuickSort(ary, comparator, q + 1, r);
      }
    }
    exports.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
  }
});

// node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "node_modules/source-map/lib/source-map-consumer.js"(exports) {
    var util = require_util();
    var binarySearch = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap) : new BasicSourceMapConsumer(sourceMap);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        if (source != null && sourceRoot != null) {
          source = util.join(sourceRoot, source);
        }
        return {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, "line");
      var needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }
      if (!this._sources.has(needle.source)) {
        return [];
      }
      needle.source = this._sources.indexOf(needle.source);
      var mappings = [];
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        binarySearch.LEAST_UPPER_BOUND
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        }
      }
      return mappings;
    };
    exports.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
      }
      var version = util.getArg(sourceMap, "version");
      var sources = util.getArg(sourceMap, "sources");
      var names = util.getArg(sourceMap, "names", []);
      var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
      var mappings = util.getArg(sourceMap, "mappings");
      var file = util.getArg(sourceMap, "file", null);
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      sources = sources.map(String).map(util.normalize).map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(
        smc._sources.toArray(),
        smc.sourceRoot
      );
      smc.file = aSourceMap._file;
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._sources.toArray().map(function(s) {
          return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
        }, this);
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      while (index < length) {
        if (aStr.charAt(index) === ";") {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index) === ",") {
          index++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);
          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            originalMappings.push(mapping);
          }
        }
      }
      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            if (this.sourceRoot != null) {
              source = util.join(this.sourceRoot, source);
            }
          }
          var name = util.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      if (this.sourceRoot != null) {
        aSource = util.relative(this.sourceRoot, aSource);
      }
      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }
      var url;
      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, "source");
      if (this.sourceRoot != null) {
        source = util.relative(this.sourceRoot, source);
      }
      if (!this._sources.has(source)) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      source = this._sources.indexOf(source);
      var needle = {
        source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
      }
      var version = util.getArg(sourceMap, "version");
      var sections = util.getArg(sourceMap, "sections");
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s) {
        if (s.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset = util.getArg(s, "offset");
        var offsetLine = util.getArg(offset, "line");
        var offsetColumn = util.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;
        return {
          generatedOffset: {
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s, "map"))
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
          for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch.search(
        needle,
        this._sections,
        function(needle2, section2) {
          var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }
          return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
        }
      );
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (section.consumer.sources.indexOf(util.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];
          var source = section.consumer._sources.at(mapping.source);
          if (section.consumer.sourceRoot !== null) {
            source = util.join(section.consumer.sourceRoot, source);
          }
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };
    exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS({
  "node_modules/source-map/lib/source-node.js"(exports) {
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var util = require_util();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null)
        this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex];
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex];
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node.add(code);
        } else {
          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(
            mapping.originalLine,
            mapping.originalColumn,
            source,
            code,
            mapping.name
          ));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map };
    };
    exports.SourceNode = SourceNode;
  }
});

// node_modules/source-map/source-map.js
var require_source_map = __commonJS({
  "node_modules/source-map/source-map.js"(exports) {
    exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports.SourceNode = require_source_node().SourceNode;
  }
});

// node_modules/rollbar/src/server/sourceMap/stackTrace.js
var require_stackTrace = __commonJS({
  "node_modules/rollbar/src/server/sourceMap/stackTrace.js"(exports) {
    var SourceMapConsumer = require_source_map().SourceMapConsumer;
    var path3 = require("path");
    var fs2 = require("fs");
    var fileContentsCache = {};
    var sourceMapCache = {};
    var sourcesContentCache = {};
    var reSourceMap = /^data:application\/json[^,]+base64,/;
    function retrieveFile(path4) {
      path4 = path4.trim();
      if (/^file:/.test(path4)) {
        path4 = path4.replace(/file:\/\/\/(\w:)?/, function(_protocol, drive) {
          return drive ? "" : "/";
        });
      }
      if (path4 in fileContentsCache) {
        return fileContentsCache[path4];
      }
      var contents = "";
      try {
        if (fs2.existsSync(path4)) {
          contents = fs2.readFileSync(path4, "utf8");
        }
      } catch (er) {
      }
      return fileContentsCache[path4] = contents;
    }
    function supportRelativeURL(file, url) {
      if (!file)
        return url;
      var dir = path3.dirname(file);
      var match = /^\w+:\/\/[^\/]*/.exec(dir);
      var protocol = match ? match[0] : "";
      var startPath = dir.slice(protocol.length);
      if (protocol && /^\/\w\:/.test(startPath)) {
        protocol += "/";
        return protocol + path3.resolve(dir.slice(protocol.length), url).replace(/\\/g, "/");
      }
      return protocol + path3.resolve(dir.slice(protocol.length), url);
    }
    function retrieveSourceMapURL(source) {
      var fileData;
      fileData = retrieveFile(source);
      var re = /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/)[ \t]*$)/mg;
      var lastMatch, match;
      while (match = re.exec(fileData))
        lastMatch = match;
      if (!lastMatch)
        return null;
      return lastMatch[1];
    }
    function retrieveSourceMap(source) {
      var sourceMappingURL = retrieveSourceMapURL(source);
      if (!sourceMappingURL)
        return null;
      var sourceMapData;
      if (reSourceMap.test(sourceMappingURL)) {
        var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(",") + 1);
        sourceMapData = Buffer.from(rawData, "base64").toString();
        sourceMappingURL = source;
      } else {
        sourceMappingURL = supportRelativeURL(source, sourceMappingURL);
        sourceMapData = retrieveFile(sourceMappingURL);
      }
      if (!sourceMapData) {
        return null;
      }
      return {
        url: sourceMappingURL,
        map: sourceMapData
      };
    }
    function cacheSourceContent(sourceMap, originalSource, newSource) {
      if (sourcesContentCache[newSource]) {
        return;
      }
      sourcesContentCache[newSource] = sourceMap.map.sourceContentFor(originalSource, true);
    }
    exports.mapSourcePosition = function mapSourcePosition(position, diagnostic) {
      var sourceMap = sourceMapCache[position.source];
      if (!sourceMap) {
        var urlAndMap = retrieveSourceMap(position.source);
        if (urlAndMap) {
          sourceMap = sourceMapCache[position.source] = {
            url: urlAndMap.url,
            map: new SourceMapConsumer(urlAndMap.map)
          };
          diagnostic.node_source_maps.source_mapping_urls[position.source] = urlAndMap.url;
          if (sourceMap.map.sourcesContent) {
            sourceMap.map.sources.forEach(function(source, i) {
              var contents = sourceMap.map.sourcesContent[i];
              if (contents) {
                var url = supportRelativeURL(sourceMap.url, source);
                fileContentsCache[url] = contents;
              }
            });
          }
        } else {
          sourceMap = sourceMapCache[position.source] = {
            url: null,
            map: null
          };
          diagnostic.node_source_maps.source_mapping_urls[position.source] = "not found";
        }
      }
      if (sourceMap && sourceMap.map && typeof sourceMap.map.originalPositionFor === "function") {
        var originalPosition = sourceMap.map.originalPositionFor(position);
        if (originalPosition.source !== null) {
          var originalSource = originalPosition.source;
          originalPosition.source = supportRelativeURL(
            sourceMap.url,
            originalPosition.source
          );
          cacheSourceContent(sourceMap, originalSource, originalPosition.source);
          return originalPosition;
        }
      }
      return position;
    };
    exports.sourceContent = function sourceContent(source) {
      return sourcesContentCache[source];
    };
  }
});

// node_modules/rollbar/src/server/parser.js
var require_parser = __commonJS({
  "node_modules/rollbar/src/server/parser.js"(exports) {
    "use strict";
    var logger = require_logger();
    var async = require_async2();
    var fs2 = require("fs");
    var lru = require_lru_cache();
    var util = require("util");
    var stackTrace = require_stackTrace();
    var linesOfContext = 3;
    var tracePattern = /^\s*at (?:([^(]+(?: \[\w\s+\])?(?:.*\)*)) )?\(?(.+?)(?::(\d+):(\d+)(?:, <js>:(\d+):(\d+))?)?\)?$/;
    var jadeTracePattern = /^\s*at .+ \(.+ (at[^)]+\))\)$/;
    var jadeFramePattern = /^\s*(>?) [0-9]+\|(\s*.+)$/m;
    var cache = new lru({ max: 100 });
    var pendingReads = {};
    exports.cache = cache;
    exports.pendingReads = pendingReads;
    function getMultipleErrors(errors) {
      var errArray, key;
      if (errors === null || errors === void 0) {
        return null;
      }
      if (typeof errors !== "object") {
        return null;
      }
      if (util.isArray(errors)) {
        return errors;
      }
      errArray = [];
      for (key in errors) {
        if (Object.prototype.hasOwnProperty.call(errors, key)) {
          errArray.push(errors[key]);
        }
      }
      return errArray;
    }
    function parseJadeDebugFrame(body) {
      var lines, lineNumSep, filename, lineno, numLines, msg, i, contextLine, preContext, postContext, line, jadeMatch;
      lines = body.split("\n");
      lineNumSep = lines[0].indexOf(":");
      filename = lines[0].slice(0, lineNumSep);
      lineno = parseInt(lines[0].slice(lineNumSep + 1), 10);
      numLines = lines.length;
      msg = lines[numLines - 1];
      lines = lines.slice(1, numLines - 1);
      preContext = [];
      postContext = [];
      for (i = 0; i < numLines - 2; ++i) {
        line = lines[i];
        jadeMatch = line.match(jadeFramePattern);
        if (jadeMatch) {
          if (jadeMatch[1] === ">") {
            contextLine = jadeMatch[2];
          } else {
            if (!contextLine) {
              if (jadeMatch[2]) {
                preContext.push(jadeMatch[2]);
              }
            } else {
              if (jadeMatch[2]) {
                postContext.push(jadeMatch[2]);
              }
            }
          }
        }
      }
      preContext = preContext.slice(0, Math.min(preContext.length, linesOfContext));
      postContext = postContext.slice(0, Math.min(postContext.length, linesOfContext));
      return {
        frame: {
          method: "<jade>",
          filename,
          lineno,
          code: contextLine,
          context: {
            pre: preContext,
            post: postContext
          }
        },
        message: msg
      };
    }
    function extractContextLines(frame, fileLines) {
      frame.code = fileLines[frame.lineno - 1];
      frame.context = {
        pre: fileLines.slice(Math.max(0, frame.lineno - (linesOfContext + 1)), frame.lineno - 1),
        post: fileLines.slice(frame.lineno, frame.lineno + linesOfContext)
      };
    }
    function mapPosition(position, diagnostic) {
      return stackTrace.mapSourcePosition(
        {
          source: position.source,
          line: position.line,
          column: position.column
        },
        diagnostic
      );
    }
    function parseFrameLine(line, callback) {
      var matched, curLine, data, frame, position;
      curLine = line;
      matched = curLine.match(jadeTracePattern);
      if (matched) {
        curLine = matched[1];
      }
      matched = curLine.match(tracePattern);
      if (!matched) {
        return callback(null, null);
      }
      data = matched.slice(1);
      var runtimePosition = {
        source: data[1],
        line: Math.floor(data[2]),
        column: Math.floor(data[3]) - 1
      };
      if (this.useSourceMaps) {
        position = mapPosition(runtimePosition, this.diagnostic);
      } else {
        position = runtimePosition;
      }
      frame = {
        method: data[0] || "<unknown>",
        filename: position.source,
        lineno: position.line,
        colno: position.column,
        runtimePosition
      };
      if (data[4]) {
        frame.compiled_lineno = Math.floor(data[4]);
      }
      if (data[5]) {
        frame.compiled_colno = Math.floor(data[5]);
      }
      callback(null, frame);
    }
    function shouldReadFrameFile(frameFilename, callback) {
      var isValidFilename, isCached, isPending;
      isValidFilename = frameFilename[0] === "/" || frameFilename[0] === ".";
      isCached = !!cache.get(frameFilename);
      isPending = !!pendingReads[frameFilename];
      callback(null, isValidFilename && !isCached && !isPending);
    }
    function readFileLines(filename, callback) {
      try {
        fs2.readFile(filename, function(err, fileData) {
          var fileLines;
          if (err) {
            return callback(err);
          }
          fileLines = fileData.toString("utf8").split("\n");
          return callback(null, fileLines);
        });
      } catch (e) {
        logger.log(e);
      }
    }
    function checkFileExists(filename, callback) {
      if (stackTrace.sourceContent(filename)) {
        return callback(null, true);
      }
      fs2.stat(filename, function(err) {
        callback(null, !err);
      });
    }
    function gatherContexts(frames, callback) {
      var frameFilenames = [];
      frames.forEach(function(frame) {
        if (frameFilenames.indexOf(frame.filename) === -1) {
          frameFilenames.push(frame.filename);
        }
      });
      async.filter(frameFilenames, shouldReadFrameFile, function(err, results) {
        if (err)
          return callback(err);
        var tempFileCache;
        tempFileCache = {};
        function cacheLines(filename, lines) {
          tempFileCache[filename] = lines;
          cache.set(filename, lines);
        }
        function gatherFileData(filename, callback2) {
          var sourceContent = stackTrace.sourceContent(filename);
          if (sourceContent) {
            try {
              var lines = sourceContent.split("\n");
              cacheLines(filename, lines);
              return callback2(null);
            } catch (err2) {
              return callback2(err2);
            }
          }
          readFileLines(filename, function(err2, lines2) {
            if (err2) {
              return callback2(err2);
            }
            cacheLines(filename, lines2);
            return callback2(null);
          });
        }
        function gatherContextLines(frame, callback2) {
          var lines = tempFileCache[frame.filename] || cache.get(frame.filename);
          if (lines) {
            extractContextLines(frame, lines);
          }
          callback2(null);
        }
        async.filter(results, checkFileExists, function(err2, filenames) {
          if (err2)
            return callback(err2);
          async.each(filenames, gatherFileData, function(err3) {
            if (err3) {
              return callback(err3);
            }
            async.eachSeries(frames, gatherContextLines, function(err4) {
              if (err4) {
                return callback(err4);
              }
              callback(null, frames);
            });
          });
        });
      });
    }
    exports.parseException = function(exc, options, item, callback) {
      var multipleErrs = getMultipleErrors(exc.errors);
      return exports.parseStack(exc.stack, options, item, function(err, stack) {
        var message, clss, ret, firstErr, jadeMatch, jadeData;
        if (err) {
          logger.error("could not parse exception, err: " + err);
          return callback(err);
        }
        message = String(exc.message || "<no message>");
        clss = String(exc.name || "<unknown>");
        ret = {
          class: clss,
          message,
          frames: stack
        };
        if (multipleErrs && multipleErrs.length) {
          firstErr = multipleErrs[0];
          ret = {
            class: clss,
            message: String(firstErr.message || "<no message>"),
            frames: stack
          };
        }
        jadeMatch = message.match(jadeFramePattern);
        if (jadeMatch) {
          jadeData = parseJadeDebugFrame(message);
          ret.message = jadeData.message;
          ret.frames.push(jadeData.frame);
        }
        if (item.localsMap) {
          item.notifier.locals.mergeLocals(item.localsMap, stack, exc.stack, function(err2) {
            if (err2) {
              logger.error("could not parse locals, err: " + err2);
              item.diagnostic["error parsing locals"] = err2;
            }
            return callback(null, ret);
          });
        } else {
          return callback(null, ret);
        }
      });
    };
    exports.parseStack = function(stack, options, item, callback) {
      var lines, _stack = stack;
      while (typeof _stack === "object") {
        _stack = _stack && _stack.stack;
      }
      lines = (_stack || "").split("\n").slice(1);
      if (options.nodeSourceMaps) {
        item.diagnostic.node_source_maps = {};
        item.diagnostic.node_source_maps.source_mapping_urls = {};
      }
      async.map(lines, parseFrameLine.bind({ useSourceMaps: options.nodeSourceMaps, diagnostic: item.diagnostic }), function(err, frames) {
        if (err) {
          return callback(err);
        }
        frames.reverse();
        async.filter(frames, function(frame, callback2) {
          callback2(null, !!frame);
        }, function(err2, results) {
          if (err2)
            return callback(err2);
          gatherContexts(results, callback);
        });
      });
    };
  }
});

// node_modules/is_js/is.js
var require_is = __commonJS({
  "node_modules/is_js/is.js"(exports, module2) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define(function() {
          return root.is = factory();
        });
      } else if (typeof exports === "object") {
        module2.exports = factory();
      } else {
        root.is = factory();
      }
    })(exports, function() {
      var is = {};
      is.VERSION = "0.8.0";
      is.not = {};
      is.all = {};
      is.any = {};
      var toString = Object.prototype.toString;
      var slice = Array.prototype.slice;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function not(func) {
        return function() {
          return !func.apply(null, slice.call(arguments));
        };
      }
      function all(func) {
        return function() {
          var params = getParams(arguments);
          var length = params.length;
          for (var i = 0; i < length; i++) {
            if (!func.call(null, params[i])) {
              return false;
            }
          }
          return true;
        };
      }
      function any(func) {
        return function() {
          var params = getParams(arguments);
          var length = params.length;
          for (var i = 0; i < length; i++) {
            if (func.call(null, params[i])) {
              return true;
            }
          }
          return false;
        };
      }
      var comparator = {
        "<": function(a, b) {
          return a < b;
        },
        "<=": function(a, b) {
          return a <= b;
        },
        ">": function(a, b) {
          return a > b;
        },
        ">=": function(a, b) {
          return a >= b;
        }
      };
      function compareVersion(version, range) {
        var string = range + "";
        var n = +(string.match(/\d+/) || NaN);
        var op = string.match(/^[<>]=?|/)[0];
        return comparator[op] ? comparator[op](version, n) : version == n || n !== n;
      }
      function getParams(args) {
        var params = slice.call(args);
        var length = params.length;
        if (length === 1 && is.array(params[0])) {
          params = params[0];
        }
        return params;
      }
      is.arguments = function(value) {
        return toString.call(value) === "[object Arguments]" || value != null && typeof value === "object" && "callee" in value;
      };
      is.array = Array.isArray || function(value) {
        return toString.call(value) === "[object Array]";
      };
      is.boolean = function(value) {
        return value === true || value === false || toString.call(value) === "[object Boolean]";
      };
      is.char = function(value) {
        return is.string(value) && value.length === 1;
      };
      is.date = function(value) {
        return toString.call(value) === "[object Date]";
      };
      is.domNode = function(object) {
        return is.object(object) && object.nodeType > 0;
      };
      is.error = function(value) {
        return toString.call(value) === "[object Error]";
      };
      is["function"] = function(value) {
        return toString.call(value) === "[object Function]" || typeof value === "function";
      };
      is.json = function(value) {
        return toString.call(value) === "[object Object]";
      };
      is.nan = function(value) {
        return value !== value;
      };
      is["null"] = function(value) {
        return value === null;
      };
      is.number = function(value) {
        return is.not.nan(value) && toString.call(value) === "[object Number]";
      };
      is.object = function(value) {
        return Object(value) === value;
      };
      is.regexp = function(value) {
        return toString.call(value) === "[object RegExp]";
      };
      is.sameType = function(value, other) {
        var tag = toString.call(value);
        if (tag !== toString.call(other)) {
          return false;
        }
        if (tag === "[object Number]") {
          return !is.any.nan(value, other) || is.all.nan(value, other);
        }
        return true;
      };
      is.sameType.api = ["not"];
      is.string = function(value) {
        return toString.call(value) === "[object String]";
      };
      is.undefined = function(value) {
        return value === void 0;
      };
      is.windowObject = function(value) {
        return value != null && typeof value === "object" && "setInterval" in value;
      };
      is.empty = function(value) {
        if (is.object(value)) {
          var length = Object.getOwnPropertyNames(value).length;
          if (length === 0 || length === 1 && is.array(value) || length === 2 && is.arguments(value)) {
            return true;
          }
          return false;
        }
        return value === "";
      };
      is.existy = function(value) {
        return value != null;
      };
      is.falsy = function(value) {
        return !value;
      };
      is.truthy = not(is.falsy);
      is.above = function(n, min) {
        return is.all.number(n, min) && n > min;
      };
      is.above.api = ["not"];
      is.decimal = function(n) {
        return is.number(n) && n % 1 !== 0;
      };
      is.equal = function(value, other) {
        if (is.all.number(value, other)) {
          return value === other && 1 / value === 1 / other;
        }
        if (is.all.string(value, other) || is.all.regexp(value, other)) {
          return "" + value === "" + other;
        }
        if (is.all.boolean(value, other)) {
          return value === other;
        }
        return false;
      };
      is.equal.api = ["not"];
      is.even = function(n) {
        return is.number(n) && n % 2 === 0;
      };
      is.finite = isFinite || function(n) {
        return is.not.infinite(n) && is.not.nan(n);
      };
      is.infinite = function(n) {
        return n === Infinity || n === -Infinity;
      };
      is.integer = function(n) {
        return is.number(n) && n % 1 === 0;
      };
      is.negative = function(n) {
        return is.number(n) && n < 0;
      };
      is.odd = function(n) {
        return is.number(n) && n % 2 === 1;
      };
      is.positive = function(n) {
        return is.number(n) && n > 0;
      };
      is.under = function(n, max) {
        return is.all.number(n, max) && n < max;
      };
      is.under.api = ["not"];
      is.within = function(n, min, max) {
        return is.all.number(n, min, max) && n > min && n < max;
      };
      is.within.api = ["not"];
      var regexes = {
        affirmative: /^(?:1|t(?:rue)?|y(?:es)?|ok(?:ay)?)$/,
        alphaNumeric: /^[A-Za-z0-9]+$/,
        caPostalCode: /^(?!.*[DFIOQU])[A-VXY][0-9][A-Z]\s?[0-9][A-Z][0-9]$/,
        creditCard: /^(?:(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11}))$/,
        dateString: /^(1[0-2]|0?[1-9])([\/-])(3[01]|[12][0-9]|0?[1-9])(?:\2)(?:[0-9]{2})?[0-9]{2}$/,
        email: /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i,
        eppPhone: /^\+[0-9]{1,3}\.[0-9]{4,14}(?:x.+)?$/,
        hexadecimal: /^(?:0x)?[0-9a-fA-F]+$/,
        hexColor: /^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/,
        ipv4: /^(?:(?:\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\.){3}(?:\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])$/,
        ipv6: /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i,
        nanpPhone: /^\(?([0-9]{3})\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$/,
        socialSecurityNumber: /^(?!000|666)[0-8][0-9]{2}-?(?!00)[0-9]{2}-?(?!0000)[0-9]{4}$/,
        timeString: /^(2[0-3]|[01]?[0-9]):([0-5]?[0-9]):([0-5]?[0-9])$/,
        ukPostCode: /^[A-Z]{1,2}[0-9RCHNQ][0-9A-Z]?\s?[0-9][ABD-HJLNP-UW-Z]{2}$|^[A-Z]{2}-?[0-9]{4}$/,
        url: /^(?:(?:https?|ftp):\/\/)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:\/\S*)?$/i,
        usZipCode: /^[0-9]{5}(?:-[0-9]{4})?$/
      };
      function regexpCheck(regexp2, regexes2) {
        is[regexp2] = function(value) {
          return regexes2[regexp2].test(value);
        };
      }
      for (var regexp in regexes) {
        if (regexes.hasOwnProperty(regexp)) {
          regexpCheck(regexp, regexes);
        }
      }
      is.ip = function(value) {
        return is.ipv4(value) || is.ipv6(value);
      };
      is.capitalized = function(string) {
        if (is.not.string(string)) {
          return false;
        }
        var words = string.split(" ");
        for (var i = 0; i < words.length; i++) {
          var word = words[i];
          if (word.length) {
            var chr = word.charAt(0);
            if (chr !== chr.toUpperCase()) {
              return false;
            }
          }
        }
        return true;
      };
      is.endWith = function(string, target) {
        if (is.not.string(string)) {
          return false;
        }
        target += "";
        var position = string.length - target.length;
        return position >= 0 && string.indexOf(target, position) === position;
      };
      is.endWith.api = ["not"];
      is.include = function(string, target) {
        return string.indexOf(target) > -1;
      };
      is.include.api = ["not"];
      is.lowerCase = function(string) {
        return is.string(string) && string === string.toLowerCase();
      };
      is.palindrome = function(string) {
        if (is.not.string(string)) {
          return false;
        }
        string = string.replace(/[^a-zA-Z0-9]+/g, "").toLowerCase();
        var length = string.length - 1;
        for (var i = 0, half = Math.floor(length / 2); i <= half; i++) {
          if (string.charAt(i) !== string.charAt(length - i)) {
            return false;
          }
        }
        return true;
      };
      is.space = function(value) {
        if (is.not.char(value)) {
          return false;
        }
        var charCode = value.charCodeAt(0);
        return charCode > 8 && charCode < 14 || charCode === 32;
      };
      is.startWith = function(string, target) {
        return is.string(string) && string.indexOf(target) === 0;
      };
      is.startWith.api = ["not"];
      is.upperCase = function(string) {
        return is.string(string) && string === string.toUpperCase();
      };
      var days = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
      var months = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"];
      is.day = function(date, day) {
        return is.date(date) && day.toLowerCase() === days[date.getDay()];
      };
      is.day.api = ["not"];
      is.dayLightSavingTime = function(date) {
        var january = new Date(date.getFullYear(), 0, 1);
        var july = new Date(date.getFullYear(), 6, 1);
        var stdTimezoneOffset = Math.max(january.getTimezoneOffset(), july.getTimezoneOffset());
        return date.getTimezoneOffset() < stdTimezoneOffset;
      };
      is.future = function(date) {
        var now = new Date();
        return is.date(date) && date.getTime() > now.getTime();
      };
      is.inDateRange = function(date, start, end) {
        if (is.not.date(date) || is.not.date(start) || is.not.date(end)) {
          return false;
        }
        var stamp = date.getTime();
        return stamp > start.getTime() && stamp < end.getTime();
      };
      is.inDateRange.api = ["not"];
      is.inLastMonth = function(date) {
        return is.inDateRange(date, new Date(new Date().setMonth(new Date().getMonth() - 1)), new Date());
      };
      is.inLastWeek = function(date) {
        return is.inDateRange(date, new Date(new Date().setDate(new Date().getDate() - 7)), new Date());
      };
      is.inLastYear = function(date) {
        return is.inDateRange(date, new Date(new Date().setFullYear(new Date().getFullYear() - 1)), new Date());
      };
      is.inNextMonth = function(date) {
        return is.inDateRange(date, new Date(), new Date(new Date().setMonth(new Date().getMonth() + 1)));
      };
      is.inNextWeek = function(date) {
        return is.inDateRange(date, new Date(), new Date(new Date().setDate(new Date().getDate() + 7)));
      };
      is.inNextYear = function(date) {
        return is.inDateRange(date, new Date(), new Date(new Date().setFullYear(new Date().getFullYear() + 1)));
      };
      is.leapYear = function(year) {
        return is.number(year) && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);
      };
      is.month = function(date, month) {
        return is.date(date) && month.toLowerCase() === months[date.getMonth()];
      };
      is.month.api = ["not"];
      is.past = function(date) {
        var now = new Date();
        return is.date(date) && date.getTime() < now.getTime();
      };
      is.quarterOfYear = function(date, quarter) {
        return is.date(date) && is.number(quarter) && quarter === Math.floor((date.getMonth() + 3) / 3);
      };
      is.quarterOfYear.api = ["not"];
      is.today = function(date) {
        var now = new Date();
        var todayString = now.toDateString();
        return is.date(date) && date.toDateString() === todayString;
      };
      is.tomorrow = function(date) {
        var now = new Date();
        var tomorrowString = new Date(now.setDate(now.getDate() + 1)).toDateString();
        return is.date(date) && date.toDateString() === tomorrowString;
      };
      is.weekend = function(date) {
        return is.date(date) && (date.getDay() === 6 || date.getDay() === 0);
      };
      is.weekday = not(is.weekend);
      is.year = function(date, year) {
        return is.date(date) && is.number(year) && year === date.getFullYear();
      };
      is.year.api = ["not"];
      is.yesterday = function(date) {
        var now = new Date();
        var yesterdayString = new Date(now.setDate(now.getDate() - 1)).toDateString();
        return is.date(date) && date.toDateString() === yesterdayString;
      };
      var freeGlobal = is.windowObject(typeof global == "object" && global) && global;
      var freeSelf = is.windowObject(typeof self == "object" && self) && self;
      var thisGlobal = is.windowObject(typeof this == "object" && this) && this;
      var root = freeGlobal || freeSelf || thisGlobal || Function("return this")();
      var document2 = freeSelf && freeSelf.document;
      var previousIs = root.is;
      var navigator = freeSelf && freeSelf.navigator;
      var appVersion = (navigator && navigator.appVersion || "").toLowerCase();
      var userAgent = (navigator && navigator.userAgent || "").toLowerCase();
      var vendor = (navigator && navigator.vendor || "").toLowerCase();
      is.android = function() {
        return /android/.test(userAgent);
      };
      is.android.api = ["not"];
      is.androidPhone = function() {
        return /android/.test(userAgent) && /mobile/.test(userAgent);
      };
      is.androidPhone.api = ["not"];
      is.androidTablet = function() {
        return /android/.test(userAgent) && !/mobile/.test(userAgent);
      };
      is.androidTablet.api = ["not"];
      is.blackberry = function() {
        return /blackberry/.test(userAgent) || /bb10/.test(userAgent);
      };
      is.blackberry.api = ["not"];
      is.chrome = function(range) {
        var match = /google inc/.test(vendor) ? userAgent.match(/(?:chrome|crios)\/(\d+)/) : null;
        return match !== null && compareVersion(match[1], range);
      };
      is.chrome.api = ["not"];
      is.desktop = function() {
        return is.not.mobile() && is.not.tablet();
      };
      is.desktop.api = ["not"];
      is.edge = function(range) {
        var match = userAgent.match(/edge\/(\d+)/);
        return match !== null && compareVersion(match[1], range);
      };
      is.edge.api = ["not"];
      is.firefox = function(range) {
        var match = userAgent.match(/(?:firefox|fxios)\/(\d+)/);
        return match !== null && compareVersion(match[1], range);
      };
      is.firefox.api = ["not"];
      is.ie = function(range) {
        var match = userAgent.match(/(?:msie |trident.+?; rv:)(\d+)/);
        return match !== null && compareVersion(match[1], range);
      };
      is.ie.api = ["not"];
      is.ios = function() {
        return is.iphone() || is.ipad() || is.ipod();
      };
      is.ios.api = ["not"];
      is.ipad = function(range) {
        var match = userAgent.match(/ipad.+?os (\d+)/);
        return match !== null && compareVersion(match[1], range);
      };
      is.ipad.api = ["not"];
      is.iphone = function(range) {
        var match = userAgent.match(/iphone(?:.+?os (\d+))?/);
        return match !== null && compareVersion(match[1] || 1, range);
      };
      is.iphone.api = ["not"];
      is.ipod = function(range) {
        var match = userAgent.match(/ipod.+?os (\d+)/);
        return match !== null && compareVersion(match[1], range);
      };
      is.ipod.api = ["not"];
      is.linux = function() {
        return /linux/.test(appVersion);
      };
      is.linux.api = ["not"];
      is.mac = function() {
        return /mac/.test(appVersion);
      };
      is.mac.api = ["not"];
      is.mobile = function() {
        return is.iphone() || is.ipod() || is.androidPhone() || is.blackberry() || is.windowsPhone();
      };
      is.mobile.api = ["not"];
      is.offline = not(is.online);
      is.offline.api = ["not"];
      is.online = function() {
        return !navigator || navigator.onLine === true;
      };
      is.online.api = ["not"];
      is.opera = function(range) {
        var match = userAgent.match(/(?:^opera.+?version|opr)\/(\d+)/);
        return match !== null && compareVersion(match[1], range);
      };
      is.opera.api = ["not"];
      is.phantom = function(range) {
        var match = userAgent.match(/phantomjs\/(\d+)/);
        return match !== null && compareVersion(match[1], range);
      };
      is.phantom.api = ["not"];
      is.safari = function(range) {
        var match = userAgent.match(/version\/(\d+).+?safari/);
        return match !== null && compareVersion(match[1], range);
      };
      is.safari.api = ["not"];
      is.tablet = function() {
        return is.ipad() || is.androidTablet() || is.windowsTablet();
      };
      is.tablet.api = ["not"];
      is.touchDevice = function() {
        return !!document2 && ("ontouchstart" in freeSelf || "DocumentTouch" in freeSelf && document2 instanceof DocumentTouch);
      };
      is.touchDevice.api = ["not"];
      is.windows = function() {
        return /win/.test(appVersion);
      };
      is.windows.api = ["not"];
      is.windowsPhone = function() {
        return is.windows() && /phone/.test(userAgent);
      };
      is.windowsPhone.api = ["not"];
      is.windowsTablet = function() {
        return is.windows() && is.not.windowsPhone() && /touch/.test(userAgent);
      };
      is.windowsTablet.api = ["not"];
      is.propertyCount = function(object, count) {
        if (is.not.object(object) || is.not.number(count)) {
          return false;
        }
        var n = 0;
        for (var property in object) {
          if (hasOwnProperty.call(object, property) && ++n > count) {
            return false;
          }
        }
        return n === count;
      };
      is.propertyCount.api = ["not"];
      is.propertyDefined = function(object, property) {
        return is.object(object) && is.string(property) && property in object;
      };
      is.propertyDefined.api = ["not"];
      is.inArray = function(value, array) {
        if (is.not.array(array)) {
          return false;
        }
        for (var i = 0; i < array.length; i++) {
          if (array[i] === value) {
            return true;
          }
        }
        return false;
      };
      is.inArray.api = ["not"];
      is.sorted = function(array, sign) {
        if (is.not.array(array)) {
          return false;
        }
        var predicate = comparator[sign] || comparator[">="];
        for (var i = 1; i < array.length; i++) {
          if (!predicate(array[i], array[i - 1])) {
            return false;
          }
        }
        return true;
      };
      function setInterfaces() {
        var options = is;
        for (var option in options) {
          if (hasOwnProperty.call(options, option) && is["function"](options[option])) {
            var interfaces = options[option].api || ["not", "all", "any"];
            for (var i = 0; i < interfaces.length; i++) {
              if (interfaces[i] === "not") {
                is.not[option] = not(is[option]);
              }
              if (interfaces[i] === "all") {
                is.all[option] = all(is[option]);
              }
              if (interfaces[i] === "any") {
                is.any[option] = any(is[option]);
              }
            }
          }
        }
      }
      setInterfaces();
      is.setNamespace = function() {
        root.is = previousIs;
        return this;
      };
      is.setRegexp = function(regexp2, name) {
        for (var r in regexes) {
          if (hasOwnProperty.call(regexes, r) && name === r) {
            regexes[r] = regexp2;
          }
        }
      };
      return is;
    });
  }
});

// node_modules/request-ip/index.js
var require_request_ip = __commonJS({
  "node_modules/request-ip/index.js"(exports, module2) {
    var is = require_is();
    function getClientIpFromXForwardedFor(value) {
      if (!is.existy(value)) {
        return null;
      }
      if (is.not.string(value)) {
        throw new TypeError(`Expected a string, got "${typeof value}"`);
      }
      const forwardedIps = value.split(",").map((e) => {
        const ip = e.trim();
        if (ip.includes(":")) {
          const splitted = ip.split(":");
          if (splitted.length === 2) {
            return splitted[0];
          }
        }
        return ip;
      });
      return forwardedIps.find(is.ip);
    }
    function getClientIp(req) {
      if (req.headers) {
        if (is.ip(req.headers["x-client-ip"])) {
          return req.headers["x-client-ip"];
        }
        const xForwardedFor = getClientIpFromXForwardedFor(req.headers["x-forwarded-for"]);
        if (is.ip(xForwardedFor)) {
          return xForwardedFor;
        }
        if (is.ip(req.headers["cf-connecting-ip"])) {
          return req.headers["cf-connecting-ip"];
        }
        if (is.ip(req.headers["true-client-ip"])) {
          return req.headers["true-client-ip"];
        }
        if (is.ip(req.headers["x-real-ip"])) {
          return req.headers["x-real-ip"];
        }
        if (is.ip(req.headers["x-cluster-client-ip"])) {
          return req.headers["x-cluster-client-ip"];
        }
        if (is.ip(req.headers["x-forwarded"])) {
          return req.headers["x-forwarded"];
        }
        if (is.ip(req.headers["forwarded-for"])) {
          return req.headers["forwarded-for"];
        }
        if (is.ip(req.headers.forwarded)) {
          return req.headers.forwarded;
        }
      }
      if (is.existy(req.connection)) {
        if (is.ip(req.connection.remoteAddress)) {
          return req.connection.remoteAddress;
        }
        if (is.existy(req.connection.socket) && is.ip(req.connection.socket.remoteAddress)) {
          return req.connection.socket.remoteAddress;
        }
      }
      if (is.existy(req.socket) && is.ip(req.socket.remoteAddress)) {
        return req.socket.remoteAddress;
      }
      if (is.existy(req.info) && is.ip(req.info.remoteAddress)) {
        return req.info.remoteAddress;
      }
      return null;
    }
    function mw(options) {
      const configuration2 = is.not.existy(options) ? {} : options;
      if (is.not.object(configuration2)) {
        throw new TypeError("Options must be an object!");
      }
      const attributeName = configuration2.attributeName || "clientIp";
      return (req, res, next) => {
        req[attributeName] = getClientIp(req);
        next();
      };
    }
    module2.exports = {
      getClientIpFromXForwardedFor,
      getClientIp,
      mw
    };
  }
});

// node_modules/rollbar/src/scrub.js
var require_scrub = __commonJS({
  "node_modules/rollbar/src/scrub.js"(exports, module2) {
    var _ = require_utility();
    var traverse = require_traverse();
    function scrub(data, scrubFields, scrubPaths) {
      scrubFields = scrubFields || [];
      if (scrubPaths) {
        for (var i = 0; i < scrubPaths.length; ++i) {
          scrubPath(data, scrubPaths[i]);
        }
      }
      var paramRes = _getScrubFieldRegexs(scrubFields);
      var queryRes = _getScrubQueryParamRegexs(scrubFields);
      function redactQueryParam(dummy0, paramPart) {
        return paramPart + _.redact();
      }
      function paramScrubber(v) {
        var i2;
        if (_.isType(v, "string")) {
          for (i2 = 0; i2 < queryRes.length; ++i2) {
            v = v.replace(queryRes[i2], redactQueryParam);
          }
        }
        return v;
      }
      function valScrubber(k, v) {
        var i2;
        for (i2 = 0; i2 < paramRes.length; ++i2) {
          if (paramRes[i2].test(k)) {
            v = _.redact();
            break;
          }
        }
        return v;
      }
      function scrubber(k, v, seen) {
        var tmpV = valScrubber(k, v);
        if (tmpV === v) {
          if (_.isType(v, "object") || _.isType(v, "array")) {
            return traverse(v, scrubber, seen);
          }
          return paramScrubber(tmpV);
        } else {
          return tmpV;
        }
      }
      return traverse(data, scrubber);
    }
    function scrubPath(obj, path3) {
      var keys = path3.split(".");
      var last = keys.length - 1;
      try {
        for (var i = 0; i <= last; ++i) {
          if (i < last) {
            obj = obj[keys[i]];
          } else {
            obj[keys[i]] = _.redact();
          }
        }
      } catch (e) {
      }
    }
    function _getScrubFieldRegexs(scrubFields) {
      var ret = [];
      var pat;
      for (var i = 0; i < scrubFields.length; ++i) {
        pat = "^\\[?(%5[bB])?" + scrubFields[i] + "\\[?(%5[bB])?\\]?(%5[dD])?$";
        ret.push(new RegExp(pat, "i"));
      }
      return ret;
    }
    function _getScrubQueryParamRegexs(scrubFields) {
      var ret = [];
      var pat;
      for (var i = 0; i < scrubFields.length; ++i) {
        pat = "\\[?(%5[bB])?" + scrubFields[i] + "\\[?(%5[bB])?\\]?(%5[dD])?";
        ret.push(new RegExp("(" + pat + "=)([^&\\n]+)", "igm"));
      }
      return ret;
    }
    module2.exports = scrub;
  }
});

// node_modules/rollbar/src/server/transforms.js
var require_transforms = __commonJS({
  "node_modules/rollbar/src/server/transforms.js"(exports, module2) {
    var async = require_async2();
    var parser = require_parser();
    var requestIp = require_request_ip();
    var url = require("url");
    var _ = require_utility();
    var scrub = require_scrub();
    function baseData(item, options, callback) {
      var environment = options.payload && options.payload.environment || options.environment;
      var data = {
        timestamp: Math.round(item.timestamp / 1e3),
        environment: item.environment || environment,
        level: item.level || "error",
        language: "javascript",
        framework: item.framework || options.framework,
        uuid: item.uuid,
        notifier: JSON.parse(JSON.stringify(options.notifier)),
        custom: item.custom
      };
      if (options.codeVersion) {
        data.code_version = options.codeVersion;
      } else if (options.code_version) {
        data.code_version = options.code_version;
      }
      var props = Object.getOwnPropertyNames(item.custom || {});
      props.forEach(function(name) {
        if (!data.hasOwnProperty(name)) {
          data[name] = item.custom[name];
        }
      });
      data.server = {
        host: options.host,
        argv: process.argv.concat(),
        pid: process.pid
      };
      if (options.branch) {
        data.server.branch = options.branch;
      }
      if (options.root) {
        data.server.root = options.root;
      }
      item.data = data;
      callback(null, item);
    }
    function addMessageData(item, options, callback) {
      item.data = item.data || {};
      item.data.body = item.data.body || {};
      var message = item.message || "Item sent with null or missing arguments.";
      item.data.body.message = {
        body: message
      };
      callback(null, item);
    }
    function addErrorData(item, options, callback) {
      if (item.stackInfo) {
        item.data = item.data || {};
        item.data.body = item.data.body || {};
        item.data.body.trace_chain = item.stackInfo;
      }
      callback(null, item);
    }
    function addBody(item, options, callback) {
      if (item.stackInfo) {
        addErrorData(item, options, callback);
      } else {
        addMessageData(item, options, callback);
      }
    }
    function handleItemWithError(item, options, callback) {
      if (!item.err) {
        return callback(null, item);
      }
      var err = item.err;
      var errors = [];
      var chain = [];
      do {
        errors.push(err);
        err = err.nested || err.cause;
      } while (err);
      item.stackInfo = chain;
      if (options.addErrorContext) {
        _.addErrorContext(item, errors);
      }
      var cb = function(e) {
        if (e) {
          item.message = item.err.message || item.err.description || item.message || String(item.err);
          item.diagnostic.buildTraceData = e.message;
          delete item.stackInfo;
        }
        callback(null, item);
      };
      async.eachSeries(errors, _buildTraceData(chain, options, item), cb);
    }
    function addRequestData(item, options, callback) {
      item.data = item.data || {};
      var req = item.request;
      if (!req) {
        callback(null, item);
        return;
      }
      var baseUrl = req.baseUrl || "";
      if (options.addRequestData && _.isFunction(options.addRequestData)) {
        options.addRequestData(item.data, req);
        callback(null, item);
        return;
      }
      var requestData = _buildRequestData(req);
      _.filterIp(requestData, options.captureIp);
      item.data.request = requestData;
      var routePath;
      if (req.route) {
        routePath = req.route.path;
        item.data.context = baseUrl && baseUrl.length ? baseUrl + routePath : routePath;
      } else {
        try {
          routePath = req.app._router.matchRequest(req).path;
          item.data.context = baseUrl && baseUrl.length ? baseUrl + routePath : routePath;
        } catch (ignore) {
        }
      }
      var captureEmail = options.captureEmail;
      var captureUsername = options.captureUsername;
      if (req.rollbar_person) {
        var person = req.rollbar_person;
        if (!captureEmail && person.email) {
          person.email = null;
        }
        if (!captureUsername && person.username) {
          person.username = null;
        }
        item.data.person = person;
      } else if (req.user) {
        item.data.person = { id: req.user.id };
        if (req.user.username && captureUsername) {
          item.data.person.username = req.user.username;
        }
        if (req.user.email && captureEmail) {
          item.data.person.email = req.user.email;
        }
      } else if (req.user_id || req.userId) {
        var userId = req.user_id || req.userId;
        if (_.isFunction(userId)) {
          userId = userId();
        }
        item.data.person = { id: userId };
      }
      callback(null, item);
    }
    function addLambdaData(item, options, callback) {
      var c = item.lambdaContext;
      if (!c) {
        callback(null, item);
        return;
      }
      var data = {
        remainingTimeInMillis: c.getRemainingTimeInMillis(),
        callbackWaitsForEmptyEventLoop: c.callbackWaitsForEmptyEventLoop,
        functionName: c.functionName,
        functionVersion: c.functionVersion,
        arn: c.invokedFunctionArn,
        requestId: c.awsRequestId
      };
      item.data = item.data || {};
      item.data.custom = item.data.custom || {};
      item.data.custom.lambda = data;
      callback(null, item);
    }
    function scrubPayload(item, options, callback) {
      var scrubHeaders = options.scrubHeaders || [];
      var scrubFields = options.scrubFields || [];
      var scrubPaths = options.scrubPaths || [];
      scrubFields = scrubHeaders.concat(scrubFields);
      parseRequestBody(item.data.request, options);
      item.data = scrub(item.data, scrubFields, scrubPaths);
      serializeRequestBody(item.data.request, options);
      callback(null, item);
    }
    function parseRequestBody(req, options) {
      if (!req || !options.scrubRequestBody) {
        return;
      }
      try {
        if (_.isString(req.body) && _isJsonContentType(req)) {
          req.body = JSON.parse(req.body);
        }
      } catch (e) {
        req.body = null;
        req.error = "request.body parse failed: " + e.message;
      }
    }
    function serializeRequestBody(req, options) {
      if (!req || !options.scrubRequestBody) {
        return;
      }
      try {
        if (_.isObject(req.body) && _isJsonContentType(req)) {
          req.body = JSON.stringify(req.body);
        }
      } catch (e) {
        req.body = null;
        req.error = "request.body serialization failed: " + e.message;
      }
    }
    function _isJsonContentType(req) {
      return req.headers && req.headers["content-type"] && req.headers["content-type"].includes("json");
    }
    function _buildTraceData(chain, options, item) {
      return function(ex, cb) {
        parser.parseException(ex, options, item, function(err, errData) {
          if (err) {
            return cb(err);
          }
          chain.push({
            frames: errData.frames,
            exception: {
              class: errData["class"],
              message: errData.message
            }
          });
          return cb(null);
        });
      };
    }
    function _extractIp(req) {
      var ip = req.ip;
      if (!ip) {
        ip = requestIp.getClientIp(req);
      }
      return ip;
    }
    function _buildRequestData(req) {
      var headers = req.headers || {};
      var host = headers.host || "<no host>";
      var proto = req.protocol || (req.socket && req.socket.encrypted ? "https" : "http");
      var parsedUrl;
      var baseUrl = req.baseUrl || "";
      if (_.isType(req.url, "string")) {
        var fullUrl = baseUrl && baseUrl.length ? baseUrl + req.url : req.url;
        parsedUrl = url.parse(fullUrl, true);
      } else {
        parsedUrl = req.url || {};
      }
      parsedUrl.protocol = parsedUrl.protocol || proto;
      parsedUrl.host = parsedUrl.host || host;
      var reqUrl = url.format(parsedUrl);
      var data = {
        url: reqUrl,
        user_ip: _extractIp(req),
        headers,
        method: req.method
      };
      if (parsedUrl.search && parsedUrl.search.length > 0) {
        data.GET = parsedUrl.query;
      }
      var body = req.body || req.payload;
      if (body) {
        var bodyParams = {};
        if (_.isIterable(body)) {
          for (var k in body) {
            if (Object.prototype.hasOwnProperty.call(body, k)) {
              bodyParams[k] = body[k];
            }
          }
          data[req.method] = bodyParams;
        } else {
          data.body = body;
        }
      }
      return data;
    }
    module2.exports = {
      baseData,
      handleItemWithError,
      addBody,
      addMessageData,
      addErrorData,
      addRequestData,
      addLambdaData,
      scrubPayload
    };
  }
});

// node_modules/rollbar/src/transforms.js
var require_transforms2 = __commonJS({
  "node_modules/rollbar/src/transforms.js"(exports, module2) {
    var _ = require_utility();
    function itemToPayload(item, options, callback) {
      var payloadOptions = options.payload || {};
      if (payloadOptions.body) {
        delete payloadOptions.body;
      }
      var data = _.merge(item.data, payloadOptions);
      if (item._isUncaught) {
        data._isUncaught = true;
      }
      if (item._originalArgs) {
        data._originalArgs = item._originalArgs;
      }
      callback(null, data);
    }
    function addTelemetryData(item, options, callback) {
      if (item.telemetryEvents) {
        _.set(item, "data.body.telemetry", item.telemetryEvents);
      }
      callback(null, item);
    }
    function addMessageWithError(item, options, callback) {
      if (!item.message) {
        callback(null, item);
        return;
      }
      var tracePath = "data.body.trace_chain.0";
      var trace = _.get(item, tracePath);
      if (!trace) {
        tracePath = "data.body.trace";
        trace = _.get(item, tracePath);
      }
      if (trace) {
        if (!(trace.exception && trace.exception.description)) {
          _.set(item, tracePath + ".exception.description", item.message);
          callback(null, item);
          return;
        }
        var extra = _.get(item, tracePath + ".extra") || {};
        var newExtra = _.merge(extra, { message: item.message });
        _.set(item, tracePath + ".extra", newExtra);
      }
      callback(null, item);
    }
    function userTransform(logger) {
      return function(item, options, callback) {
        var newItem = _.merge(item);
        var response = null;
        try {
          if (_.isFunction(options.transform)) {
            response = options.transform(newItem.data, item);
          }
        } catch (e) {
          options.transform = null;
          logger.error("Error while calling custom transform() function. Removing custom transform().", e);
          callback(null, item);
          return;
        }
        if (_.isPromise(response)) {
          response.then(function(promisedItem) {
            if (promisedItem) {
              newItem.data = promisedItem;
            }
            callback(null, newItem);
          }, function(error) {
            callback(error, item);
          });
        } else {
          callback(null, newItem);
        }
      };
    }
    function addConfigToPayload(item, options, callback) {
      if (!options.sendConfig) {
        return callback(null, item);
      }
      var configKey = "_rollbarConfig";
      var custom = _.get(item, "data.custom") || {};
      custom[configKey] = options;
      item.data.custom = custom;
      callback(null, item);
    }
    function addFunctionOption(options, name) {
      if (_.isFunction(options[name])) {
        options[name] = options[name].toString();
      }
    }
    function addConfiguredOptions(item, options, callback) {
      var configuredOptions = options._configuredOptions;
      addFunctionOption(configuredOptions, "transform");
      addFunctionOption(configuredOptions, "checkIgnore");
      addFunctionOption(configuredOptions, "onSendCallback");
      delete configuredOptions.accessToken;
      item.data.notifier.configured_options = configuredOptions;
      callback(null, item);
    }
    function addDiagnosticKeys(item, options, callback) {
      var diagnostic = _.merge(item.notifier.client.notifier.diagnostic, item.diagnostic);
      if (_.get(item, "err._isAnonymous")) {
        diagnostic.is_anonymous = true;
      }
      if (item._isUncaught) {
        diagnostic.is_uncaught = item._isUncaught;
      }
      if (item.err) {
        try {
          diagnostic.raw_error = {
            message: item.err.message,
            name: item.err.name,
            constructor_name: item.err.constructor && item.err.constructor.name,
            filename: item.err.fileName,
            line: item.err.lineNumber,
            column: item.err.columnNumber,
            stack: item.err.stack
          };
        } catch (e) {
          diagnostic.raw_error = { failed: String(e) };
        }
      }
      item.data.notifier.diagnostic = _.merge(item.data.notifier.diagnostic, diagnostic);
      callback(null, item);
    }
    module2.exports = {
      itemToPayload,
      addTelemetryData,
      addMessageWithError,
      userTransform,
      addConfigToPayload,
      addConfiguredOptions,
      addDiagnosticKeys
    };
  }
});

// node_modules/rollbar/src/predicates.js
var require_predicates = __commonJS({
  "node_modules/rollbar/src/predicates.js"(exports, module2) {
    var _ = require_utility();
    function checkLevel(item, settings) {
      var level = item.level;
      var levelVal = _.LEVELS[level] || 0;
      var reportLevel = settings.reportLevel;
      var reportLevelVal = _.LEVELS[reportLevel] || 0;
      if (levelVal < reportLevelVal) {
        return false;
      }
      return true;
    }
    function userCheckIgnore(logger) {
      return function(item, settings) {
        var isUncaught = !!item._isUncaught;
        delete item._isUncaught;
        var args = item._originalArgs;
        delete item._originalArgs;
        try {
          if (_.isFunction(settings.onSendCallback)) {
            settings.onSendCallback(isUncaught, args, item);
          }
        } catch (e) {
          settings.onSendCallback = null;
          logger.error("Error while calling onSendCallback, removing", e);
        }
        try {
          if (_.isFunction(settings.checkIgnore) && settings.checkIgnore(isUncaught, args, item)) {
            return false;
          }
        } catch (e) {
          settings.checkIgnore = null;
          logger.error("Error while calling custom checkIgnore(), removing", e);
        }
        return true;
      };
    }
    function urlIsNotBlockListed(logger) {
      return function(item, settings) {
        return !urlIsOnAList(item, settings, "blocklist", logger);
      };
    }
    function urlIsSafeListed(logger) {
      return function(item, settings) {
        return urlIsOnAList(item, settings, "safelist", logger);
      };
    }
    function matchFrames(trace, list, block) {
      if (!trace) {
        return !block;
      }
      var frames = trace.frames;
      if (!frames || frames.length === 0) {
        return !block;
      }
      var frame, filename, url, urlRegex;
      var listLength = list.length;
      var frameLength = frames.length;
      for (var i = 0; i < frameLength; i++) {
        frame = frames[i];
        filename = frame.filename;
        if (!_.isType(filename, "string")) {
          return !block;
        }
        for (var j = 0; j < listLength; j++) {
          url = list[j];
          urlRegex = new RegExp(url);
          if (urlRegex.test(filename)) {
            return true;
          }
        }
      }
      return false;
    }
    function urlIsOnAList(item, settings, safeOrBlock, logger) {
      var block = false;
      if (safeOrBlock === "blocklist") {
        block = true;
      }
      var list, traces;
      try {
        list = block ? settings.hostBlockList : settings.hostSafeList;
        traces = _.get(item, "body.trace_chain") || [_.get(item, "body.trace")];
        if (!list || list.length === 0) {
          return !block;
        }
        if (traces.length === 0 || !traces[0]) {
          return !block;
        }
        var tracesLength = traces.length;
        for (var i = 0; i < tracesLength; i++) {
          if (matchFrames(traces[i], list, block)) {
            return true;
          }
        }
      } catch (e) {
        if (block) {
          settings.hostBlockList = null;
        } else {
          settings.hostSafeList = null;
        }
        var listName = block ? "hostBlockList" : "hostSafeList";
        logger.error("Error while reading your configuration's " + listName + " option. Removing custom " + listName + ".", e);
        return !block;
      }
      return false;
    }
    function messageIsIgnored(logger) {
      return function(item, settings) {
        var i, j, ignoredMessages, len, messageIsIgnored2, rIgnoredMessage, messages;
        try {
          messageIsIgnored2 = false;
          ignoredMessages = settings.ignoredMessages;
          if (!ignoredMessages || ignoredMessages.length === 0) {
            return true;
          }
          messages = messagesFromItem(item);
          if (messages.length === 0) {
            return true;
          }
          len = ignoredMessages.length;
          for (i = 0; i < len; i++) {
            rIgnoredMessage = new RegExp(ignoredMessages[i], "gi");
            for (j = 0; j < messages.length; j++) {
              messageIsIgnored2 = rIgnoredMessage.test(messages[j]);
              if (messageIsIgnored2) {
                return false;
              }
            }
          }
        } catch (e) {
          settings.ignoredMessages = null;
          logger.error("Error while reading your configuration's ignoredMessages option. Removing custom ignoredMessages.");
        }
        return true;
      };
    }
    function messagesFromItem(item) {
      var body = item.body;
      var messages = [];
      if (body.trace_chain) {
        var traceChain = body.trace_chain;
        for (var i = 0; i < traceChain.length; i++) {
          var trace = traceChain[i];
          messages.push(_.get(trace, "exception.message"));
        }
      }
      if (body.trace) {
        messages.push(_.get(body, "trace.exception.message"));
      }
      if (body.message) {
        messages.push(_.get(body, "message.body"));
      }
      return messages;
    }
    module2.exports = {
      checkLevel,
      userCheckIgnore,
      urlIsNotBlockListed,
      urlIsSafeListed,
      messageIsIgnored
    };
  }
});

// node_modules/rollbar/vendor/JSON-js/json3.js
var require_json3 = __commonJS({
  "node_modules/rollbar/vendor/JSON-js/json3.js"(exports, module2) {
    var setupCustomJSON = function(JSON2) {
      var rx_one = /^[\],:{}\s]*$/;
      var rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
      var rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
      var rx_four = /(?:^|:|,)(?:\s*\[)+/g;
      var rx_escapable = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
      var rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
      function f(n) {
        return n < 10 ? "0" + n : n;
      }
      function this_value() {
        return this.valueOf();
      }
      if (typeof Date.prototype.toJSON !== "function") {
        Date.prototype.toJSON = function() {
          return isFinite(this.valueOf()) ? this.getUTCFullYear() + "-" + f(this.getUTCMonth() + 1) + "-" + f(this.getUTCDate()) + "T" + f(this.getUTCHours()) + ":" + f(this.getUTCMinutes()) + ":" + f(this.getUTCSeconds()) + "Z" : null;
        };
        Boolean.prototype.toJSON = this_value;
        Number.prototype.toJSON = this_value;
        String.prototype.toJSON = this_value;
      }
      var gap;
      var indent2;
      var meta;
      var rep;
      function quote(string) {
        rx_escapable.lastIndex = 0;
        return rx_escapable.test(string) ? '"' + string.replace(rx_escapable, function(a) {
          var c = meta[a];
          return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
      }
      function str(key, holder) {
        var i;
        var k;
        var v;
        var length;
        var mind = gap;
        var partial;
        var value = holder[key];
        if (value && typeof value === "object" && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        if (typeof rep === "function") {
          value = rep.call(holder, key, value);
        }
        switch (typeof value) {
          case "string":
            return quote(value);
          case "number":
            return isFinite(value) ? String(value) : "null";
          case "boolean":
          case "null":
            return String(value);
          case "object":
            if (!value) {
              return "null";
            }
            gap += indent2;
            partial = [];
            if (Object.prototype.toString.apply(value) === "[object Array]") {
              length = value.length;
              for (i = 0; i < length; i += 1) {
                partial[i] = str(i, value) || "null";
              }
              v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
              gap = mind;
              return v;
            }
            if (rep && typeof rep === "object") {
              length = rep.length;
              for (i = 0; i < length; i += 1) {
                if (typeof rep[i] === "string") {
                  k = rep[i];
                  v = str(k, value);
                  if (v) {
                    partial.push(quote(k) + (gap ? ": " : ":") + v);
                  }
                }
              }
            } else {
              for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                  v = str(k, value);
                  if (v) {
                    partial.push(quote(k) + (gap ? ": " : ":") + v);
                  }
                }
              }
            }
            v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
            gap = mind;
            return v;
        }
      }
      if (typeof JSON2.stringify !== "function") {
        meta = {
          "\b": "\\b",
          "	": "\\t",
          "\n": "\\n",
          "\f": "\\f",
          "\r": "\\r",
          '"': '\\"',
          "\\": "\\\\"
        };
        JSON2.stringify = function(value, replacer, space) {
          var i;
          gap = "";
          indent2 = "";
          if (typeof space === "number") {
            for (i = 0; i < space; i += 1) {
              indent2 += " ";
            }
          } else if (typeof space === "string") {
            indent2 = space;
          }
          rep = replacer;
          if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
            throw new Error("JSON.stringify");
          }
          return str("", { "": value });
        };
      }
      if (typeof JSON2.parse !== "function") {
        JSON2.parse = function() {
          var state;
          var stack;
          var container2;
          var key;
          var value;
          var escapes = {
            "\\": "\\",
            '"': '"',
            "/": "/",
            "t": "	",
            "n": "\n",
            "r": "\r",
            "f": "\f",
            "b": "\b"
          };
          var string = {
            go: function() {
              state = "ok";
            },
            firstokey: function() {
              key = value;
              state = "colon";
            },
            okey: function() {
              key = value;
              state = "colon";
            },
            ovalue: function() {
              state = "ocomma";
            },
            firstavalue: function() {
              state = "acomma";
            },
            avalue: function() {
              state = "acomma";
            }
          };
          var number = {
            go: function() {
              state = "ok";
            },
            ovalue: function() {
              state = "ocomma";
            },
            firstavalue: function() {
              state = "acomma";
            },
            avalue: function() {
              state = "acomma";
            }
          };
          var action = {
            "{": {
              go: function() {
                stack.push({ state: "ok" });
                container2 = {};
                state = "firstokey";
              },
              ovalue: function() {
                stack.push({ container: container2, state: "ocomma", key });
                container2 = {};
                state = "firstokey";
              },
              firstavalue: function() {
                stack.push({ container: container2, state: "acomma" });
                container2 = {};
                state = "firstokey";
              },
              avalue: function() {
                stack.push({ container: container2, state: "acomma" });
                container2 = {};
                state = "firstokey";
              }
            },
            "}": {
              firstokey: function() {
                var pop = stack.pop();
                value = container2;
                container2 = pop.container;
                key = pop.key;
                state = pop.state;
              },
              ocomma: function() {
                var pop = stack.pop();
                container2[key] = value;
                value = container2;
                container2 = pop.container;
                key = pop.key;
                state = pop.state;
              }
            },
            "[": {
              go: function() {
                stack.push({ state: "ok" });
                container2 = [];
                state = "firstavalue";
              },
              ovalue: function() {
                stack.push({ container: container2, state: "ocomma", key });
                container2 = [];
                state = "firstavalue";
              },
              firstavalue: function() {
                stack.push({ container: container2, state: "acomma" });
                container2 = [];
                state = "firstavalue";
              },
              avalue: function() {
                stack.push({ container: container2, state: "acomma" });
                container2 = [];
                state = "firstavalue";
              }
            },
            "]": {
              firstavalue: function() {
                var pop = stack.pop();
                value = container2;
                container2 = pop.container;
                key = pop.key;
                state = pop.state;
              },
              acomma: function() {
                var pop = stack.pop();
                container2.push(value);
                value = container2;
                container2 = pop.container;
                key = pop.key;
                state = pop.state;
              }
            },
            ":": {
              colon: function() {
                if (Object.hasOwnProperty.call(container2, key)) {
                  throw new SyntaxError("Duplicate key '" + key + '"');
                }
                state = "ovalue";
              }
            },
            ",": {
              ocomma: function() {
                container2[key] = value;
                state = "okey";
              },
              acomma: function() {
                container2.push(value);
                state = "avalue";
              }
            },
            "true": {
              go: function() {
                value = true;
                state = "ok";
              },
              ovalue: function() {
                value = true;
                state = "ocomma";
              },
              firstavalue: function() {
                value = true;
                state = "acomma";
              },
              avalue: function() {
                value = true;
                state = "acomma";
              }
            },
            "false": {
              go: function() {
                value = false;
                state = "ok";
              },
              ovalue: function() {
                value = false;
                state = "ocomma";
              },
              firstavalue: function() {
                value = false;
                state = "acomma";
              },
              avalue: function() {
                value = false;
                state = "acomma";
              }
            },
            "null": {
              go: function() {
                value = null;
                state = "ok";
              },
              ovalue: function() {
                value = null;
                state = "ocomma";
              },
              firstavalue: function() {
                value = null;
                state = "acomma";
              },
              avalue: function() {
                value = null;
                state = "acomma";
              }
            }
          };
          function debackslashify(text) {
            return text.replace(/\\(?:u(.{4})|([^u]))/g, function(ignore, b, c) {
              return b ? String.fromCharCode(parseInt(b, 16)) : escapes[c];
            });
          }
          return function(source, reviver) {
            var result;
            var tx = /^[\u0020\t\n\r]*(?:([,:\[\]{}]|true|false|null)|(-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)|"((?:[^\r\n\t\\\"]|\\(?:["\\\/trnfb]|u[0-9a-fA-F]{4}))*)")/;
            state = "go";
            stack = [];
            try {
              while (true) {
                result = tx.exec(source);
                if (!result) {
                  break;
                }
                if (result[1]) {
                  action[result[1]][state]();
                } else if (result[2]) {
                  value = +result[2];
                  number[state]();
                } else {
                  value = debackslashify(result[3]);
                  string[state]();
                }
                source = source.slice(result[0].length);
              }
            } catch (e) {
              state = e;
            }
            if (state !== "ok" || /[^\u0020\t\n\r]/.test(source)) {
              throw state instanceof SyntaxError ? state : new SyntaxError("JSON");
            }
            return typeof reviver === "function" ? function walk(holder, key2) {
              var k;
              var v;
              var val = holder[key2];
              if (val && typeof val === "object") {
                for (k in value) {
                  if (Object.prototype.hasOwnProperty.call(val, k)) {
                    v = walk(val, k);
                    if (v !== void 0) {
                      val[k] = v;
                    } else {
                      delete val[k];
                    }
                  }
                }
              }
              return reviver.call(holder, key2, val);
            }({ "": value }, "") : value;
          };
        }();
      }
    };
    module2.exports = setupCustomJSON;
  }
});

// node_modules/rollbar/src/server/rollbar.js
var require_rollbar2 = __commonJS({
  "node_modules/rollbar/src/server/rollbar.js"(exports, module2) {
    var util = require("util");
    var os = require("os");
    var packageJson = require_package();
    var Client = require_rollbar();
    var _ = require_utility();
    var API = require_api();
    var logger = require_logger();
    var Transport = require_transport();
    var urllib = require("url");
    var jsonBackup = require_stringify();
    var Telemeter = require_telemetry();
    var Instrumenter = require_telemetry2();
    var transforms = require_transforms();
    var sharedTransforms = require_transforms2();
    var sharedPredicates = require_predicates();
    var truncation = require_truncation();
    var polyfillJSON = require_json3();
    function Rollbar2(options, client) {
      if (_.isType(options, "string")) {
        var accessToken = options;
        options = {};
        options.accessToken = accessToken;
      }
      if (options.minimumLevel !== void 0) {
        options.reportLevel = options.minimumLevel;
        delete options.minimumLevel;
      }
      this.options = _.handleOptions(Rollbar2.defaultOptions, options, null, logger);
      this.options._configuredOptions = options;
      delete this.options.maxItems;
      this.options.environment = this.options.environment || "unspecified";
      logger.setVerbose(this.options.verbose);
      this.lambdaContext = null;
      this.lambdaTimeoutHandle = null;
      var transport = new Transport();
      var api = new API(this.options, transport, urllib, truncation, jsonBackup);
      var telemeter = new Telemeter(this.options);
      this.client = client || new Client(this.options, api, logger, telemeter, "server");
      this.instrumenter = new Instrumenter(this.options, this.client.telemeter, this);
      this.instrumenter.instrument();
      if (this.options.locals) {
        this.locals = initLocals(this.options.locals, logger);
      }
      addTransformsToNotifier(this.client.notifier);
      addPredicatesToQueue(this.client.queue);
      this.setupUnhandledCapture();
      _.setupJSON(polyfillJSON);
    }
    function initLocals(localsOptions, logger2) {
      var nodeMajorVersion = process.versions.node.split(".")[0];
      if (nodeMajorVersion < 10) {
        return null;
      }
      var Locals;
      if (typeof localsOptions === "function") {
        Locals = localsOptions;
        localsOptions = null;
      } else if (_.isType(localsOptions, "object")) {
        Locals = localsOptions.module;
        delete localsOptions.module;
      } else {
        logger2.error("options.locals or options.locals.module must be a Locals module");
        return null;
      }
      return new Locals(localsOptions, logger2);
    }
    var _instance = null;
    Rollbar2.init = function(options, client) {
      if (_instance) {
        return _instance.global(options).configure(options);
      }
      _instance = new Rollbar2(options, client);
      return _instance;
    };
    function handleUninitialized(maybeCallback) {
      var message = "Rollbar is not initialized";
      logger.error(message);
      if (maybeCallback) {
        maybeCallback(new Error(message));
      }
    }
    Rollbar2.prototype.global = function(options) {
      options = _.handleOptions(options);
      delete options.maxItems;
      this.client.global(options);
      return this;
    };
    Rollbar2.global = function(options) {
      if (_instance) {
        return _instance.global(options);
      } else {
        handleUninitialized();
      }
    };
    Rollbar2.prototype.configure = function(options, payloadData) {
      var oldOptions = this.options;
      var payload = {};
      if (payloadData) {
        payload = { payload: payloadData };
      }
      this.options = _.handleOptions(oldOptions, options, payload, logger);
      this.options._configuredOptions = _.handleOptions(oldOptions._configuredOptions, options, payload);
      delete this.options.maxItems;
      logger.setVerbose(this.options.verbose);
      this.client.configure(options, payloadData);
      this.setupUnhandledCapture();
      if (this.options.locals) {
        if (this.locals) {
          this.locals.updateOptions(this.options.locals);
        } else {
          this.locals = initLocals(this.options.locals, logger);
        }
      }
      return this;
    };
    Rollbar2.configure = function(options, payloadData) {
      if (_instance) {
        return _instance.configure(options, payloadData);
      } else {
        handleUninitialized();
      }
    };
    Rollbar2.prototype.lastError = function() {
      return this.client.lastError;
    };
    Rollbar2.lastError = function() {
      if (_instance) {
        return _instance.lastError();
      } else {
        handleUninitialized();
      }
    };
    Rollbar2.prototype.log = function() {
      var item = this._createItem(arguments);
      var uuid = item.uuid;
      this.client.log(item);
      return { uuid };
    };
    Rollbar2.log = function() {
      if (_instance) {
        return _instance.log.apply(_instance, arguments);
      } else {
        var maybeCallback = _getFirstFunction(arguments);
        handleUninitialized(maybeCallback);
      }
    };
    Rollbar2.prototype.debug = function() {
      var item = this._createItem(arguments);
      var uuid = item.uuid;
      this.client.debug(item);
      return { uuid };
    };
    Rollbar2.debug = function() {
      if (_instance) {
        return _instance.debug.apply(_instance, arguments);
      } else {
        var maybeCallback = _getFirstFunction(arguments);
        handleUninitialized(maybeCallback);
      }
    };
    Rollbar2.prototype.info = function() {
      var item = this._createItem(arguments);
      var uuid = item.uuid;
      this.client.info(item);
      return { uuid };
    };
    Rollbar2.info = function() {
      if (_instance) {
        return _instance.info.apply(_instance, arguments);
      } else {
        var maybeCallback = _getFirstFunction(arguments);
        handleUninitialized(maybeCallback);
      }
    };
    Rollbar2.prototype.warn = function() {
      var item = this._createItem(arguments);
      var uuid = item.uuid;
      this.client.warn(item);
      return { uuid };
    };
    Rollbar2.warn = function() {
      if (_instance) {
        return _instance.warn.apply(_instance, arguments);
      } else {
        var maybeCallback = _getFirstFunction(arguments);
        handleUninitialized(maybeCallback);
      }
    };
    Rollbar2.prototype.warning = function() {
      var item = this._createItem(arguments);
      var uuid = item.uuid;
      this.client.warning(item);
      return { uuid };
    };
    Rollbar2.warning = function() {
      if (_instance) {
        return _instance.warning.apply(_instance, arguments);
      } else {
        var maybeCallback = _getFirstFunction(arguments);
        handleUninitialized(maybeCallback);
      }
    };
    Rollbar2.prototype.error = function() {
      var item = this._createItem(arguments);
      var uuid = item.uuid;
      this.client.error(item);
      return { uuid };
    };
    Rollbar2.error = function() {
      if (_instance) {
        return _instance.error.apply(_instance, arguments);
      } else {
        var maybeCallback = _getFirstFunction(arguments);
        handleUninitialized(maybeCallback);
      }
    };
    Rollbar2.prototype._uncaughtError = function() {
      var item = this._createItem(arguments);
      item._isUncaught = true;
      var uuid = item.uuid;
      this.client.error(item);
      return { uuid };
    };
    Rollbar2.prototype.critical = function() {
      var item = this._createItem(arguments);
      var uuid = item.uuid;
      this.client.critical(item);
      return { uuid };
    };
    Rollbar2.critical = function() {
      if (_instance) {
        return _instance.critical.apply(_instance, arguments);
      } else {
        var maybeCallback = _getFirstFunction(arguments);
        handleUninitialized(maybeCallback);
      }
    };
    Rollbar2.prototype.buildJsonPayload = function(item) {
      return this.client.buildJsonPayload(item);
    };
    Rollbar2.buildJsonPayload = function() {
      if (_instance) {
        return _instance.buildJsonPayload.apply(_instance, arguments);
      } else {
        handleUninitialized();
      }
    };
    Rollbar2.prototype.sendJsonPayload = function(jsonPayload) {
      return this.client.sendJsonPayload(jsonPayload);
    };
    Rollbar2.sendJsonPayload = function() {
      if (_instance) {
        return _instance.sendJsonPayload.apply(_instance, arguments);
      } else {
        handleUninitialized();
      }
    };
    Rollbar2.prototype.wait = function(callback) {
      this.client.wait(callback);
    };
    Rollbar2.wait = function(callback) {
      if (_instance) {
        return _instance.wait(callback);
      } else {
        var maybeCallback = _getFirstFunction(arguments);
        handleUninitialized(maybeCallback);
      }
    };
    Rollbar2.prototype.errorHandler = function() {
      return function(err, request, response, next) {
        var cb = function(rollbarError) {
          if (rollbarError) {
            logger.error("Error reporting to rollbar, ignoring: " + rollbarError);
          }
          return next(err, request, response);
        };
        if (!err) {
          return next(err, request, response);
        }
        if (err instanceof Error) {
          return this.error(err, request, cb);
        }
        return this.error("Error: " + err, request, cb);
      }.bind(this);
    };
    Rollbar2.errorHandler = function() {
      if (_instance) {
        return _instance.errorHandler();
      } else {
        handleUninitialized();
      }
    };
    Rollbar2.prototype.lambdaHandler = function(handler, timeoutHandler) {
      if (handler.length <= 2) {
        return this.asyncLambdaHandler(handler, timeoutHandler);
      }
      return this.syncLambdaHandler(handler, timeoutHandler);
    };
    Rollbar2.prototype.asyncLambdaHandler = function(handler, timeoutHandler) {
      var self2 = this;
      var _timeoutHandler = function(event, context) {
        var message = "Function timed out";
        var custom = {
          originalEvent: event,
          originalRequestId: context.awsRequestId
        };
        self2.error(message, custom);
      };
      var shouldReportTimeouts = self2.options.captureLambdaTimeouts;
      return function rollbarAsyncLambdaHandler(event, context) {
        return new Promise(function(resolve, reject) {
          self2.lambdaContext = context;
          if (shouldReportTimeouts) {
            var timeoutCb = (timeoutHandler || _timeoutHandler).bind(null, event, context);
            self2.lambdaTimeoutHandle = setTimeout(timeoutCb, context.getRemainingTimeInMillis() - 1e3);
          }
          handler(event, context).then(function(resp) {
            self2.wait(function() {
              clearTimeout(self2.lambdaTimeoutHandle);
              resolve(resp);
            });
          }).catch(function(err) {
            self2.error(err);
            self2.wait(function() {
              clearTimeout(self2.lambdaTimeoutHandle);
              reject(err);
            });
          });
        });
      };
    };
    Rollbar2.prototype.syncLambdaHandler = function(handler, timeoutHandler) {
      var self2 = this;
      var _timeoutHandler = function(event, context, _cb) {
        var message = "Function timed out";
        var custom = {
          originalEvent: event,
          originalRequestId: context.awsRequestId
        };
        self2.error(message, custom);
      };
      var shouldReportTimeouts = self2.options.captureLambdaTimeouts;
      return function(event, context, callback) {
        self2.lambdaContext = context;
        if (shouldReportTimeouts) {
          var timeoutCb = (timeoutHandler || _timeoutHandler).bind(null, event, context, callback);
          self2.lambdaTimeoutHandle = setTimeout(timeoutCb, context.getRemainingTimeInMillis() - 1e3);
        }
        try {
          handler(event, context, function(err, resp) {
            if (err) {
              self2.error(err);
            }
            self2.wait(function() {
              clearTimeout(self2.lambdaTimeoutHandle);
              callback(err, resp);
            });
          });
        } catch (err) {
          self2.error(err);
          self2.wait(function() {
            clearTimeout(self2.lambdaTimeoutHandle);
            throw err;
          });
        }
      };
    };
    Rollbar2.lambdaHandler = function(handler) {
      if (_instance) {
        return _instance.lambdaHandler(handler);
      } else {
        handleUninitialized();
      }
    };
    function wrapCallback(r, f) {
      return function() {
        var err = arguments[0];
        if (err) {
          r.error(err);
        }
        return f.apply(this, arguments);
      };
    }
    Rollbar2.prototype.wrapCallback = function(f) {
      return wrapCallback(this, f);
    };
    Rollbar2.wrapCallback = function(f) {
      if (_instance) {
        return _instance.wrapCallback(f);
      } else {
        handleUninitialized();
      }
    };
    Rollbar2.prototype.captureEvent = function() {
      var event = _.createTelemetryEvent(arguments);
      return this.client.captureEvent(event.type, event.metadata, event.level);
    };
    Rollbar2.captureEvent = function() {
      if (_instance) {
        return _instance.captureEvent.apply(_instance, arguments);
      } else {
        handleUninitialized();
      }
    };
    Rollbar2.prototype.reportMessage = function(message, level, request, callback) {
      logger.log("reportMessage is deprecated");
      if (_.isFunction(this[level])) {
        return this[level](message, request, callback);
      } else {
        return this.error(message, request, callback);
      }
    };
    Rollbar2.reportMessage = function(message, level, request, callback) {
      if (_instance) {
        return _instance.reportMessage(message, level, request, callback);
      } else {
        handleUninitialized(callback);
      }
    };
    Rollbar2.prototype.reportMessageWithPayloadData = function(message, payloadData, request, callback) {
      logger.log("reportMessageWithPayloadData is deprecated");
      return this.error(message, request, payloadData, callback);
    };
    Rollbar2.reportMessageWithPayloadData = function(message, payloadData, request, callback) {
      if (_instance) {
        return _instance.reportMessageWithPayloadData(message, payloadData, request, callback);
      } else {
        handleUninitialized(callback);
      }
    };
    Rollbar2.prototype.handleError = function(err, request, callback) {
      logger.log("handleError is deprecated");
      return this.error(err, request, callback);
    };
    Rollbar2.handleError = function(err, request, callback) {
      if (_instance) {
        return _instance.handleError(err, request, callback);
      } else {
        handleUninitialized(callback);
      }
    };
    Rollbar2.prototype.handleErrorWithPayloadData = function(err, payloadData, request, callback) {
      logger.log("handleErrorWithPayloadData is deprecated");
      return this.error(err, request, payloadData, callback);
    };
    Rollbar2.handleErrorWithPayloadData = function(err, payloadData, request, callback) {
      if (_instance) {
        return _instance.handleErrorWithPayloadData(err, payloadData, request, callback);
      } else {
        handleUninitialized(callback);
      }
    };
    Rollbar2.handleUncaughtExceptions = function(accessToken, options) {
      if (_instance) {
        options = options || {};
        options.accessToken = accessToken;
        return _instance.configure(options);
      } else {
        handleUninitialized();
      }
    };
    Rollbar2.handleUnhandledRejections = function(accessToken, options) {
      if (_instance) {
        options = options || {};
        options.accessToken = accessToken;
        return _instance.configure(options);
      } else {
        handleUninitialized();
      }
    };
    Rollbar2.handleUncaughtExceptionsAndRejections = function(accessToken, options) {
      if (_instance) {
        options = options || {};
        options.accessToken = accessToken;
        return _instance.configure(options);
      } else {
        handleUninitialized();
      }
    };
    function addTransformsToNotifier(notifier) {
      notifier.addTransform(transforms.baseData).addTransform(transforms.handleItemWithError).addTransform(transforms.addBody).addTransform(sharedTransforms.addMessageWithError).addTransform(sharedTransforms.addTelemetryData).addTransform(transforms.addRequestData).addTransform(transforms.addLambdaData).addTransform(sharedTransforms.addConfigToPayload).addTransform(transforms.scrubPayload).addTransform(sharedTransforms.userTransform(logger)).addTransform(sharedTransforms.addConfiguredOptions).addTransform(sharedTransforms.addDiagnosticKeys).addTransform(sharedTransforms.itemToPayload);
    }
    function addPredicatesToQueue(queue) {
      queue.addPredicate(sharedPredicates.checkLevel).addPredicate(sharedPredicates.userCheckIgnore(logger)).addPredicate(sharedPredicates.urlIsNotBlockListed(logger)).addPredicate(sharedPredicates.urlIsSafeListed(logger)).addPredicate(sharedPredicates.messageIsIgnored(logger));
    }
    Rollbar2.prototype._createItem = function(args) {
      var requestKeys = ["headers", "protocol", "url", "method", "body", "route"];
      var item = _.createItem(args, logger, this, requestKeys, this.lambdaContext);
      if (item.err && item.notifier.locals) {
        item.localsMap = item.notifier.locals.currentLocalsMap();
      }
      return item;
    };
    function _getFirstFunction(args) {
      for (var i = 0, len = args.length; i < len; ++i) {
        if (_.isFunction(args[i])) {
          return args[i];
        }
      }
      return void 0;
    }
    Rollbar2.prototype.setupUnhandledCapture = function() {
      if (this.options.captureUncaught || this.options.handleUncaughtExceptions) {
        this.handleUncaughtExceptions();
      }
      if (this.options.captureUnhandledRejections || this.options.handleUnhandledRejections) {
        this.handleUnhandledRejections();
      }
    };
    Rollbar2.prototype.handleUncaughtExceptions = function() {
      var exitOnUncaught = !!this.options.exitOnUncaughtException;
      delete this.options.exitOnUncaughtException;
      addOrReplaceRollbarHandler("uncaughtException", function(err) {
        if (!this.options.captureUncaught && !this.options.handleUncaughtExceptions) {
          return;
        }
        this._uncaughtError(err, function(err2) {
          if (err2) {
            logger.error("Encountered error while handling an uncaught exception.");
            logger.error(err2);
          }
        });
        if (exitOnUncaught) {
          setImmediate(function() {
            this.wait(function() {
              process.exit(1);
            });
          }.bind(this));
        }
      }.bind(this));
    };
    Rollbar2.prototype.handleUnhandledRejections = function() {
      addOrReplaceRollbarHandler("unhandledRejection", function(reason) {
        if (!this.options.captureUnhandledRejections && !this.options.handleUnhandledRejections) {
          return;
        }
        this._uncaughtError(reason, function(err) {
          if (err) {
            logger.error("Encountered error while handling an uncaught exception.");
            logger.error(err);
          }
        });
      }.bind(this));
    };
    function addOrReplaceRollbarHandler(event, action) {
      var fn = function(a, b) {
        action(a, b);
      };
      fn._rollbarHandler = true;
      var listeners = process.listeners(event);
      var len = listeners.length;
      for (var i = 0; i < len; ++i) {
        if (listeners[i]._rollbarHandler) {
          process.removeListener(event, listeners[i]);
        }
      }
      process.on(event, fn);
    }
    function RollbarError(message, nested) {
      Error.call(this);
      Error.captureStackTrace(this, this.constructor);
      this.message = message;
      this.nested = nested;
      this.name = this.constructor.name;
    }
    util.inherits(RollbarError, Error);
    Rollbar2.Error = RollbarError;
    Rollbar2.defaultOptions = {
      host: os.hostname(),
      environment: process.env.NODE_ENV || "development",
      framework: "node-js",
      showReportedMessageTraces: false,
      notifier: {
        name: "node_rollbar",
        version: packageJson.version
      },
      scrubHeaders: packageJson.defaults.server.scrubHeaders,
      scrubFields: packageJson.defaults.server.scrubFields,
      addRequestData: null,
      reportLevel: packageJson.defaults.reportLevel,
      verbose: false,
      enabled: true,
      transmit: true,
      sendConfig: false,
      includeItemsInTelemetry: false,
      captureEmail: false,
      captureUsername: false,
      captureIp: true,
      captureLambdaTimeouts: true,
      ignoreDuplicateErrors: true,
      scrubRequestBody: true,
      autoInstrument: false
    };
    module2.exports = Rollbar2;
  }
});

// node_modules/@jedithepro/system-info/package.json
var require_package2 = __commonJS({
  "node_modules/@jedithepro/system-info/package.json"(exports, module2) {
    module2.exports = {
      name: "@jedithepro/system-info",
      version: "3.0.0",
      description: "System and OS information library for Node.js, and SystemInfo API.",
      license: "MIT",
      access: "public",
      author: {
        email: "pasit.sakorn@gmail.com",
        name: "JediThePro"
      },
      homepage: "",
      main: "./lib/index.js",
      bin: "./lib/cli.js",
      types: "./lib/index.d.ts",
      scripts: {
        clean: "rimraf dist",
        "test-bare": "npm run compile && mocha ./test/**/*.test.js",
        compile: "tsc",
        watch: "tsc -w",
        test: "nyc mocha --require ts-node/register --require source-map-support/register  ./test/**/*.test.ts",
        coverage: "nyc report --reporter=text-lcov"
      },
      files: [
        "lib/"
      ],
      keywords: [
        "system information",
        "sysinfo",
        "monitor",
        "monitoring",
        "os",
        "linux",
        "osx",
        "windows",
        "freebsd",
        "openbsd",
        "netbsd",
        "cpu",
        "cpuload",
        "physical cores",
        "logical cores",
        "processor",
        "cores",
        "threads",
        "socket type",
        "memory",
        "file system",
        "fsstats",
        "diskio",
        "block devices",
        "netstats",
        "network",
        "network interfaces",
        "network connections",
        "network stats",
        "iface",
        "processes",
        "users",
        "internet",
        "battery",
        "docker",
        "docker stats",
        "docker processes",
        "graphics",
        "graphic card",
        "graphic controller",
        "gpu",
        "display",
        "smart",
        "disk layout",
        "wifi",
        "wifinetworks",
        "virtual box",
        "virtualbox",
        "vm"
      ],
      repository: {
        type: "git",
        url: "https://github.com/JediThePro/systeminfo.git"
      },
      os: [
        "darwin",
        "linux",
        "win32",
        "freebsd",
        "openbsd",
        "netbsd",
        "sunos"
      ],
      engines: {
        node: ">=10.0.0"
      },
      devDependencies: {
        "@types/chai": "^4.1.7",
        "@types/mocha": "^5.2.5",
        "@types/node": "^10.12.18",
        chai: "^4.2.0",
        coveralls: "^3.0.2",
        mocha: "^5.2.0",
        nyc: "^13.1.0",
        rimraf: "^2.6.2",
        "source-map-support": "^0.5.9",
        "ts-node": "^7.0.1",
        typescript: "^3.2.2"
      },
      nyc: {
        extension: [
          ".js"
        ],
        include: [
          "lib/**"
        ],
        exclude: [
          "**/*.d.ts"
        ],
        reporter: [
          "html",
          "text"
        ],
        all: true
      }
    };
  }
});

// node_modules/@jedithepro/system-info/lib/util.js
var require_util2 = __commonJS({
  "node_modules/@jedithepro/system-info/lib/util.js"(exports) {
    "use strict";
    var os = require("os");
    var fs2 = require("fs");
    var spawn2 = require("child_process").spawn;
    var exec2 = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var util = require("util");
    var _platform = process.platform;
    var _linux = _platform === "linux";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _cores = 0;
    var wmicPath = "";
    var codepage = "";
    var execOptsWin = {
      windowsHide: true,
      maxBuffer: 1024 * 2e4,
      encoding: "UTF-8",
      env: util._extend({}, process.env, { LANG: "en_US.UTF-8" })
    };
    function toInt(value) {
      let result = parseInt(value, 10);
      if (isNaN(result)) {
        result = 0;
      }
      return result;
    }
    function isFunction(functionToCheck) {
      let getType = {};
      return functionToCheck && getType.toString.call(functionToCheck) === "[object Function]";
    }
    function unique(obj) {
      let uniques = [];
      let stringify = {};
      for (let i = 0; i < obj.length; i++) {
        let keys = Object.keys(obj[i]);
        keys.sort(function(a, b) {
          return a - b;
        });
        let str = "";
        for (let j = 0; j < keys.length; j++) {
          str += JSON.stringify(keys[j]);
          str += JSON.stringify(obj[i][keys[j]]);
        }
        if (!{}.hasOwnProperty.call(stringify, str)) {
          uniques.push(obj[i]);
          stringify[str] = true;
        }
      }
      return uniques;
    }
    function sortByKey(array, keys) {
      return array.sort(function(a, b) {
        let x = "";
        let y = "";
        keys.forEach(function(key) {
          x = x + a[key];
          y = y + b[key];
        });
        return x < y ? -1 : x > y ? 1 : 0;
      });
    }
    function cores() {
      if (_cores === 0) {
        _cores = os.cpus().length;
      }
      return _cores;
    }
    function getValue(lines, property, separator, trimmed) {
      separator = separator || ":";
      property = property.toLowerCase();
      trimmed = trimmed || false;
      for (let i = 0; i < lines.length; i++) {
        let line = lines[i].toLowerCase().replace(/\t/g, "");
        if (trimmed) {
          line = line.trim();
        }
        if (line.startsWith(property)) {
          const parts = lines[i].split(separator);
          if (parts.length >= 2) {
            parts.shift();
            return parts.join(separator).trim();
          } else {
            return "";
          }
        }
      }
      return "";
    }
    function decodeEscapeSequence(str, base) {
      base = base || 16;
      return str.replace(/\\x([0-9A-Fa-f]{2})/g, function() {
        return String.fromCharCode(parseInt(arguments[1], base));
      });
    }
    function detectSplit(str) {
      let seperator = "";
      let part = 0;
      str.split("").forEach((element) => {
        if (element >= "0" && element <= "9") {
          if (part === 1) {
            part++;
          }
        } else {
          if (part === 0) {
            part++;
          }
          if (part === 1) {
            seperator += element;
          }
        }
      });
      return seperator;
    }
    function parseTime(t, pmDesignator) {
      pmDesignator = pmDesignator || "";
      t = t.toUpperCase();
      let hour = 0;
      let min = 0;
      let splitter = detectSplit(t);
      let parts = t.split(splitter);
      if (parts.length >= 2) {
        if (parts[2]) {
          parts[1] += parts[2];
        }
        let isPM = parts[1] && parts[1].toLowerCase().indexOf("pm") > -1 || parts[1].toLowerCase().indexOf("p.m.") > -1 || parts[1].toLowerCase().indexOf("p. m.") > -1 || parts[1].toLowerCase().indexOf("n") > -1 || parts[1].toLowerCase().indexOf("ch") > -1 || parts[1].toLowerCase().indexOf("\xF6s") > -1 || pmDesignator && parts[1].toLowerCase().indexOf(pmDesignator) > -1;
        hour = parseInt(parts[0], 10);
        min = parseInt(parts[1], 10);
        hour = isPM && hour < 12 ? hour + 12 : hour;
        return ("0" + hour).substr(-2) + ":" + ("0" + min).substr(-2);
      }
    }
    function parseDateTime(dt, culture) {
      const result = {
        date: "",
        time: ""
      };
      culture = culture || {};
      let dateFormat = (culture.dateFormat || "").toLowerCase();
      let pmDesignator = culture.pmDesignator || "";
      const parts = dt.split(" ");
      if (parts[0]) {
        if (parts[0].indexOf("/") >= 0) {
          const dtparts = parts[0].split("/");
          if (dtparts.length === 3) {
            if (dtparts[0].length === 4) {
              result.date = dtparts[0] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[2]).substr(-2);
            } else if (dtparts[2].length === 2) {
              if (dateFormat.indexOf("/d/") > -1 || dateFormat.indexOf("/dd/") > -1) {
                result.date = "20" + dtparts[2] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[0]).substr(-2);
              } else {
                result.date = "20" + dtparts[2] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[0]).substr(-2);
              }
            } else {
              const isEN = dt.toLowerCase().indexOf("pm") > -1 || dt.toLowerCase().indexOf("p.m.") > -1 || dt.toLowerCase().indexOf("p. m.") > -1 || dt.toLowerCase().indexOf("am") > -1 || dt.toLowerCase().indexOf("a.m.") > -1 || dt.toLowerCase().indexOf("a. m.") > -1;
              if ((isEN || dateFormat.indexOf("/d/") > -1 || dateFormat.indexOf("/dd/") > -1) && dateFormat.indexOf("dd/") !== 0) {
                result.date = dtparts[2] + "-" + ("0" + dtparts[0]).substr(-2) + "-" + ("0" + dtparts[1]).substr(-2);
              } else {
                result.date = dtparts[2] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[0]).substr(-2);
              }
            }
          }
        }
        if (parts[0].indexOf(".") >= 0) {
          const dtparts = parts[0].split(".");
          if (dtparts.length === 3) {
            if (dateFormat.indexOf(".d.") > -1 || dateFormat.indexOf(".dd.") > -1) {
              result.date = dtparts[2] + "-" + ("0" + dtparts[0]).substr(-2) + "-" + ("0" + dtparts[1]).substr(-2);
            } else {
              result.date = dtparts[2] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[0]).substr(-2);
            }
          }
        }
        if (parts[0].indexOf("-") >= 0) {
          const dtparts = parts[0].split("-");
          if (dtparts.length === 3) {
            result.date = dtparts[0] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[2]).substr(-2);
          }
        }
      }
      if (parts[1]) {
        parts.shift();
        let time = parts.join(" ");
        result.time = parseTime(time, pmDesignator);
      }
      return result;
    }
    function parseHead(head, rights) {
      let space = rights > 0;
      let count = 1;
      let from = 0;
      let to = 0;
      let result = [];
      for (let i2 = 0; i2 < head.length; i2++) {
        if (count <= rights) {
          if (/\s/.test(head[i2]) && !space) {
            to = i2 - 1;
            result.push({
              from,
              to: to + 1,
              cap: head.substring(from, to + 1)
            });
            from = to + 2;
            count++;
          }
          space = head[i2] === " ";
        } else {
          if (!/\s/.test(head[i2]) && space) {
            to = i2 - 1;
            if (from < to) {
              result.push({
                from,
                to,
                cap: head.substring(from, to)
              });
            }
            from = to + 1;
            count++;
          }
          space = head[i2] === " ";
        }
      }
      to = 1e3;
      result.push({
        from,
        to,
        cap: head.substring(from, to)
      });
      let len = result.length;
      for (var i = 0; i < len; i++) {
        if (result[i].cap.replace(/\s/g, "").length === 0) {
          if (i + 1 < len) {
            result[i].to = result[i + 1].to;
            result[i].cap = result[i].cap + result[i + 1].cap;
            result.splice(i + 1, 1);
            len = len - 1;
          }
        }
      }
      return result;
    }
    function findObjectByKey(array, key, value) {
      for (let i = 0; i < array.length; i++) {
        if (array[i][key] === value) {
          return i;
        }
      }
      return -1;
    }
    function getWmic() {
      if (os.type() === "Windows_NT" && !wmicPath) {
        wmicPath = process.env.WINDIR + "\\system32\\wbem\\wmic.exe";
        if (!fs2.existsSync(wmicPath)) {
          try {
            const wmicPathArray = execSync("WHERE WMIC").toString().split("\r\n");
            if (wmicPathArray && wmicPathArray.length) {
              wmicPath = wmicPathArray[0];
            } else {
              wmicPath = "wmic";
            }
          } catch (e) {
            wmicPath = "wmic";
          }
        }
      }
      return wmicPath;
    }
    function wmic(command, options) {
      options = options || execOptsWin;
      return new Promise((resolve) => {
        process.nextTick(() => {
          try {
            exec2(process.env.WINDIR + "\\system32\\chcp.com 65001 | " + getWmic() + " " + command, options, function(error, stdout) {
              resolve(stdout, error);
            }).stdin.end();
          } catch (e) {
            resolve("", e);
          }
        });
      });
    }
    function getVboxmanage() {
      return _windows ? process.env.VBOX_INSTALL_PATH || process.env.VBOX_MSI_INSTALL_PATH + '\\VBoxManage.exe" ' : "vboxmanage";
    }
    function powerShell(cmd) {
      let result = "";
      return new Promise((resolve) => {
        process.nextTick(() => {
          try {
            const child = spawn2("powershell.exe", ["-NoLogo", "-InputFormat", "Text", "-NoExit", "-ExecutionPolicy", "Unrestricted", "-Command", "-"], {
              stdio: "pipe",
              windowsHide: true,
              maxBuffer: 1024 * 2e4,
              encoding: "UTF-8",
              env: util._extend({}, process.env, { LANG: "en_US.UTF-8" })
            });
            if (child && !child.pid) {
              child.on("error", function() {
                resolve(result);
              });
            }
            if (child && child.pid) {
              child.stdout.on("data", function(data) {
                result = result + data.toString("utf8");
              });
              child.stderr.on("data", function() {
                child.kill();
                resolve(result);
              });
              child.on("close", function() {
                child.kill();
                resolve(result);
              });
              child.on("error", function() {
                child.kill();
                resolve(result);
              });
              try {
                child.stdin.write(cmd + os.EOL);
                child.stdin.write("exit" + os.EOL);
                child.stdin.end();
              } catch (e) {
                child.kill();
                resolve(result);
              }
            } else {
              resolve(result);
            }
          } catch (e) {
            resolve(result);
          }
        });
      });
    }
    function getCodepage() {
      if (_windows) {
        if (!codepage) {
          try {
            const stdout = execSync("chcp");
            const lines = stdout.toString().split("\r\n");
            const parts = lines[0].split(":");
            codepage = parts.length > 1 ? parts[1].replace(".", "") : "";
          } catch (err) {
            codepage = "437";
          }
        }
        return codepage;
      }
      if (_linux || _darwin || _freebsd || _openbsd || _netbsd) {
        if (!codepage) {
          try {
            const stdout = execSync("echo $LANG");
            const lines = stdout.toString().split("\r\n");
            const parts = lines[0].split(".");
            codepage = parts.length > 1 ? parts[1].trim() : "";
            if (!codepage) {
              codepage = "UTF-8";
            }
          } catch (err) {
            codepage = "UTF-8";
          }
        }
        return codepage;
      }
    }
    function isRaspberry() {
      const PI_MODEL_NO = [
        "BCM2708",
        "BCM2709",
        "BCM2710",
        "BCM2835",
        "BCM2837B0"
      ];
      let cpuinfo = [];
      try {
        cpuinfo = fs2.readFileSync("/proc/cpuinfo", { encoding: "utf8" }).split("\n");
      } catch (e) {
        return false;
      }
      const hardware = getValue(cpuinfo, "hardware");
      return hardware && PI_MODEL_NO.indexOf(hardware) > -1;
    }
    function isRaspbian() {
      let osrelease = [];
      try {
        osrelease = fs2.readFileSync("/etc/os-release", { encoding: "utf8" }).split("\n");
      } catch (e) {
        return false;
      }
      const id = getValue(osrelease, "id");
      return id && id.indexOf("raspbian") > -1;
    }
    function execWin(cmd, opts, callback) {
      if (!callback) {
        callback = opts;
        opts = execOptsWin;
      }
      let newCmd = "chcp 65001 > nul && cmd /C " + cmd + " && chcp " + codepage + " > nul";
      exec2(newCmd, opts, function(error, stdout) {
        callback(error, stdout);
      });
    }
    function darwinXcodeExists() {
      const cmdLineToolsExists = fs2.existsSync("/Library/Developer/CommandLineTools/usr/bin/");
      const xcodeAppExists = fs2.existsSync("/Applications/Xcode.app/Contents/Developer/Tools");
      const xcodeExists = fs2.existsSync("/Library/Developer/Xcode/");
      return cmdLineToolsExists || xcodeExists || xcodeAppExists;
    }
    function nanoSeconds() {
      const time = process.hrtime();
      if (!Array.isArray(time) || time.length !== 2) {
        return 0;
      }
      return +time[0] * 1e9 + +time[1];
    }
    function countUniqueLines(lines, startingWith) {
      startingWith = startingWith || "";
      const uniqueLines = [];
      lines.forEach((line) => {
        if (line.startsWith(startingWith)) {
          if (uniqueLines.indexOf(line) === -1) {
            uniqueLines.push(line);
          }
        }
      });
      return uniqueLines.length;
    }
    function countLines(lines, startingWith) {
      startingWith = startingWith || "";
      const uniqueLines = [];
      lines.forEach((line) => {
        if (line.startsWith(startingWith)) {
          uniqueLines.push(line);
        }
      });
      return uniqueLines.length;
    }
    function sanitizeShellString(str) {
      let result = str || "";
      result = result.replace(/>/g, "");
      result = result.replace(/</g, "");
      result = result.replace(/\*/g, "");
      result = result.replace(/\?/g, "");
      result = result.replace(/\[/g, "");
      result = result.replace(/\]/g, "");
      result = result.replace(/\|/g, "");
      result = result.replace(/\`/g, "");
      result = result.replace(/\$/g, "");
      result = result.replace(/;/g, "");
      result = result.replace(/&/g, "");
      result = result.replace(/\)/g, "");
      result = result.replace(/\(/g, "");
      result = result.replace(/\$/g, "");
      result = result.replace(/#/g, "");
      result = result.replace(/\\/g, "");
      result = result.replace(/\t/g, "");
      result = result.replace(/\n/g, "");
      result = result.replace(/\"/g, "");
      return result;
    }
    function hex2bin(hex) {
      return ("00000000" + parseInt(hex, 16).toString(2)).substr(-8);
    }
    function decodePiCpuinfo(lines) {
      const oldRevisionCodes = {
        "0002": {
          type: "B",
          revision: "1.0",
          memory: 256,
          manufacturer: "Egoman",
          processor: "BCM2835"
        },
        "0003": {
          type: "B",
          revision: "1.0",
          memory: 256,
          manufacturer: "Egoman",
          processor: "BCM2835"
        },
        "0004": {
          type: "B",
          revision: "2.0",
          memory: 256,
          manufacturer: "Sony UK",
          processor: "BCM2835"
        },
        "0005": {
          type: "B",
          revision: "2.0",
          memory: 256,
          manufacturer: "Qisda",
          processor: "BCM2835"
        },
        "0006": {
          type: "B",
          revision: "2.0",
          memory: 256,
          manufacturer: "Egoman",
          processor: "BCM2835"
        },
        "0007": {
          type: "A",
          revision: "2.0",
          memory: 256,
          manufacturer: "Egoman",
          processor: "BCM2835"
        },
        "0008": {
          type: "A",
          revision: "2.0",
          memory: 256,
          manufacturer: "Sony UK",
          processor: "BCM2835"
        },
        "0009": {
          type: "A",
          revision: "2.0",
          memory: 256,
          manufacturer: "Qisda",
          processor: "BCM2835"
        },
        "000d": {
          type: "B",
          revision: "2.0",
          memory: 512,
          manufacturer: "Egoman",
          processor: "BCM2835"
        },
        "000e": {
          type: "B",
          revision: "2.0",
          memory: 512,
          manufacturer: "Sony UK",
          processor: "BCM2835"
        },
        "000f": {
          type: "B",
          revision: "2.0",
          memory: 512,
          manufacturer: "Egoman",
          processor: "BCM2835"
        },
        "0010": {
          type: "B+",
          revision: "1.2",
          memory: 512,
          manufacturer: "Sony UK",
          processor: "BCM2835"
        },
        "0011": {
          type: "CM1",
          revision: "1.0",
          memory: 512,
          manufacturer: "Sony UK",
          processor: "BCM2835"
        },
        "0012": {
          type: "A+",
          revision: "1.1",
          memory: 256,
          manufacturer: "Sony UK",
          processor: "BCM2835"
        },
        "0013": {
          type: "B+",
          revision: "1.2",
          memory: 512,
          manufacturer: "Embest",
          processor: "BCM2835"
        },
        "0014": {
          type: "CM1",
          revision: "1.0",
          memory: 512,
          manufacturer: "Embest",
          processor: "BCM2835"
        },
        "0015": {
          type: "A+",
          revision: "1.1",
          memory: 256,
          manufacturer: "512MB	Embest",
          processor: "BCM2835"
        }
      };
      const processorList = [
        "BMC2835",
        "BMC2836",
        "BMC2837",
        "BMC2711"
      ];
      const manufacturerList = [
        "Sony UK",
        "Egoman",
        "Embest",
        "Sony Japan",
        "Embest",
        "Stadium"
      ];
      const typeList = {
        "00": "A",
        "01": "B",
        "02": "A+",
        "03": "B+",
        "04": "2B",
        "05": "Alpha (early prototype)",
        "06": "CM1",
        "08": "3B",
        "09": "Zero",
        "0a": "CM3",
        "0c": "Zero W",
        "0d": "3B+",
        "0e": "3A+",
        "0f": "Internal use only",
        "10": "CM3+",
        "11": "4B",
        "13": "400",
        "14": "CM4"
      };
      const revisionCode = getValue(lines, "revision", ":", true);
      const model = getValue(lines, "model:", ":", true);
      const serial = getValue(lines, "serial", ":", true);
      let result = {};
      if (oldRevisionCodes.hasOwnProperty(revisionCode)) {
        result = {
          model,
          serial,
          revisionCode,
          memory: oldRevisionCodes[revisionCode].memory,
          manufacturer: oldRevisionCodes[revisionCode].manufacturer,
          processor: oldRevisionCodes[revisionCode].processor,
          type: oldRevisionCodes[revisionCode].type,
          revision: oldRevisionCodes[revisionCode].revision
        };
      } else {
        const revision = ("00000000" + getValue(lines, "revision", ":", true).toLowerCase()).substr(-8);
        const memSizeCode = parseInt(hex2bin(revision.substr(2, 1)).substr(5, 3), 2) || 0;
        const manufacturer = manufacturerList[parseInt(revision.substr(3, 1), 10)];
        const processor = processorList[parseInt(revision.substr(4, 1), 10)];
        const typeCode = revision.substr(5, 2);
        result = {
          model,
          serial,
          revisionCode,
          memory: 256 * Math.pow(2, memSizeCode),
          manufacturer,
          processor,
          type: typeList.hasOwnProperty(typeCode) ? typeList[typeCode] : "",
          revision: "1." + revision.substr(7, 1)
        };
      }
      return result;
    }
    function noop() {
    }
    exports.toInt = toInt;
    exports.execOptsWin = execOptsWin;
    exports.getCodepage = getCodepage;
    exports.execWin = execWin;
    exports.isFunction = isFunction;
    exports.unique = unique;
    exports.sortByKey = sortByKey;
    exports.cores = cores;
    exports.getValue = getValue;
    exports.decodeEscapeSequence = decodeEscapeSequence;
    exports.parseDateTime = parseDateTime;
    exports.parseHead = parseHead;
    exports.findObjectByKey = findObjectByKey;
    exports.getWmic = getWmic;
    exports.wmic = wmic;
    exports.darwinXcodeExists = darwinXcodeExists;
    exports.getVboxmanage = getVboxmanage;
    exports.powerShell = powerShell;
    exports.nanoSeconds = nanoSeconds;
    exports.countUniqueLines = countUniqueLines;
    exports.countLines = countLines;
    exports.noop = noop;
    exports.isRaspberry = isRaspberry;
    exports.isRaspbian = isRaspbian;
    exports.sanitizeShellString = sanitizeShellString;
    exports.decodePiCpuinfo = decodePiCpuinfo;
  }
});

// node_modules/@jedithepro/system-info/lib/system.js
var require_system = __commonJS({
  "node_modules/@jedithepro/system-info/lib/system.js"(exports) {
    "use strict";
    var exec2 = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var fs2 = require("fs");
    var util = require_util2();
    var _platform = process.platform;
    var _linux = _platform === "linux";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    function system(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = {
            manufacturer: "",
            model: "Computer",
            version: "",
            serial: "-",
            uuid: "-",
            sku: "-"
          };
          if (_linux || _freebsd || _openbsd || _netbsd) {
            exec2("export LC_ALL=C; dmidecode -t system 2>/dev/null; unset LC_ALL", function(error, stdout) {
              let lines = stdout.toString().split("\n");
              result.manufacturer = util.getValue(lines, "manufacturer");
              result.model = util.getValue(lines, "product name");
              result.version = util.getValue(lines, "version");
              result.serial = util.getValue(lines, "serial number");
              result.uuid = util.getValue(lines, "uuid");
              result.sku = util.getValue(lines, "sku number");
              const cmd = `echo -n "product_name: "; cat /sys/devices/virtual/dmi/id/product_name 2>/dev/null; echo;
            echo -n "product_serial: "; cat /sys/devices/virtual/dmi/id/product_serial 2>/dev/null; echo;
            echo -n "product_uuid: "; cat /sys/devices/virtual/dmi/id/product_uuid 2>/dev/null; echo;
            echo -n "product_version: "; cat /sys/devices/virtual/dmi/id/product_version 2>/dev/null; echo;
            echo -n "sys_vendor: "; cat /sys/devices/virtual/dmi/id/sys_vendor 2>/dev/null; echo;`;
              try {
                lines = execSync(cmd).toString().split("\n");
                result.manufacturer = result.manufacturer === "" ? util.getValue(lines, "sys_vendor") : result.manufacturer;
                result.model = result.model === "" ? util.getValue(lines, "product_name") : result.model;
                result.version = result.version === "" ? util.getValue(lines, "product_version") : result.version;
                result.serial = result.serial === "" ? util.getValue(lines, "product_serial") : result.serial;
                result.uuid = result.uuid === "" ? util.getValue(lines, "product_uuid") : result.uuid;
              } catch (e) {
                util.noop();
              }
              if (!result.serial || result.serial.toLowerCase().indexOf("o.e.m.") !== -1)
                result.serial = "-";
              if (!result.manufacturer || result.manufacturer.toLowerCase().indexOf("o.e.m.") !== -1)
                result.manufacturer = "";
              if (!result.model || result.model.toLowerCase().indexOf("o.e.m.") !== -1)
                result.model = "Computer";
              if (!result.version || result.version.toLowerCase().indexOf("o.e.m.") !== -1)
                result.version = "";
              if (!result.sku || result.sku.toLowerCase().indexOf("o.e.m.") !== -1)
                result.sku = "-";
              if (fs2.existsSync("/.dockerenv") || fs2.existsSync("/.dockerinit")) {
                result.model = "Docker Container";
              }
              if (result.manufacturer === "" && result.model === "Computer" && result.version === "") {
                exec2('dmesg | grep -i virtual | grep -iE "vmware|qemu|kvm|xen"', function(error2, stdout2) {
                  if (!error2) {
                    let lines2 = stdout2.toString().split("\n");
                    if (lines2.length > 0)
                      result.model = "Virtual machine";
                  }
                  if (result.manufacturer === "" && result.model === "Computer" && result.version === "") {
                    fs2.readFile("/proc/cpuinfo", function(error3, stdout3) {
                      if (!error3) {
                        let lines2 = stdout3.toString().split("\n");
                        result.model = util.getValue(lines2, "hardware", ":", true).toUpperCase();
                        result.version = util.getValue(lines2, "revision", ":", true).toLowerCase();
                        result.serial = util.getValue(lines2, "serial", ":", true);
                        const model = util.getValue(lines2, "model:", ":", true);
                        if ((result.model === "BCM2835" || result.model === "BCM2708" || result.model === "BCM2709" || result.model === "BCM2835" || result.model === "BCM2837") && model.toLowerCase().indexOf("raspberry") >= 0) {
                          const rPIRevision = util.decodePiCpuinfo(lines2);
                          result.model = rPIRevision.model;
                          result.version = rPIRevision.revisionCode;
                          result.manufacturer = "Raspberry Pi Foundation";
                          result.raspberry = {
                            manufacturer: rPIRevision.manufacturer,
                            processor: rPIRevision.processor,
                            type: rPIRevision.type,
                            revision: rPIRevision.revision
                          };
                        }
                      }
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                    });
                  } else {
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  }
                });
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            });
          }
          if (_darwin) {
            exec2("ioreg -c IOPlatformExpertDevice -d 2", function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().replace(/[<>"]/g, "").split("\n");
                result.manufacturer = util.getValue(lines, "manufacturer", "=", true);
                result.model = util.getValue(lines, "model", "=", true);
                result.version = util.getValue(lines, "version", "=", true);
                result.serial = util.getValue(lines, "ioplatformserialnumber", "=", true);
                result.uuid = util.getValue(lines, "ioplatformuuid", "=", true);
                result.sku = util.getValue(lines, "board-id", "=", true);
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_sunos) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_windows) {
            try {
              util.wmic("csproduct get /value").then((stdout, error) => {
                if (!error) {
                  let lines = stdout.split("\r\n");
                  result.manufacturer = util.getValue(lines, "vendor", "=");
                  result.model = util.getValue(lines, "name", "=");
                  result.version = util.getValue(lines, "version", "=");
                  result.serial = util.getValue(lines, "identifyingnumber", "=");
                  result.uuid = util.getValue(lines, "uuid", "=");
                  util.wmic("/namespace:\\\\root\\wmi path MS_SystemInformation get /value").then((stdout2, error2) => {
                    if (!error2) {
                      let lines2 = stdout2.split("\r\n");
                      result.sku = util.getValue(lines2, "systemsku", "=");
                    }
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  });
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.system = system;
    function bios(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = {
            vendor: "",
            version: "",
            releaseDate: "",
            revision: ""
          };
          let cmd = "";
          if (_linux || _freebsd || _openbsd || _netbsd) {
            if (process.arch === "arm") {
              cmd = "cat /proc/cpuinfo | grep Serial";
            } else {
              cmd = "export LC_ALL=C; dmidecode --type 0 2>/dev/null; unset LC_ALL";
            }
            exec2(cmd, function(error, stdout) {
              let lines = stdout.toString().split("\n");
              result.vendor = util.getValue(lines, "Vendor");
              result.version = util.getValue(lines, "Version");
              let datetime = util.getValue(lines, "Release Date");
              result.releaseDate = util.parseDateTime(datetime).date;
              result.revision = util.getValue(lines, "BIOS Revision");
              const cmd2 = `echo -n "bios_date: "; cat /sys/devices/virtual/dmi/id/bios_date 2>/dev/null; echo;
            echo -n "bios_vendor: "; cat /sys/devices/virtual/dmi/id/bios_vendor 2>/dev/null; echo;
            echo -n "bios_version: "; cat /sys/devices/virtual/dmi/id/bios_version 2>/dev/null; echo;`;
              try {
                lines = execSync(cmd2).toString().split("\n");
                result.vendor = !result.vendor ? util.getValue(lines, "bios_vendor") : result.vendor;
                result.version = !result.version ? util.getValue(lines, "bios_version") : result.version;
                datetime = util.getValue(lines, "bios_date");
                result.releaseDate = !result.releaseDate ? util.parseDateTime(datetime).date : result.releaseDate;
              } catch (e) {
                util.noop();
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_darwin) {
            result.vendor = "Apple Inc.";
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_sunos) {
            result.vendor = "Sun Microsystems";
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_windows) {
            try {
              util.wmic("bios get /value").then((stdout, error) => {
                if (!error) {
                  let lines = stdout.toString().split("\r\n");
                  const description = util.getValue(lines, "description", "=");
                  if (description.indexOf(" Version ") !== -1) {
                    result.vendor = description.split(" Version ")[0].trim();
                    result.version = description.split(" Version ")[1].trim();
                  } else if (description.indexOf(" Ver: ") !== -1) {
                    result.vendor = util.getValue(lines, "manufacturer", "=");
                    result.version = description.split(" Ver: ")[1].trim();
                  } else {
                    result.vendor = util.getValue(lines, "manufacturer", "=");
                    result.version = util.getValue(lines, "version", "=");
                  }
                  result.releaseDate = util.getValue(lines, "releasedate", "=");
                  if (result.releaseDate.length >= 10) {
                    result.releaseDate = result.releaseDate.substr(0, 4) + "-" + result.releaseDate.substr(4, 2) + "-" + result.releaseDate.substr(6, 2);
                  }
                  result.revision = util.getValue(lines, "buildnumber", "=");
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.bios = bios;
    function baseboard(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = {
            manufacturer: "",
            model: "",
            version: "",
            serial: "-",
            assetTag: "-"
          };
          let cmd = "";
          if (_linux || _freebsd || _openbsd || _netbsd) {
            if (process.arch === "arm") {
              cmd = "cat /proc/cpuinfo | grep Serial";
            } else {
              cmd = "export LC_ALL=C; dmidecode -t 2 2>/dev/null; unset LC_ALL";
            }
            exec2(cmd, function(error, stdout) {
              let lines = stdout.toString().split("\n");
              result.manufacturer = util.getValue(lines, "Manufacturer");
              result.model = util.getValue(lines, "Product Name");
              result.version = util.getValue(lines, "Version");
              result.serial = util.getValue(lines, "Serial Number");
              result.assetTag = util.getValue(lines, "Asset Tag");
              const cmd2 = `echo -n "board_asset_tag: "; cat /sys/devices/virtual/dmi/id/board_asset_tag 2>/dev/null; echo;
            echo -n "board_name: "; cat /sys/devices/virtual/dmi/id/board_name 2>/dev/null; echo;
            echo -n "board_serial: "; cat /sys/devices/virtual/dmi/id/board_serial 2>/dev/null; echo;
            echo -n "board_vendor: "; cat /sys/devices/virtual/dmi/id/board_vendor 2>/dev/null; echo;
            echo -n "board_version: "; cat /sys/devices/virtual/dmi/id/board_version 2>/dev/null; echo;`;
              try {
                lines = execSync(cmd2).toString().split("\n");
                result.manufacturer = !result.manufacturer ? util.getValue(lines, "board_vendor") : result.manufacturer;
                result.model = !result.model ? util.getValue(lines, "board_name") : result.model;
                result.version = !result.version ? util.getValue(lines, "board_version") : result.version;
                result.serial = !result.serial ? util.getValue(lines, "board_serial") : result.serial;
                result.assetTag = !result.assetTag ? util.getValue(lines, "board_asset_tag") : result.assetTag;
              } catch (e) {
                util.noop();
              }
              if (result.serial.toLowerCase().indexOf("o.e.m.") !== -1)
                result.serial = "-";
              if (result.assetTag.toLowerCase().indexOf("o.e.m.") !== -1)
                result.assetTag = "-";
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_darwin) {
            exec2("ioreg -c IOPlatformExpertDevice -d 2", function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().replace(/[<>"]/g, "").split("\n");
                result.manufacturer = util.getValue(lines, "manufacturer", "=", true);
                result.model = util.getValue(lines, "model", "=", true);
                result.version = util.getValue(lines, "version", "=", true);
                result.serial = util.getValue(lines, "ioplatformserialnumber", "=", true);
                result.assetTag = util.getValue(lines, "board-id", "=", true);
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_sunos) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_windows) {
            try {
              util.wmic("baseboard get /value").then((stdout, error) => {
                if (!error) {
                  let lines = stdout.toString().split("\r\n");
                  result.manufacturer = util.getValue(lines, "manufacturer", "=");
                  result.model = util.getValue(lines, "model", "=");
                  if (!result.model) {
                    result.model = util.getValue(lines, "product", "=");
                  }
                  result.version = util.getValue(lines, "version", "=");
                  result.serial = util.getValue(lines, "serialnumber", "=");
                  result.assetTag = util.getValue(lines, "partnumber", "=");
                  if (!result.assetTag) {
                    result.assetTag = util.getValue(lines, "sku", "=");
                  }
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.baseboard = baseboard;
    function chassis(callback) {
      const chassisTypes = [
        "Other",
        "Unknown",
        "Desktop",
        "Low Profile Desktop",
        "Pizza Box",
        "Mini Tower",
        "Tower",
        "Portable",
        "Laptop",
        "Notebook",
        "Hand Held",
        "Docking Station",
        "All in One",
        "Sub Notebook",
        "Space-Saving",
        "Lunch Box",
        "Main System Chassis",
        "Expansion Chassis",
        "SubChassis",
        "Bus Expansion Chassis",
        "Peripheral Chassis",
        "Storage Chassis",
        "Rack Mount Chassis",
        "Sealed-Case PC",
        "Multi-System Chassis",
        "Compact PCI",
        "Advanced TCA",
        "Blade",
        "Blade Enclosure",
        "Tablet",
        "Concertible",
        "Detachable",
        "IoT Gateway ",
        "Embedded PC",
        "Mini PC",
        "Stick PC"
      ];
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = {
            manufacturer: "",
            model: "",
            type: "",
            version: "",
            serial: "-",
            assetTag: "-",
            sku: ""
          };
          if (_linux || _freebsd || _openbsd || _netbsd) {
            const cmd = `echo -n "chassis_asset_tag: "; cat /sys/devices/virtual/dmi/id/chassis_asset_tag 2>/dev/null; echo;
            echo -n "chassis_serial: "; cat /sys/devices/virtual/dmi/id/chassis_serial 2>/dev/null; echo;
            echo -n "chassis_type: "; cat /sys/devices/virtual/dmi/id/chassis_type 2>/dev/null; echo;
            echo -n "chassis_vendor: "; cat /sys/devices/virtual/dmi/id/chassis_vendor 2>/dev/null; echo;
            echo -n "chassis_version: "; cat /sys/devices/virtual/dmi/id/chassis_version 2>/dev/null; echo;`;
            exec2(cmd, function(error, stdout) {
              let lines = stdout.toString().split("\n");
              result.manufacturer = util.getValue(lines, "chassis_vendor");
              const ctype = parseInt(util.getValue(lines, "chassis_type").replace(/\D/g, ""));
              result.type = ctype && !isNaN(ctype) && ctype < chassisTypes.length ? chassisTypes[ctype - 1] : "";
              result.version = util.getValue(lines, "chassis_version");
              result.serial = util.getValue(lines, "chassis_serial");
              result.assetTag = util.getValue(lines, "chassis_asset_tag");
              if (result.serial.toLowerCase().indexOf("o.e.m.") !== -1)
                result.serial = "-";
              if (result.assetTag.toLowerCase().indexOf("o.e.m.") !== -1)
                result.assetTag = "-";
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_darwin) {
            exec2("ioreg -c IOPlatformExpertDevice -d 2", function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().replace(/[<>"]/g, "").split("\n");
                result.manufacturer = util.getValue(lines, "manufacturer", "=", true);
                result.model = util.getValue(lines, "model", "=", true);
                result.version = util.getValue(lines, "version", "=", true);
                result.serial = util.getValue(lines, "ioplatformserialnumber", "=", true);
                result.assetTag = util.getValue(lines, "board-id", "=", true);
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_sunos) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_windows) {
            try {
              util.wmic("path Win32_SystemEnclosure get /value").then((stdout, error) => {
                if (!error) {
                  let lines = stdout.toString().split("\r\n");
                  result.manufacturer = util.getValue(lines, "manufacturer", "=");
                  result.model = util.getValue(lines, "model", "=");
                  const ctype = parseInt(util.getValue(lines, "ChassisTypes", "=").replace(/\D/g, ""));
                  result.type = ctype && !isNaN(ctype) && ctype < chassisTypes.length ? chassisTypes[ctype - 1] : "";
                  result.version = util.getValue(lines, "version", "=");
                  result.serial = util.getValue(lines, "serialnumber", "=");
                  result.assetTag = util.getValue(lines, "partnumber", "=");
                  result.sku = util.getValue(lines, "sku", "=");
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.chassis = chassis;
  }
});

// node_modules/@jedithepro/system-info/lib/osinfo.js
var require_osinfo = __commonJS({
  "node_modules/@jedithepro/system-info/lib/osinfo.js"(exports) {
    "use strict";
    var os = require("os");
    var exec2 = require("child_process").exec;
    var util = require_util2();
    var fs2 = require("fs");
    var _platform = process.platform;
    var _linux = _platform === "linux";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    var NOT_SUPPORTED = "not supported";
    function time() {
      let t = new Date().toString().split(" ");
      return {
        current: Date.now(),
        uptime: os.uptime(),
        timezone: t.length >= 7 ? t[5] : "",
        timezoneName: t.length >= 7 ? t.slice(6).join(" ").replace(/\(/g, "").replace(/\)/g, "") : ""
      };
    }
    exports.time = time;
    function getLogoFile(distro) {
      distro = distro || "";
      distro = distro.toLowerCase();
      let result = _platform;
      if (_windows) {
        result = "windows";
      } else if (distro.indexOf("mac os") !== -1) {
        result = "apple";
      } else if (distro.indexOf("arch") !== -1) {
        result = "arch";
      } else if (distro.indexOf("centos") !== -1) {
        result = "centos";
      } else if (distro.indexOf("coreos") !== -1) {
        result = "coreos";
      } else if (distro.indexOf("debian") !== -1) {
        result = "debian";
      } else if (distro.indexOf("deepin") !== -1) {
        result = "deepin";
      } else if (distro.indexOf("elementary") !== -1) {
        result = "elementary";
      } else if (distro.indexOf("fedora") !== -1) {
        result = "fedora";
      } else if (distro.indexOf("gentoo") !== -1) {
        result = "gentoo";
      } else if (distro.indexOf("mageia") !== -1) {
        result = "mageia";
      } else if (distro.indexOf("mandriva") !== -1) {
        result = "mandriva";
      } else if (distro.indexOf("manjaro") !== -1) {
        result = "manjaro";
      } else if (distro.indexOf("mint") !== -1) {
        result = "mint";
      } else if (distro.indexOf("mx") !== -1) {
        result = "mx";
      } else if (distro.indexOf("openbsd") !== -1) {
        result = "openbsd";
      } else if (distro.indexOf("freebsd") !== -1) {
        result = "freebsd";
      } else if (distro.indexOf("opensuse") !== -1) {
        result = "opensuse";
      } else if (distro.indexOf("pclinuxos") !== -1) {
        result = "pclinuxos";
      } else if (distro.indexOf("puppy") !== -1) {
        result = "puppy";
      } else if (distro.indexOf("raspbian") !== -1) {
        result = "raspbian";
      } else if (distro.indexOf("reactos") !== -1) {
        result = "reactos";
      } else if (distro.indexOf("redhat") !== -1) {
        result = "redhat";
      } else if (distro.indexOf("slackware") !== -1) {
        result = "slackware";
      } else if (distro.indexOf("sugar") !== -1) {
        result = "sugar";
      } else if (distro.indexOf("steam") !== -1) {
        result = "steam";
      } else if (distro.indexOf("suse") !== -1) {
        result = "suse";
      } else if (distro.indexOf("mate") !== -1) {
        result = "ubuntu-mate";
      } else if (distro.indexOf("lubuntu") !== -1) {
        result = "lubuntu";
      } else if (distro.indexOf("xubuntu") !== -1) {
        result = "xubuntu";
      } else if (distro.indexOf("ubuntu") !== -1) {
        result = "ubuntu";
      } else if (distro.indexOf("solaris") !== -1) {
        result = "solaris";
      } else if (distro.indexOf("tails") !== -1) {
        result = "tails";
      } else if (distro.indexOf("robolinux") !== -1) {
        result = "robolinux";
      } else if (_linux && distro) {
        result = distro.toLowerCase().trim().replace(/\s+/g, "-");
      }
      return result;
    }
    function osInfo(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = {
            platform: _platform === "Windows_NT" ? "Windows" : _platform,
            distro: "unknown",
            release: "unknown",
            codename: "",
            kernel: os.release(),
            arch: os.arch(),
            hostname: os.hostname(),
            codepage: "",
            logofile: "",
            serial: "",
            build: "",
            servicepack: "",
            uefi: false
          };
          if (_linux) {
            exec2("cat /etc/*-release; cat /usr/lib/os-release; cat /etc/openwrt_release", function(error, stdout) {
              let release = {};
              let lines = stdout.toString().split("\n");
              lines.forEach(function(line) {
                if (line.indexOf("=") !== -1) {
                  release[line.split("=")[0].trim().toUpperCase()] = line.split("=")[1].trim();
                }
              });
              let releaseVersion = (release.VERSION || "").replace(/"/g, "");
              let codename = (release.DISTRIB_CODENAME || release.VERSION_CODENAME || "").replace(/"/g, "");
              if (releaseVersion.indexOf("(") >= 0) {
                codename = releaseVersion.split("(")[1].replace(/[()]/g, "").trim();
                releaseVersion = releaseVersion.split("(")[0].trim();
              }
              result.distro = (release.DISTRIB_ID || release.NAME || "unknown").replace(/"/g, "");
              result.logofile = getLogoFile(result.distro);
              result.release = (releaseVersion || release.DISTRIB_RELEASE || release.VERSION_ID || "unknown").replace(/"/g, "");
              result.codename = codename;
              result.codepage = util.getCodepage();
              result.build = (release.BUILD_ID || "").replace(/"/g, "").trim();
              isUefiLinux().then((uefi) => {
                result.uefi = uefi;
                uuid().then((data) => {
                  result.serial = data.os;
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                });
              });
            });
          }
          if (_freebsd || _openbsd || _netbsd) {
            exec2("sysctl kern.ostype kern.osrelease kern.osrevision kern.hostuuid machdep.bootmethod", function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                result.distro = util.getValue(lines, "kern.ostype");
                result.logofile = getLogoFile(result.distro);
                result.release = util.getValue(lines, "kern.osrelease").split("-")[0];
                result.serial = util.getValue(lines, "kern.uuid");
                result.codename = "";
                result.codepage = util.getCodepage();
                result.uefi = util.getValue(lines, "machdep.bootmethod").toLowerCase().indexOf("uefi") >= 0;
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_darwin) {
            exec2("sw_vers; sysctl kern.ostype kern.osrelease kern.osrevision kern.uuid", function(error, stdout) {
              let lines = stdout.toString().split("\n");
              result.serial = util.getValue(lines, "kern.uuid");
              result.distro = util.getValue(lines, "ProductName");
              result.release = util.getValue(lines, "ProductVersion");
              result.build = util.getValue(lines, "BuildVersion");
              result.logofile = getLogoFile(result.distro);
              result.codename = "macOS";
              result.codename = result.release.indexOf("10.4") > -1 ? "Mac OS X Tiger" : result.codename;
              result.codename = result.release.indexOf("10.4") > -1 ? "Mac OS X Tiger" : result.codename;
              result.codename = result.release.indexOf("10.4") > -1 ? "Mac OS X Tiger" : result.codename;
              result.codename = result.release.indexOf("10.5") > -1 ? "Mac OS X Leopard" : result.codename;
              result.codename = result.release.indexOf("10.6") > -1 ? "Mac OS X Snow Leopard" : result.codename;
              result.codename = result.release.indexOf("10.7") > -1 ? "Mac OS X Lion" : result.codename;
              result.codename = result.release.indexOf("10.8") > -1 ? "OS X Mountain Lion" : result.codename;
              result.codename = result.release.indexOf("10.9") > -1 ? "OS X Mavericks" : result.codename;
              result.codename = result.release.indexOf("10.10") > -1 ? "OS X Yosemite" : result.codename;
              result.codename = result.release.indexOf("10.11") > -1 ? "OS X El Capitan" : result.codename;
              result.codename = result.release.indexOf("10.12") > -1 ? "macOS Sierra" : result.codename;
              result.codename = result.release.indexOf("10.13") > -1 ? "macOS High Sierra" : result.codename;
              result.codename = result.release.indexOf("10.14") > -1 ? "macOS Mojave" : result.codename;
              result.codename = result.release.indexOf("10.15") > -1 ? "macOS Catalina" : result.codename;
              result.uefi = true;
              result.codepage = util.getCodepage();
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_sunos) {
            result.release = result.kernel;
            exec2("uname -o", function(error, stdout) {
              let lines = stdout.toString().split("\n");
              result.distro = lines[0];
              result.logofile = getLogoFile(result.distro);
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_windows) {
            result.logofile = getLogoFile();
            result.release = result.kernel;
            try {
              util.wmic("os get /value").then((stdout) => {
                let lines = stdout.toString().split("\r\n");
                result.distro = util.getValue(lines, "Caption", "=").trim();
                result.serial = util.getValue(lines, "SerialNumber", "=").trim();
                result.build = util.getValue(lines, "BuildNumber", "=").trim();
                result.servicepack = util.getValue(lines, "ServicePackMajorVersion", "=").trim() + "." + util.getValue(lines, "ServicePackMinorVersion", "=").trim();
                result.codepage = util.getCodepage();
                isUefiWindows().then((uefi) => {
                  result.uefi = uefi;
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                });
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.osInfo = osInfo;
    function isUefiLinux() {
      return new Promise((resolve) => {
        process.nextTick(() => {
          fs2.stat("/sys/firmware/efi", function(err) {
            if (!err) {
              resolve(true);
            } else {
              resolve(false);
            }
          });
        });
      });
    }
    function isUefiWindows() {
      return new Promise((resolve) => {
        process.nextTick(() => {
          try {
            exec2('findstr /C:"Detected boot environment" "%windir%\\Panther\\setupact.log"', util.execOptsWin, function(error, stdout) {
              if (!error) {
                const line = stdout.toString().split("\n\r")[0];
                resolve(line.toLowerCase().indexOf("uefi") >= 0);
                return;
              }
              resolve(false);
            });
          } catch (e) {
            resolve(false);
          }
        });
      });
    }
    function versions(apps, callback) {
      let versionObject = {
        kernel: os.release(),
        openssl: "",
        systemOpenssl: "",
        systemOpensslLib: "",
        node: process.versions.node,
        v8: process.versions.v8,
        npm: "",
        yarn: "",
        pm2: "",
        gulp: "",
        grunt: "",
        git: "",
        tsc: "",
        mysql: "",
        redis: "",
        mongodb: "",
        apache: "",
        nginx: "",
        php: "",
        docker: "",
        postfix: "",
        postgresql: "",
        perl: "",
        python: "",
        python3: "",
        pip: "",
        pip3: "",
        java: "",
        gcc: "",
        virtualbox: "",
        dotnet: ""
      };
      function checkVersionParam(apps2) {
        if (apps2 === "*") {
          return {
            versions: versionObject,
            counter: 26
          };
        }
        if (!Array.isArray(apps2)) {
          apps2 = apps2.trim().toLowerCase().replace(/,+/g, "|").replace(/ /g, "|");
          apps2 = apps2.split("|");
          const result = {
            versions: {},
            counter: 0
          };
          apps2.forEach((el) => {
            if (el) {
              for (let key in versionObject) {
                if ({}.hasOwnProperty.call(versionObject, key)) {
                  if (key.toLowerCase() === el.toLowerCase() && !{}.hasOwnProperty.call(result.versions, key)) {
                    result.versions[key] = versionObject[key];
                    if (key === "openssl") {
                      result.versions.systemOpenssl = "";
                      result.versions.systemOpensslLib = "";
                    }
                    if (!result.versions[key]) {
                      result.counter++;
                    }
                  }
                }
              }
            }
          });
          return result;
        }
      }
      return new Promise((resolve) => {
        process.nextTick(() => {
          if (util.isFunction(apps) && !callback) {
            callback = apps;
            apps = "*";
          } else {
            apps = apps || "*";
          }
          const appsObj = checkVersionParam(apps);
          let totalFunctions = appsObj.counter;
          let functionProcessed = function() {
            return function() {
              if (--totalFunctions === 0) {
                if (callback) {
                  callback(appsObj.versions);
                }
                resolve(appsObj.versions);
              }
            };
          }();
          let cmd = "";
          try {
            if ({}.hasOwnProperty.call(appsObj.versions, "openssl")) {
              appsObj.versions.openssl = process.versions.openssl;
              exec2("openssl version", function(error, stdout) {
                if (!error) {
                  let openssl_string = stdout.toString().split("\n")[0].trim();
                  let openssl = openssl_string.split(" ");
                  appsObj.versions.systemOpenssl = openssl.length > 0 ? openssl[1] : openssl[0];
                  appsObj.versions.systemOpensslLib = openssl.length > 0 ? openssl[0] : "openssl";
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "npm")) {
              exec2("npm -v", function(error, stdout) {
                if (!error) {
                  appsObj.versions.npm = stdout.toString().split("\n")[0];
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "pm2")) {
              cmd = "pm2";
              if (_windows) {
                cmd += ".cmd";
              }
              exec2(`${cmd} -v`, function(error, stdout) {
                if (!error) {
                  let pm2 = stdout.toString().split("\n")[0].trim();
                  if (!pm2.startsWith("[PM2]")) {
                    appsObj.versions.pm2 = pm2;
                  }
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "yarn")) {
              exec2("yarn --version", function(error, stdout) {
                if (!error) {
                  appsObj.versions.yarn = stdout.toString().split("\n")[0];
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "gulp")) {
              cmd = "gulp";
              if (_windows) {
                cmd += ".cmd";
              }
              exec2(`${cmd} --version`, function(error, stdout) {
                if (!error) {
                  const gulp = stdout.toString().split("\n")[0] || "";
                  appsObj.versions.gulp = (gulp.toLowerCase().split("version")[1] || "").trim();
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "tsc")) {
              cmd = "tsc";
              if (_windows) {
                cmd += ".cmd";
              }
              exec2(`${cmd} --version`, function(error, stdout) {
                if (!error) {
                  const tsc = stdout.toString().split("\n")[0] || "";
                  appsObj.versions.tsc = (tsc.toLowerCase().split("version")[1] || "").trim();
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "grunt")) {
              cmd = "grunt";
              if (_windows) {
                cmd += ".cmd";
              }
              exec2(`${cmd} --version`, function(error, stdout) {
                if (!error) {
                  const grunt = stdout.toString().split("\n")[0] || "";
                  appsObj.versions.grunt = (grunt.toLowerCase().split("cli v")[1] || "").trim();
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "git")) {
              if (_darwin) {
                const gitHomebrewExists = fs2.existsSync("/usr/local/Cellar/git");
                if (util.darwinXcodeExists() || gitHomebrewExists) {
                  exec2("git --version", function(error, stdout) {
                    if (!error) {
                      let git = stdout.toString().split("\n")[0] || "";
                      git = (git.toLowerCase().split("version")[1] || "").trim();
                      appsObj.versions.git = (git.split(" ")[0] || "").trim();
                    }
                    functionProcessed();
                  });
                } else {
                  functionProcessed();
                }
              } else {
                exec2("git --version", function(error, stdout) {
                  if (!error) {
                    let git = stdout.toString().split("\n")[0] || "";
                    git = (git.toLowerCase().split("version")[1] || "").trim();
                    appsObj.versions.git = (git.split(" ")[0] || "").trim();
                  }
                  functionProcessed();
                });
              }
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "apache")) {
              exec2("apachectl -v 2>&1", function(error, stdout) {
                if (!error) {
                  const apache = (stdout.toString().split("\n")[0] || "").split(":");
                  appsObj.versions.apache = apache.length > 1 ? apache[1].replace("Apache", "").replace("/", "").trim() : "";
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "nginx")) {
              exec2("nginx -v 2>&1", function(error, stdout) {
                if (!error) {
                  const nginx = stdout.toString().split("\n")[0] || "";
                  appsObj.versions.nginx = (nginx.toLowerCase().split("/")[1] || "").trim();
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "mysql")) {
              exec2("mysql -V", function(error, stdout) {
                if (!error) {
                  let mysql = stdout.toString().split("\n")[0] || "";
                  mysql = mysql.toLowerCase();
                  if (mysql.indexOf(",") > -1) {
                    mysql = (mysql.split(",")[0] || "").trim();
                    const parts = mysql.split(" ");
                    appsObj.versions.mysql = (parts[parts.length - 1] || "").trim();
                  } else {
                    if (mysql.indexOf(" ver ") > -1) {
                      mysql = mysql.split(" ver ")[1];
                      appsObj.versions.mysql = mysql.split(" ")[0];
                    }
                  }
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "php")) {
              exec2("php -v", function(error, stdout) {
                if (!error) {
                  const php = stdout.toString().split("\n")[0] || "";
                  let parts = php.split("(");
                  if (parts[0].indexOf("-")) {
                    parts = parts[0].split("-");
                  }
                  appsObj.versions.php = parts[0].replace(/[^0-9.]/g, "");
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "redis")) {
              exec2("redis-server --version", function(error, stdout) {
                if (!error) {
                  const redis = stdout.toString().split("\n")[0] || "";
                  const parts = redis.split(" ");
                  appsObj.versions.redis = util.getValue(parts, "v", "=", true);
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "docker")) {
              exec2("docker --version", function(error, stdout) {
                if (!error) {
                  const docker = stdout.toString().split("\n")[0] || "";
                  const parts = docker.split(" ");
                  appsObj.versions.docker = parts.length > 2 && parts[2].endsWith(",") ? parts[2].slice(0, -1) : "";
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "postfix")) {
              exec2("postconf -d | grep mail_version", function(error, stdout) {
                if (!error) {
                  const postfix = stdout.toString().split("\n") || [];
                  appsObj.versions.postfix = util.getValue(postfix, "mail_version", "=", true);
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "mongodb")) {
              exec2("mongod --version", function(error, stdout) {
                if (!error) {
                  const mongodb = stdout.toString().split("\n")[0] || "";
                  appsObj.versions.mongodb = (mongodb.toLowerCase().split(",")[0] || "").replace(/[^0-9.]/g, "");
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "postgresql")) {
              if (_linux) {
                exec2("locate bin/postgres", function(error, stdout) {
                  if (!error) {
                    const postgresqlBin = stdout.toString().split("\n").sort();
                    if (postgresqlBin.length) {
                      exec2(postgresqlBin[postgresqlBin.length - 1] + " -V", function(error2, stdout2) {
                        if (!error2) {
                          const postgresql = stdout2.toString().split("\n")[0].split(" ") || [];
                          appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : "";
                        }
                        functionProcessed();
                      });
                    } else {
                      functionProcessed();
                    }
                  } else {
                    exec2("psql -V", function(error2, stdout2) {
                      if (!error2) {
                        const postgresql = stdout2.toString().split("\n")[0].split(" ") || [];
                        appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : "";
                        appsObj.versions.postgresql = appsObj.versions.postgresql.split("-")[0];
                      }
                      functionProcessed();
                    });
                    functionProcessed();
                  }
                });
              } else {
                if (_windows) {
                  util.wmic("service get /value").then((stdout) => {
                    let serviceSections = stdout.split(/\n\s*\n/);
                    for (let i = 0; i < serviceSections.length; i++) {
                      if (serviceSections[i].trim() !== "") {
                        let lines = serviceSections[i].trim().split("\r\n");
                        let srvCaption = util.getValue(lines, "caption", "=", true).toLowerCase();
                        if (srvCaption.indexOf("postgresql") > -1) {
                          const parts = srvCaption.split(" server ");
                          if (parts.length > 1) {
                            appsObj.versions.postgresql = parts[1];
                          }
                        }
                      }
                    }
                    functionProcessed();
                  });
                } else {
                  exec2("postgres -V", function(error, stdout) {
                    if (!error) {
                      const postgresql = stdout.toString().split("\n")[0].split(" ") || [];
                      appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : "";
                    }
                    functionProcessed();
                  });
                }
              }
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "perl")) {
              exec2("perl -v", function(error, stdout) {
                if (!error) {
                  const perl = stdout.toString().split("\n") || "";
                  while (perl.length > 0 && perl[0].trim() === "") {
                    perl.shift();
                  }
                  if (perl.length > 0) {
                    appsObj.versions.perl = perl[0].split("(").pop().split(")")[0].replace("v", "");
                  }
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "python")) {
              exec2("python -V 2>&1", function(error, stdout) {
                if (!error) {
                  const python = stdout.toString().split("\n")[0] || "";
                  appsObj.versions.python = python.toLowerCase().replace("python", "").trim();
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "python3")) {
              exec2("python3 -V 2>&1", function(error, stdout) {
                if (!error) {
                  const python = stdout.toString().split("\n")[0] || "";
                  appsObj.versions.python3 = python.toLowerCase().replace("python", "").trim();
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "pip")) {
              exec2("pip -V 2>&1", function(error, stdout) {
                if (!error) {
                  const pip = stdout.toString().split("\n")[0] || "";
                  const parts = pip.split(" ");
                  appsObj.versions.pip = parts.length >= 2 ? parts[1] : "";
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "pip3")) {
              exec2("pip3 -V 2>&1", function(error, stdout) {
                if (!error) {
                  const pip = stdout.toString().split("\n")[0] || "";
                  const parts = pip.split(" ");
                  appsObj.versions.pip3 = parts.length >= 2 ? parts[1] : "";
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "java")) {
              if (_darwin) {
                exec2("/usr/libexec/java_home -V 2>&1", function(error, stdout) {
                  if (!error && stdout.toString().toLowerCase().indexOf("no java runtime") === -1) {
                    exec2("java -version 2>&1", function(error2, stdout2) {
                      if (!error2) {
                        const java = stdout2.toString().split("\n")[0] || "";
                        const parts = java.split('"');
                        appsObj.versions.java = parts.length === 3 ? parts[1].trim() : "";
                      }
                      functionProcessed();
                    });
                  } else {
                    functionProcessed();
                  }
                });
              } else {
                exec2("java -version 2>&1", function(error, stdout) {
                  if (!error) {
                    const java = stdout.toString().split("\n")[0] || "";
                    const parts = java.split('"');
                    appsObj.versions.java = parts.length === 3 ? parts[1].trim() : "";
                  }
                  functionProcessed();
                });
              }
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "gcc")) {
              if (_darwin && util.darwinXcodeExists() || !_darwin) {
                exec2("gcc -dumpversion", function(error, stdout) {
                  if (!error) {
                    appsObj.versions.gcc = stdout.toString().split("\n")[0].trim() || "";
                  }
                  if (appsObj.versions.gcc.indexOf(".") > -1) {
                    functionProcessed();
                  } else {
                    exec2("gcc --version", function(error2, stdout2) {
                      if (!error2) {
                        const gcc = stdout2.toString().split("\n")[0].trim();
                        if (gcc.indexOf("gcc") > -1 && gcc.indexOf(")") > -1) {
                          const parts = gcc.split(")");
                          appsObj.versions.gcc = parts[1].trim() || appsObj.versions.gcc;
                        }
                      }
                      functionProcessed();
                    });
                  }
                });
              } else {
                functionProcessed();
              }
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "virtualbox")) {
              exec2(util.getVboxmanage() + " -v 2>&1", function(error, stdout) {
                if (!error) {
                  const vbox = stdout.toString().split("\n")[0] || "";
                  const parts = vbox.split("r");
                  appsObj.versions.virtualbox = parts[0];
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "dotnet")) {
              exec2("dotnet --version 2>&1", function(error, stdout) {
                if (!error) {
                  const dotnet = stdout.toString().split("\n")[0] || "";
                  appsObj.versions.dotnet = dotnet.trim();
                }
                functionProcessed();
              });
            }
          } catch (e) {
            if (callback) {
              callback(appsObj.versions);
            }
            resolve(appsObj.versions);
          }
        });
      });
    }
    exports.versions = versions;
    function shell(callback) {
      return new Promise((resolve, reject) => {
        process.nextTick(() => {
          if (_windows) {
            let error = new Error(NOT_SUPPORTED);
            if (callback) {
              callback(NOT_SUPPORTED);
            }
            reject(error);
          }
          let result = "";
          exec2("echo $SHELL", function(error, stdout) {
            if (!error) {
              result = stdout.toString().split("\n")[0];
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        });
      });
    }
    exports.shell = shell;
    function uuid(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = {
            os: ""
          };
          let parts;
          if (_darwin) {
            exec2("ioreg -rd1 -c IOPlatformExpertDevice | grep IOPlatformUUID", function(error, stdout) {
              if (!error) {
                parts = stdout.toString().split("\n")[0].replace(/"/g, "").split("=");
                result.os = parts.length > 1 ? parts[1].trim().toLowerCase() : "";
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_linux) {
            exec2("( cat /var/lib/dbus/machine-id /etc/machine-id 2> /dev/null || hostname ) | head -n 1 || :", function(error, stdout) {
              if (!error) {
                result.os = stdout.toString().split("\n")[0].trim().toLowerCase();
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_freebsd || _openbsd || _netbsd) {
            exec2("kenv -q smbios.system.uuid", function(error, stdout) {
              if (!error) {
                result.os = stdout.toString().split("\n")[0].trim().toLowerCase();
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_windows) {
            exec2('%windir%\\System32\\reg query "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography" /v MachineGuid', util.execOptsWin, function(error, stdout) {
              if (!error) {
                parts = stdout.toString().split("\n\r")[0].split("REG_SZ");
                result.os = parts.length > 1 ? parts[1].replace(/\r+|\n+|\s+/ig, "").toLowerCase() : "";
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
        });
      });
    }
    exports.uuid = uuid;
  }
});

// node_modules/@jedithepro/system-info/lib/cpu.js
var require_cpu = __commonJS({
  "node_modules/@jedithepro/system-info/lib/cpu.js"(exports) {
    "use strict";
    var os = require("os");
    var exec2 = require("child_process").exec;
    var fs2 = require("fs");
    var util = require_util2();
    var _platform = process.platform;
    var _linux = _platform === "linux";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    var _cpu_speed = "0.00";
    var _current_cpu = {
      user: 0,
      nice: 0,
      system: 0,
      idle: 0,
      irq: 0,
      load: 0,
      tick: 0,
      ms: 0,
      currentload: 0,
      currentload_user: 0,
      currentload_system: 0,
      currentload_nice: 0,
      currentload_idle: 0,
      currentload_irq: 0,
      raw_currentload: 0,
      raw_currentload_user: 0,
      raw_currentload_system: 0,
      raw_currentload_nice: 0,
      raw_currentload_idle: 0,
      raw_currentload_irq: 0
    };
    var _cpus = [];
    var _corecount = 0;
    var AMDBaseFrequencies = {
      "8346": "1.8",
      "8347": "1.9",
      "8350": "2.0",
      "8354": "2.2",
      "8356|SE": "2.4",
      "8356": "2.3",
      "8360": "2.5",
      "2372": "2.1",
      "2373": "2.1",
      "2374": "2.2",
      "2376": "2.3",
      "2377": "2.3",
      "2378": "2.4",
      "2379": "2.4",
      "2380": "2.5",
      "2381": "2.5",
      "2382": "2.6",
      "2384": "2.7",
      "2386": "2.8",
      "2387": "2.8",
      "2389": "2.9",
      "2393": "3.1",
      "8374": "2.2",
      "8376": "2.3",
      "8378": "2.4",
      "8379": "2.4",
      "8380": "2.5",
      "8381": "2.5",
      "8382": "2.6",
      "8384": "2.7",
      "8386": "2.8",
      "8387": "2.8",
      "8389": "2.9",
      "8393": "3.1",
      "2419EE": "1.8",
      "2423HE": "2.0",
      "2425HE": "2.1",
      "2427": "2.2",
      "2431": "2.4",
      "2435": "2.6",
      "2439SE": "2.8",
      "8425HE": "2.1",
      "8431": "2.4",
      "8435": "2.6",
      "8439SE": "2.8",
      "4122": "2.2",
      "4130": "2.6",
      "4162EE": "1.7",
      "4164EE": "1.8",
      "4170HE": "2.1",
      "4174HE": "2.3",
      "4176HE": "2.4",
      "4180": "2.6",
      "4184": "2.8",
      "6124HE": "1.8",
      "6128HE": "2.0",
      "6132HE": "2.2",
      "6128": "2.0",
      "6134": "2.3",
      "6136": "2.4",
      "6140": "2.6",
      "6164HE": "1.7",
      "6166HE": "1.8",
      "6168": "1.9",
      "6172": "2.1",
      "6174": "2.2",
      "6176": "2.3",
      "6176SE": "2.3",
      "6180SE": "2.5",
      "3250": "2.5",
      "3260": "2.7",
      "3280": "2.4",
      "4226": "2.7",
      "4228": "2.8",
      "4230": "2.9",
      "4234": "3.1",
      "4238": "3.3",
      "4240": "3.4",
      "4256": "1.6",
      "4274": "2.5",
      "4276": "2.6",
      "4280": "2.8",
      "4284": "3.0",
      "6204": "3.3",
      "6212": "2.6",
      "6220": "3.0",
      "6234": "2.4",
      "6238": "2.6",
      "6262HE": "1.6",
      "6272": "2.1",
      "6274": "2.2",
      "6276": "2.3",
      "6278": "2.4",
      "6282SE": "2.6",
      "6284SE": "2.7",
      "6308": "3.5",
      "6320": "2.8",
      "6328": "3.2",
      "6338P": "2.3",
      "6344": "2.6",
      "6348": "2.8",
      "6366": "1.8",
      "6370P": "2.0",
      "6376": "2.3",
      "6378": "2.4",
      "6380": "2.5",
      "6386": "2.8",
      "FX|4100": "3.6",
      "FX|4120": "3.9",
      "FX|4130": "3.8",
      "FX|4150": "3.8",
      "FX|4170": "4.2",
      "FX|6100": "3.3",
      "FX|6120": "3.6",
      "FX|6130": "3.6",
      "FX|6200": "3.8",
      "FX|8100": "2.8",
      "FX|8120": "3.1",
      "FX|8140": "3.2",
      "FX|8150": "3.6",
      "FX|8170": "3.9",
      "FX|4300": "3.8",
      "FX|4320": "4.0",
      "FX|4350": "4.2",
      "FX|6300": "3.5",
      "FX|6350": "3.9",
      "FX|8300": "3.3",
      "FX|8310": "3.4",
      "FX|8320": "3.5",
      "FX|8350": "4.0",
      "FX|8370": "4.0",
      "FX|9370": "4.4",
      "FX|9590": "4.7",
      "FX|8320E": "3.2",
      "FX|8370E": "3.3",
      "1950X": "3.4",
      "1920X": "3.5",
      "1920": "3.2",
      "1900X": "3.8",
      "1800X": "3.6",
      "1700X": "3.4",
      "Pro 1700X": "3.5",
      "1700": "3.0",
      "Pro 1700": "3.0",
      "1600X": "3.6",
      "1600": "3.2",
      "Pro 1600": "3.2",
      "1500X": "3.5",
      "Pro 1500": "3.5",
      "1400": "3.2",
      "1300X": "3.5",
      "Pro 1300": "3.5",
      "1200": "3.1",
      "Pro 1200": "3.1",
      "2200U": "2.5",
      "2300U": "2.0",
      "Pro 2300U": "2.0",
      "2500U": "2.0",
      "Pro 2500U": "2.2",
      "2700U": "2.0",
      "Pro 2700U": "2.2",
      "2600H": "3.2",
      "2800H": "3.3",
      "7601": "2.2",
      "7551": "2.0",
      "7501": "2.0",
      "74501": "2.3",
      "7401": "2.0",
      "7351": "2.4",
      "7301": "2.2",
      "7281": "2.1",
      "7251": "2.1",
      "7551P": "2.0",
      "7401P": "2.0",
      "7351P": "2.4",
      "2300X": "3.5",
      "2500X": "3.6",
      "2600": "3.4",
      "2600E": "3.1",
      "2600X": "3.6",
      "2700": "3.2",
      "2700E": "2.8",
      "2700X": "3.7",
      "Pro 2700X": "3.6",
      "2920": "3.5",
      "2950": "3.5",
      "2970WX": "3.0",
      "2990WX": "3.0",
      "3200U": "2.6",
      "3300U": "2.1",
      "3500U": "2.1",
      "3550H": "2.1",
      "3580U": "2.1",
      "3700U": "2.3",
      "3750H": "2.3",
      "3780U": "2.3",
      "3500X": "3.6",
      "3600": "3.6",
      "Pro 3600": "3.6",
      "3600X": "3.8",
      "Pro 3700": "3.6",
      "3700X": "3.6",
      "3800X": "3.9",
      "3900": "3.1",
      "Pro 3900": "3.1",
      "3900X": "3.8",
      "3950X": "3.5",
      "3960X": "3.8",
      "3970X": "3.7",
      "7232P": "3.1",
      "7302P": "3.0",
      "7402P": "2.8",
      "7502P": "2.5",
      "7702P": "2.0",
      "7252": "3.1",
      "7262": "3.2",
      "7272": "2.9",
      "7282": "2.8",
      "7302": "3.0",
      "7352": "2.3",
      "7402": "2.8",
      "7452": "2.35",
      "7502": "2.5",
      "7542": "2.9",
      "7552": "2.2",
      "7642": "2.3",
      "7702": "2.0",
      "7742": "2.25",
      "7H12": "2.6"
    };
    var socketTypes = {
      1: "Other",
      2: "Unknown",
      3: "Daughter Board",
      4: "ZIF Socket",
      5: "Replacement/Piggy Back",
      6: "None",
      7: "LIF Socket",
      8: "Slot 1",
      9: "Slot 2",
      10: "370 Pin Socket",
      11: "Slot A",
      12: "Slot M",
      13: "423",
      14: "A (Socket 462)",
      15: "478",
      16: "754",
      17: "940",
      18: "939",
      19: "mPGA604",
      20: "LGA771",
      21: "LGA775",
      22: "S1",
      23: "AM2",
      24: "F (1207)",
      25: "LGA1366",
      26: "G34",
      27: "AM3",
      28: "C32",
      29: "LGA1156",
      30: "LGA1567",
      31: "PGA988A",
      32: "BGA1288",
      33: "rPGA988B",
      34: "BGA1023",
      35: "BGA1224",
      36: "LGA1155",
      37: "LGA1356",
      38: "LGA2011",
      39: "FS1",
      40: "FS2",
      41: "FM1",
      42: "FM2",
      43: "LGA2011-3",
      44: "LGA1356-3",
      45: "LGA1150",
      46: "BGA1168",
      47: "BGA1234",
      48: "BGA1364",
      49: "AM4",
      50: "LGA1151",
      51: "BGA1356",
      52: "BGA1440",
      53: "BGA1515",
      54: "LGA3647-1",
      55: "SP3",
      56: "SP3r2",
      57: "LGA2066",
      58: "BGA1392",
      59: "BGA1510",
      60: "BGA1528"
    };
    function cpuBrandManufacturer(res) {
      res.brand = res.brand.replace(/\(R\)+/g, "\xAE").replace(/\s+/g, " ").trim();
      res.brand = res.brand.replace(/\(TM\)+/g, "\u2122").replace(/\s+/g, " ").trim();
      res.brand = res.brand.replace(/\(C\)+/g, "\xA9").replace(/\s+/g, " ").trim();
      res.brand = res.brand.replace(/CPU+/g, "").replace(/\s+/g, " ").trim();
      res.manufacturer = res.brand.split(" ")[0];
      let parts = res.brand.split(" ");
      parts.shift();
      res.brand = parts.join(" ");
      return res;
    }
    function getAMDSpeed(brand) {
      let result = "0.00";
      for (let key in AMDBaseFrequencies) {
        if ({}.hasOwnProperty.call(AMDBaseFrequencies, key)) {
          let parts = key.split("|");
          let found = 0;
          parts.forEach((item) => {
            if (brand.indexOf(item) > -1) {
              found++;
            }
          });
          if (found === parts.length) {
            result = AMDBaseFrequencies[key];
          }
        }
      }
      return result;
    }
    function getCpu() {
      return new Promise((resolve) => {
        process.nextTick(() => {
          const UNKNOWN = "unknown";
          let result = {
            manufacturer: UNKNOWN,
            brand: UNKNOWN,
            vendor: "",
            family: "",
            model: "",
            stepping: "",
            revision: "",
            voltage: "",
            speed: "0.00",
            speedmin: "",
            speedmax: "",
            governor: "",
            cores: util.cores(),
            physicalCores: util.cores(),
            processors: 1,
            socket: "",
            cache: {}
          };
          if (_darwin) {
            exec2("sysctl machdep.cpu hw.cpufrequency_max hw.cpufrequency_min hw.packages hw.physicalcpu_max hw.ncpu", function(error, stdout) {
              let lines = stdout.toString().split("\n");
              const modelline = util.getValue(lines, "machdep.cpu.brand_string");
              result.brand = modelline.split("@")[0].trim();
              result.speed = modelline.split("@")[1].trim();
              result.speed = parseFloat(result.speed.replace(/GHz+/g, "")).toFixed(2);
              _cpu_speed = result.speed;
              result = cpuBrandManufacturer(result);
              result.speedmin = (util.getValue(lines, "hw.cpufrequency_min") / 1e9).toFixed(2);
              result.speedmax = (util.getValue(lines, "hw.cpufrequency_max") / 1e9).toFixed(2);
              result.vendor = util.getValue(lines, "machdep.cpu.vendor");
              result.family = util.getValue(lines, "machdep.cpu.family");
              result.model = util.getValue(lines, "machdep.cpu.model");
              result.stepping = util.getValue(lines, "machdep.cpu.stepping");
              const countProcessors = util.getValue(lines, "hw.packages");
              const countCores = util.getValue(lines, "hw.physicalcpu_max");
              const countThreads = util.getValue(lines, "hw.ncpu");
              if (countProcessors) {
                result.processors = parseInt(countProcessors) || 1;
              }
              if (countCores && countThreads) {
                result.cores = parseInt(countThreads) || util.cores();
                result.physicalCores = parseInt(countCores) || util.cores();
              }
              cpuCache().then((res) => {
                result.cache = res;
                resolve(result);
              });
            });
          }
          if (_linux) {
            let modelline = "";
            let lines = [];
            if (os.cpus()[0] && os.cpus()[0].model)
              modelline = os.cpus()[0].model;
            exec2('export LC_ALL=C; lscpu; echo -n "Governor: "; cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor 2>/dev/null; echo; unset LC_ALL', function(error, stdout) {
              if (!error) {
                lines = stdout.toString().split("\n");
              }
              modelline = util.getValue(lines, "model name") || modelline;
              result.brand = modelline.split("@")[0].trim();
              result.speed = modelline.split("@")[1] ? parseFloat(modelline.split("@")[1].trim()).toFixed(2) : "0.00";
              if (result.speed === "0.00" && (result.brand.indexOf("AMD") > -1 || result.brand.toLowerCase().indexOf("ryzen") > -1)) {
                result.speed = getAMDSpeed(result.brand);
              }
              if (result.speed === "0.00") {
                let current = getCpuCurrentSpeedSync();
                if (current.avg !== 0)
                  result.speed = current.avg.toFixed(2);
              }
              _cpu_speed = result.speed;
              result.speedmin = Math.round(parseFloat(util.getValue(lines, "cpu min mhz").replace(/,/g, ".")) / 10) / 100;
              result.speedmin = result.speedmin ? parseFloat(result.speedmin).toFixed(2) : "";
              result.speedmax = Math.round(parseFloat(util.getValue(lines, "cpu max mhz").replace(/,/g, ".")) / 10) / 100;
              result.speedmax = result.speedmax ? parseFloat(result.speedmax).toFixed(2) : "";
              result = cpuBrandManufacturer(result);
              result.vendor = util.getValue(lines, "vendor id");
              result.family = util.getValue(lines, "cpu family");
              result.model = util.getValue(lines, "model:");
              result.stepping = util.getValue(lines, "stepping");
              result.revision = util.getValue(lines, "cpu revision");
              result.cache.l1d = util.getValue(lines, "l1d cache");
              if (result.cache.l1d) {
                result.cache.l1d = parseInt(result.cache.l1d) * (result.cache.l1d.indexOf("K") !== -1 ? 1024 : 1);
              }
              result.cache.l1i = util.getValue(lines, "l1i cache");
              if (result.cache.l1i) {
                result.cache.l1i = parseInt(result.cache.l1i) * (result.cache.l1i.indexOf("K") !== -1 ? 1024 : 1);
              }
              result.cache.l2 = util.getValue(lines, "l2 cache");
              if (result.cache.l2) {
                result.cache.l2 = parseInt(result.cache.l2) * (result.cache.l2.indexOf("K") !== -1 ? 1024 : 1);
              }
              result.cache.l3 = util.getValue(lines, "l3 cache");
              if (result.cache.l3) {
                result.cache.l3 = parseInt(result.cache.l3) * (result.cache.l3.indexOf("K") !== -1 ? 1024 : 1);
              }
              const threadsPerCore = util.getValue(lines, "thread(s) per core") || "1";
              const processors = util.getValue(lines, "socket(s)") || "1";
              let threadsPerCoreInt = parseInt(threadsPerCore, 10);
              let processorsInt = parseInt(processors, 10);
              result.physicalCores = result.cores / threadsPerCoreInt;
              result.processors = processorsInt;
              result.governor = util.getValue(lines, "governor") || "";
              if (result.vendor === "ARM") {
                const linesRpi = fs2.readFileSync("/proc/cpuinfo").toString().split("\n");
                const rPIRevision = util.decodePiCpuinfo(linesRpi);
                if (rPIRevision.model.toLowerCase().indexOf("raspberry") >= 0) {
                  result.family = result.manufacturer;
                  result.manufacturer = rPIRevision.manufacturer;
                  result.brand = rPIRevision.processor;
                  result.revision = rPIRevision.revisionCode;
                  result.socket = "SOC";
                }
              }
              let lines2 = [];
              exec2('export LC_ALL=C; dmidecode \u2013t 4 2>/dev/null | grep "Upgrade: Socket"; unset LC_ALL', function(error2, stdout2) {
                lines2 = stdout2.toString().split("\n");
                if (lines2 && lines2.length) {
                  result.socket = util.getValue(lines2, "Upgrade").replace("Socket", "").trim() || result.socket;
                }
                resolve(result);
              });
            });
          }
          if (_freebsd || _openbsd || _netbsd) {
            let modelline = "";
            let lines = [];
            if (os.cpus()[0] && os.cpus()[0].model)
              modelline = os.cpus()[0].model;
            exec2("export LC_ALL=C; dmidecode -t 4; dmidecode -t 7 unset LC_ALL", function(error, stdout) {
              let cache = [];
              if (!error) {
                const data = stdout.toString().split("# dmidecode");
                const processor = data.length > 1 ? data[1] : "";
                cache = data.length > 2 ? data[2].split("Cache Information") : [];
                lines = processor.split("\n");
              }
              result.brand = modelline.split("@")[0].trim();
              result.speed = modelline.split("@")[1] ? parseFloat(modelline.split("@")[1].trim()).toFixed(2) : "0.00";
              if (result.speed === "0.00" && (result.brand.indexOf("AMD") > -1 || result.brand.toLowerCase().indexOf("ryzen") > -1)) {
                result.speed = getAMDSpeed(result.brand);
              }
              if (result.speed === "0.00") {
                let current = getCpuCurrentSpeedSync();
                if (current.avg !== 0)
                  result.speed = current.avg.toFixed(2);
              }
              _cpu_speed = result.speed;
              result.speedmin = "";
              result.speedmax = Math.round(parseFloat(util.getValue(lines, "max speed").replace(/Mhz/g, "")) / 10) / 100;
              result.speedmax = result.speedmax ? parseFloat(result.speedmax).toFixed(2) : "";
              result = cpuBrandManufacturer(result);
              result.vendor = util.getValue(lines, "manufacturer");
              let sig = util.getValue(lines, "signature");
              sig = sig.split(",");
              for (var i = 0; i < sig.length; i++) {
                sig[i] = sig[i].trim();
              }
              result.family = util.getValue(sig, "Family", " ", true);
              result.model = util.getValue(sig, "Model", " ", true);
              result.stepping = util.getValue(sig, "Stepping", " ", true);
              result.revision = "";
              const voltage = parseFloat(util.getValue(lines, "voltage"));
              result.voltage = isNaN(voltage) ? "" : voltage.toFixed(2);
              for (let i2 = 0; i2 < cache.length; i2++) {
                lines = cache[i2].split("\n");
                let cacheType = util.getValue(lines, "Socket Designation").toLowerCase().replace(" ", "-").split("-");
                cacheType = cacheType.length ? cacheType[0] : "";
                const sizeParts = util.getValue(lines, "Installed Size").split(" ");
                let size = parseInt(sizeParts[0], 10);
                const unit = sizeParts.length > 1 ? sizeParts[1] : "kb";
                size = size * (unit === "kb" ? 1024 : unit === "mb" ? 1024 * 1024 : unit === "gb" ? 1024 * 1024 * 1024 : 1);
                if (cacheType) {
                  if (cacheType === "l1") {
                    result.cache[cacheType + "d"] = size / 2;
                    result.cache[cacheType + "i"] = size / 2;
                  } else {
                    result.cache[cacheType] = size;
                  }
                }
              }
              result.socket = util.getValue(lines, "Upgrade").replace("Socket", "").trim();
              const threadCount = util.getValue(lines, "thread count").trim();
              const coreCount = util.getValue(lines, "core count").trim();
              if (coreCount && threadCount) {
                result.cores = threadCount;
                result.physicalCores = coreCount;
              }
              resolve(result);
            });
          }
          if (_sunos) {
            resolve(result);
          }
          if (_windows) {
            try {
              util.wmic("cpu get /value").then((stdout, error) => {
                if (!error) {
                  let lines = stdout.split("\r\n");
                  let name = util.getValue(lines, "name", "=") || "";
                  if (name.indexOf("@") >= 0) {
                    result.brand = name.split("@")[0].trim();
                    result.speed = name.split("@")[1] ? parseFloat(name.split("@")[1].trim()).toFixed(2) : "0.00";
                    _cpu_speed = result.speed;
                  } else {
                    result.brand = name.trim();
                    result.speed = "0.00";
                  }
                  result = cpuBrandManufacturer(result);
                  result.revision = util.getValue(lines, "revision", "=");
                  result.cache.l1d = 0;
                  result.cache.l1i = 0;
                  result.cache.l2 = util.getValue(lines, "l2cachesize", "=");
                  result.cache.l3 = util.getValue(lines, "l3cachesize", "=");
                  if (result.cache.l2) {
                    result.cache.l2 = parseInt(result.cache.l2, 10) * 1024;
                  }
                  if (result.cache.l3) {
                    result.cache.l3 = parseInt(result.cache.l3, 10) * 1024;
                  }
                  result.vendor = util.getValue(lines, "manufacturer", "=");
                  result.speedmax = Math.round(parseFloat(util.getValue(lines, "maxclockspeed", "=").replace(/,/g, ".")) / 10) / 100;
                  result.speedmax = result.speedmax ? parseFloat(result.speedmax).toFixed(2) : "";
                  if (result.speed === "0.00" && (result.brand.indexOf("AMD") > -1 || result.brand.toLowerCase().indexOf("ryzen") > -1)) {
                    result.speed = getAMDSpeed(result.brand);
                  }
                  if (result.speed === "0.00") {
                    result.speed = result.speedmax;
                  }
                  let description = util.getValue(lines, "description", "=").split(" ");
                  for (let i = 0; i < description.length; i++) {
                    if (description[i].toLowerCase().startsWith("family") && i + 1 < description.length && description[i + 1]) {
                      result.family = description[i + 1];
                    }
                    if (description[i].toLowerCase().startsWith("model") && i + 1 < description.length && description[i + 1]) {
                      result.model = description[i + 1];
                    }
                    if (description[i].toLowerCase().startsWith("stepping") && i + 1 < description.length && description[i + 1]) {
                      result.stepping = description[i + 1];
                    }
                  }
                  const socketId = util.getValue(lines, "UpgradeMethod", "=");
                  if (socketTypes[socketId]) {
                    result.socket = socketTypes[socketId];
                  }
                  const countProcessors = util.countLines(lines, "Caption");
                  const countThreads = util.getValue(lines, "NumberOfLogicalProcessors", "=");
                  const countCores = util.getValue(lines, "NumberOfCores", "=");
                  if (countProcessors) {
                    result.processors = parseInt(countProcessors) || 1;
                  }
                  if (countCores && countThreads) {
                    result.cores = parseInt(countThreads) || util.cores();
                    result.physicalCores = parseInt(countCores) || util.cores();
                  }
                  if (countProcessors > 1) {
                    result.cores = result.cores * countProcessors;
                    result.physicalCores = result.physicalCores * countProcessors;
                  }
                }
                util.wmic("path Win32_CacheMemory get CacheType,InstalledSize,Purpose").then((stdout2, error2) => {
                  if (!error2) {
                    let lines = stdout2.split("\r\n").filter((line) => line.trim() !== "").filter((line, idx) => idx > 0);
                    lines.forEach(function(line) {
                      if (line !== "") {
                        line = line.trim().split(/\s\s+/);
                        if (line[2] === "L1 Cache" && line[0] === "3") {
                          result.cache.l1i = parseInt(line[1], 10);
                        }
                        if (line[2] === "L1 Cache" && line[0] === "4") {
                          result.cache.l1d = parseInt(line[1], 10);
                        }
                      }
                    });
                  }
                  resolve(result);
                });
              });
            } catch (e) {
              resolve(result);
            }
          }
        });
      });
    }
    function cpu(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          getCpu().then((result) => {
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        });
      });
    }
    exports.cpu = cpu;
    function getCpuCurrentSpeedSync() {
      let cpus = os.cpus();
      let minFreq = 999999999;
      let maxFreq = 0;
      let avgFreq = 0;
      let cores = [];
      if (cpus && cpus.length) {
        for (let i in cpus) {
          if ({}.hasOwnProperty.call(cpus, i)) {
            avgFreq = avgFreq + cpus[i].speed;
            if (cpus[i].speed > maxFreq)
              maxFreq = cpus[i].speed;
            if (cpus[i].speed < minFreq)
              minFreq = cpus[i].speed;
          }
          cores.push(parseFloat(((cpus[i].speed + 1) / 1e3).toFixed(2)));
        }
        avgFreq = avgFreq / cpus.length;
        return {
          min: parseFloat(((minFreq + 1) / 1e3).toFixed(2)),
          max: parseFloat(((maxFreq + 1) / 1e3).toFixed(2)),
          avg: parseFloat(((avgFreq + 1) / 1e3).toFixed(2)),
          cores
        };
      } else {
        return {
          min: 0,
          max: 0,
          avg: 0,
          cores
        };
      }
    }
    function cpuCurrentspeed(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = getCpuCurrentSpeedSync();
          if (result.avg === 0 && _cpu_speed !== "0.00") {
            const currCpuSpeed = parseFloat(_cpu_speed);
            result = {
              min: currCpuSpeed,
              max: currCpuSpeed,
              avg: currCpuSpeed,
              cores: []
            };
          }
          if (callback) {
            callback(result);
          }
          resolve(result);
        });
      });
    }
    exports.cpuCurrentspeed = cpuCurrentspeed;
    function cpuTemperature(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = {
            main: -1,
            cores: [],
            max: -1
          };
          if (_linux) {
            const cmd = 'cat /sys/class/hwmon/hwmon1/temp*_la*;echo "---";cat /sys/class/hwmon/hwmon1/temp*_i*';
            try {
              exec2(cmd, function(error, stdout) {
                if (!error) {
                  let parts = stdout.toString().split("---");
                  let labels = parts[0].split("\n");
                  let temps = parts[1].split("\n");
                  temps.shift();
                  for (let i = 0; i < temps.length; i++) {
                    if (temps[i] && (labels[i] === void 0 || labels[i] && labels[i].toLowerCase().startsWith("core"))) {
                      result.cores.push(Math.round(parseInt(temps[i], 10) / 100) / 10);
                    } else if (temps[i] && labels[i] && result.main === -1) {
                      result.main = Math.round(parseInt(temps[i], 10) / 100) / 10;
                    }
                  }
                  if (result.cores.length > 0) {
                    if (result.main === -1) {
                      result.main = Math.round(result.cores.reduce((a, b) => a + b, 0) / result.cores.length);
                    }
                    let maxtmp = Math.max.apply(Math, result.cores);
                    result.max = maxtmp > result.main ? maxtmp : result.main;
                  }
                  if (result.main !== -1) {
                    if (result.max === -1) {
                      result.max = result.main;
                    }
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                    return;
                  }
                }
                exec2("sensors", function(error2, stdout2) {
                  if (!error2) {
                    let lines = stdout2.toString().split("\n");
                    let tdieTemp = -1;
                    lines.forEach(function(line) {
                      let regex = /[+-]([^]*)/g;
                      let temps = line.match(regex);
                      let firstPart = line.split(":")[0].toUpperCase();
                      if (firstPart.indexOf("PHYSICAL") !== -1 || firstPart.indexOf("PACKAGE") !== -1) {
                        result.main = parseFloat(temps);
                      }
                      if (firstPart.indexOf("CORE ") !== -1) {
                        result.cores.push(parseFloat(temps));
                      }
                      if (firstPart.indexOf("TDIE") !== -1 && tdieTemp === -1) {
                        tdieTemp = parseFloat(temps);
                      }
                    });
                    if (result.cores.length > 0) {
                      if (result.main === -1) {
                        result.main = Math.round(result.cores.reduce((a, b) => a + b, 0) / result.cores.length);
                      }
                      let maxtmp = Math.max.apply(Math, result.cores);
                      result.max = maxtmp > result.main ? maxtmp : result.main;
                    } else {
                      if (result.main === -1 && tdieTemp !== -1) {
                        result.main = tdieTemp;
                        result.max = tdieTemp;
                      }
                    }
                    if (result.main !== -1 || result.max !== -1) {
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                      return;
                    }
                  }
                  fs2.stat("/sys/class/thermal/thermal_zone0/temp", function(err) {
                    if (err === null) {
                      fs2.readFile("/sys/class/thermal/thermal_zone0/temp", function(error3, stdout3) {
                        if (!error3) {
                          let lines = stdout3.toString().split("\n");
                          if (lines.length > 0) {
                            result.main = parseFloat(lines[0]) / 1e3;
                            result.max = result.main;
                          }
                        }
                        if (callback) {
                          callback(result);
                        }
                        resolve(result);
                      });
                    } else {
                      exec2("/opt/vc/bin/vcgencmd measure_temp", function(error3, stdout3) {
                        if (!error3) {
                          let lines = stdout3.toString().split("\n");
                          if (lines.length > 0 && lines[0].indexOf("=")) {
                            result.main = parseFloat(lines[0].split("=")[1]);
                            result.max = result.main;
                          }
                        }
                        if (callback) {
                          callback(result);
                        }
                        resolve(result);
                      });
                    }
                  });
                });
              });
            } catch (er) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
          if (_freebsd || _openbsd || _netbsd) {
            exec2("sysctl dev.cpu | grep temp", function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                let sum = 0;
                lines.forEach(function(line) {
                  const parts = line.split(":");
                  if (parts.length > 1) {
                    const temp = parseFloat(parts[1].replace(",", "."));
                    if (temp > result.max)
                      result.max = temp;
                    sum = sum + temp;
                    result.cores.push(temp);
                  }
                });
                if (result.cores.length) {
                  result.main = Math.round(sum / result.cores.length * 100) / 100;
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_darwin) {
            let osxTemp = null;
            try {
              osxTemp = require("osx-temperature-sensor");
            } catch (er) {
              osxTemp = null;
            }
            if (osxTemp) {
              result = osxTemp.cpuTemperature();
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_sunos) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_windows) {
            try {
              util.wmic("/namespace:\\\\root\\wmi PATH MSAcpi_ThermalZoneTemperature get CurrentTemperature").then((stdout, error) => {
                if (!error) {
                  let sum = 0;
                  let lines = stdout.split("\r\n").filter((line) => line.trim() !== "").filter((line, idx) => idx > 0);
                  lines.forEach(function(line) {
                    let value = (parseInt(line, 10) - 2732) / 10;
                    sum = sum + value;
                    if (value > result.max)
                      result.max = value;
                    result.cores.push(value);
                  });
                  if (result.cores.length) {
                    result.main = sum / result.cores.length;
                  }
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.cpuTemperature = cpuTemperature;
    function cpuFlags(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = "";
          if (_windows) {
            try {
              exec2('reg query "HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0" /v FeatureSet', util.execOptsWin, function(error, stdout) {
                if (!error) {
                  let flag_hex = stdout.split("0x").pop().trim();
                  let flag_bin_unpadded = parseInt(flag_hex, 16).toString(2);
                  let flag_bin = "0".repeat(32 - flag_bin_unpadded.length) + flag_bin_unpadded;
                  let all_flags = [
                    "fpu",
                    "vme",
                    "de",
                    "pse",
                    "tsc",
                    "msr",
                    "pae",
                    "mce",
                    "cx8",
                    "apic",
                    "",
                    "sep",
                    "mtrr",
                    "pge",
                    "mca",
                    "cmov",
                    "pat",
                    "pse-36",
                    "psn",
                    "clfsh",
                    "",
                    "ds",
                    "acpi",
                    "mmx",
                    "fxsr",
                    "sse",
                    "sse2",
                    "ss",
                    "htt",
                    "tm",
                    "ia64",
                    "pbe"
                  ];
                  for (let f = 0; f < all_flags.length; f++) {
                    if (flag_bin[f] === "1" && all_flags[f] !== "") {
                      result += " " + all_flags[f];
                    }
                  }
                  result = result.trim();
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
          if (_linux) {
            try {
              exec2("export LC_ALL=C; lscpu; unset LC_ALL", function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  lines.forEach(function(line) {
                    if (line.split(":")[0].toUpperCase().indexOf("FLAGS") !== -1) {
                      result = line.split(":")[1].trim().toLowerCase();
                    }
                  });
                }
                if (!result) {
                  fs2.readFile("/proc/cpuinfo", function(error2, stdout2) {
                    if (!error2) {
                      let lines = stdout2.toString().split("\n");
                      result = util.getValue(lines, "features", ":", true).toLowerCase();
                    }
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  });
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
          if (_freebsd || _openbsd || _netbsd) {
            exec2("export LC_ALL=C; dmidecode -t 4 2>/dev/null; unset LC_ALL", function(error, stdout) {
              let flags = [];
              if (!error) {
                let parts = stdout.toString().split("	Flags:");
                const lines = parts.length > 1 ? parts[1].split("	Version:")[0].split["\n"] : [];
                lines.forEach(function(line) {
                  let flag = (line.indexOf("(") ? line.split("(")[0].toLowerCase() : "").trim().replace(/\t/g, "");
                  if (flag) {
                    flags.push(flag);
                  }
                });
              }
              result = flags.join(" ").trim();
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_darwin) {
            exec2("sysctl machdep.cpu.features", function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                if (lines.length > 0 && lines[0].indexOf("machdep.cpu.features:") !== -1) {
                  result = lines[0].split(":")[1].trim().toLowerCase();
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_sunos) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        });
      });
    }
    exports.cpuFlags = cpuFlags;
    function cpuCache(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = {
            l1d: -1,
            l1i: -1,
            l2: -1,
            l3: -1
          };
          if (_linux) {
            try {
              exec2("export LC_ALL=C; lscpu; unset LC_ALL", function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  lines.forEach(function(line) {
                    let parts = line.split(":");
                    if (parts[0].toUpperCase().indexOf("L1D CACHE") !== -1) {
                      result.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf("K") !== -1 ? 1024 : 1);
                    }
                    if (parts[0].toUpperCase().indexOf("L1I CACHE") !== -1) {
                      result.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf("K") !== -1 ? 1024 : 1);
                    }
                    if (parts[0].toUpperCase().indexOf("L2 CACHE") !== -1) {
                      result.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf("K") !== -1 ? 1024 : 1);
                    }
                    if (parts[0].toUpperCase().indexOf("L3 CACHE") !== -1) {
                      result.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf("K") !== -1 ? 1024 : 1);
                    }
                  });
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
          if (_freebsd || _openbsd || _netbsd) {
            exec2("export LC_ALL=C; dmidecode -t 7 2>/dev/null; unset LC_ALL", function(error, stdout) {
              let cache = [];
              if (!error) {
                const data = stdout.toString();
                cache = data.split("Cache Information");
                cache.shift();
              }
              for (let i = 0; i < cache.length; i++) {
                const lines = cache[i].split("\n");
                let cacheType = util.getValue(lines, "Socket Designation").toLowerCase().replace(" ", "-").split("-");
                cacheType = cacheType.length ? cacheType[0] : "";
                const sizeParts = util.getValue(lines, "Installed Size").split(" ");
                let size = parseInt(sizeParts[0], 10);
                const unit = sizeParts.length > 1 ? sizeParts[1] : "kb";
                size = size * (unit === "kb" ? 1024 : unit === "mb" ? 1024 * 1024 : unit === "gb" ? 1024 * 1024 * 1024 : 1);
                if (cacheType) {
                  if (cacheType === "l1") {
                    result.cache[cacheType + "d"] = size / 2;
                    result.cache[cacheType + "i"] = size / 2;
                  } else {
                    result.cache[cacheType] = size;
                  }
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_darwin) {
            exec2("sysctl hw.l1icachesize hw.l1dcachesize hw.l2cachesize hw.l3cachesize", function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                lines.forEach(function(line) {
                  let parts = line.split(":");
                  if (parts[0].toLowerCase().indexOf("hw.l1icachesize") !== -1) {
                    result.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf("K") !== -1 ? 1024 : 1);
                  }
                  if (parts[0].toLowerCase().indexOf("hw.l1dcachesize") !== -1) {
                    result.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf("K") !== -1 ? 1024 : 1);
                  }
                  if (parts[0].toLowerCase().indexOf("hw.l2cachesize") !== -1) {
                    result.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf("K") !== -1 ? 1024 : 1);
                  }
                  if (parts[0].toLowerCase().indexOf("hw.l3cachesize") !== -1) {
                    result.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf("K") !== -1 ? 1024 : 1);
                  }
                });
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_sunos) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_windows) {
            try {
              util.wmic("cpu get l2cachesize, l3cachesize /value").then((stdout, error) => {
                if (!error) {
                  let lines = stdout.split("\r\n");
                  result.l1d = 0;
                  result.l1i = 0;
                  result.l2 = util.getValue(lines, "l2cachesize", "=");
                  result.l3 = util.getValue(lines, "l3cachesize", "=");
                  if (result.l2) {
                    result.l2 = parseInt(result.l2, 10) * 1024;
                  }
                  if (result.l3) {
                    result.l3 = parseInt(result.l3, 10) * 1024;
                  }
                }
                util.wmic("path Win32_CacheMemory get CacheType,InstalledSize,Purpose").then((stdout2, error2) => {
                  if (!error2) {
                    let lines = stdout2.split("\r\n").filter((line) => line.trim() !== "").filter((line, idx) => idx > 0);
                    lines.forEach(function(line) {
                      if (line !== "") {
                        line = line.trim().split(/\s\s+/);
                        if (line[2] === "L1 Cache" && line[0] === "3") {
                          result.l1i = parseInt(line[1], 10);
                        }
                        if (line[2] === "L1 Cache" && line[0] === "4") {
                          result.l1d = parseInt(line[1], 10);
                        }
                      }
                    });
                  }
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                });
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.cpuCache = cpuCache;
    function getLoad() {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let loads = os.loadavg().map(function(x) {
            return x / util.cores();
          });
          let avgload = parseFloat(Math.max.apply(Math, loads).toFixed(2));
          let result = {};
          let now = Date.now() - _current_cpu.ms;
          if (now >= 200) {
            _current_cpu.ms = Date.now();
            const cpus = os.cpus();
            let totalUser = 0;
            let totalSystem = 0;
            let totalNice = 0;
            let totalIrq = 0;
            let totalIdle = 0;
            let cores = [];
            _corecount = cpus && cpus.length ? cpus.length : 0;
            for (let i = 0; i < _corecount; i++) {
              const cpu2 = cpus[i].times;
              totalUser += cpu2.user;
              totalSystem += cpu2.sys;
              totalNice += cpu2.nice;
              totalIdle += cpu2.idle;
              totalIrq += cpu2.irq;
              let tmp_tick = _cpus && _cpus[i] && _cpus[i].totalTick ? _cpus[i].totalTick : 0;
              let tmp_load = _cpus && _cpus[i] && _cpus[i].totalLoad ? _cpus[i].totalLoad : 0;
              let tmp_user = _cpus && _cpus[i] && _cpus[i].user ? _cpus[i].user : 0;
              let tmp_system = _cpus && _cpus[i] && _cpus[i].sys ? _cpus[i].sys : 0;
              let tmp_nice = _cpus && _cpus[i] && _cpus[i].nice ? _cpus[i].nice : 0;
              let tmp_idle = _cpus && _cpus[i] && _cpus[i].idle ? _cpus[i].idle : 0;
              let tmp_irq = _cpus && _cpus[i] && _cpus[i].irq ? _cpus[i].irq : 0;
              _cpus[i] = cpu2;
              _cpus[i].totalTick = _cpus[i].user + _cpus[i].sys + _cpus[i].nice + _cpus[i].irq + _cpus[i].idle;
              _cpus[i].totalLoad = _cpus[i].user + _cpus[i].sys + _cpus[i].nice + _cpus[i].irq;
              _cpus[i].currentTick = _cpus[i].totalTick - tmp_tick;
              _cpus[i].load = _cpus[i].totalLoad - tmp_load;
              _cpus[i].load_user = _cpus[i].user - tmp_user;
              _cpus[i].load_system = _cpus[i].sys - tmp_system;
              _cpus[i].load_nice = _cpus[i].nice - tmp_nice;
              _cpus[i].load_idle = _cpus[i].idle - tmp_idle;
              _cpus[i].load_irq = _cpus[i].irq - tmp_irq;
              cores[i] = {};
              cores[i].load = _cpus[i].load / _cpus[i].currentTick * 100;
              cores[i].load_user = _cpus[i].load_user / _cpus[i].currentTick * 100;
              cores[i].load_system = _cpus[i].load_system / _cpus[i].currentTick * 100;
              cores[i].load_nice = _cpus[i].load_nice / _cpus[i].currentTick * 100;
              cores[i].load_idle = _cpus[i].load_idle / _cpus[i].currentTick * 100;
              cores[i].load_irq = _cpus[i].load_irq / _cpus[i].currentTick * 100;
              cores[i].raw_load = _cpus[i].load;
              cores[i].raw_load_user = _cpus[i].load_user;
              cores[i].raw_load_system = _cpus[i].load_system;
              cores[i].raw_load_nice = _cpus[i].load_nice;
              cores[i].raw_load_idle = _cpus[i].load_idle;
              cores[i].raw_load_irq = _cpus[i].load_irq;
            }
            let totalTick = totalUser + totalSystem + totalNice + totalIrq + totalIdle;
            let totalLoad = totalUser + totalSystem + totalNice + totalIrq;
            let currentTick = totalTick - _current_cpu.tick;
            result = {
              avgload,
              currentload: (totalLoad - _current_cpu.load) / currentTick * 100,
              currentload_user: (totalUser - _current_cpu.user) / currentTick * 100,
              currentload_system: (totalSystem - _current_cpu.system) / currentTick * 100,
              currentload_nice: (totalNice - _current_cpu.nice) / currentTick * 100,
              currentload_idle: (totalIdle - _current_cpu.idle) / currentTick * 100,
              currentload_irq: (totalIrq - _current_cpu.irq) / currentTick * 100,
              raw_currentload: totalLoad - _current_cpu.load,
              raw_currentload_user: totalUser - _current_cpu.user,
              raw_currentload_system: totalSystem - _current_cpu.system,
              raw_currentload_nice: totalNice - _current_cpu.nice,
              raw_currentload_idle: totalIdle - _current_cpu.idle,
              raw_currentload_irq: totalIrq - _current_cpu.irq,
              cpus: cores
            };
            _current_cpu = {
              user: totalUser,
              nice: totalNice,
              system: totalSystem,
              idle: totalIdle,
              irq: totalIrq,
              tick: totalTick,
              load: totalLoad,
              ms: _current_cpu.ms,
              currentload: result.currentload,
              currentload_user: result.currentload_user,
              currentload_system: result.currentload_system,
              currentload_nice: result.currentload_nice,
              currentload_idle: result.currentload_idle,
              currentload_irq: result.currentload_irq,
              raw_currentload: result.raw_currentload,
              raw_currentload_user: result.raw_currentload_user,
              raw_currentload_system: result.raw_currentload_system,
              raw_currentload_nice: result.raw_currentload_nice,
              raw_currentload_idle: result.raw_currentload_idle,
              raw_currentload_irq: result.raw_currentload_irq
            };
          } else {
            let cores = [];
            for (let i = 0; i < _corecount; i++) {
              cores[i] = {};
              cores[i].load = _cpus[i].load / _cpus[i].currentTick * 100;
              cores[i].load_user = _cpus[i].load_user / _cpus[i].currentTick * 100;
              cores[i].load_system = _cpus[i].load_system / _cpus[i].currentTick * 100;
              cores[i].load_nice = _cpus[i].load_nice / _cpus[i].currentTick * 100;
              cores[i].load_idle = _cpus[i].load_idle / _cpus[i].currentTick * 100;
              cores[i].load_irq = _cpus[i].load_irq / _cpus[i].currentTick * 100;
              cores[i].raw_load = _cpus[i].load;
              cores[i].raw_load_user = _cpus[i].load_user;
              cores[i].raw_load_system = _cpus[i].load_system;
              cores[i].raw_load_nice = _cpus[i].load_nice;
              cores[i].raw_load_idle = _cpus[i].load_idle;
              cores[i].raw_load_irq = _cpus[i].load_irq;
            }
            result = {
              avgload,
              currentload: _current_cpu.currentload,
              currentload_user: _current_cpu.currentload_user,
              currentload_system: _current_cpu.currentload_system,
              currentload_nice: _current_cpu.currentload_nice,
              currentload_idle: _current_cpu.currentload_idle,
              currentload_irq: _current_cpu.currentload_irq,
              raw_currentload: _current_cpu.raw_currentload,
              raw_currentload_user: _current_cpu.raw_currentload_user,
              raw_currentload_system: _current_cpu.raw_currentload_system,
              raw_currentload_nice: _current_cpu.raw_currentload_nice,
              raw_currentload_idle: _current_cpu.raw_currentload_idle,
              raw_currentload_irq: _current_cpu.raw_currentload_irq,
              cpus: cores
            };
          }
          resolve(result);
        });
      });
    }
    function currentLoad(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          getLoad().then((result) => {
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        });
      });
    }
    exports.currentLoad = currentLoad;
    function getFullLoad() {
      return new Promise((resolve) => {
        process.nextTick(() => {
          const cpus = os.cpus();
          let totalUser = 0;
          let totalSystem = 0;
          let totalNice = 0;
          let totalIrq = 0;
          let totalIdle = 0;
          let result = 0;
          if (cpus && cpus.length) {
            for (let i = 0, len = cpus.length; i < len; i++) {
              const cpu2 = cpus[i].times;
              totalUser += cpu2.user;
              totalSystem += cpu2.sys;
              totalNice += cpu2.nice;
              totalIrq += cpu2.irq;
              totalIdle += cpu2.idle;
            }
            let totalTicks = totalIdle + totalIrq + totalNice + totalSystem + totalUser;
            result = (totalTicks - totalIdle) / totalTicks * 100;
          } else {
            result = 0;
          }
          resolve(result);
        });
      });
    }
    function fullLoad(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          getFullLoad().then((result) => {
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        });
      });
    }
    exports.fullLoad = fullLoad;
  }
});

// node_modules/@jedithepro/system-info/lib/memory.js
var require_memory = __commonJS({
  "node_modules/@jedithepro/system-info/lib/memory.js"(exports) {
    "use strict";
    var os = require("os");
    var exec2 = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var util = require_util2();
    var fs2 = require("fs");
    var _platform = process.platform;
    var _linux = _platform === "linux";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    var OSX_RAM_manufacturers = {
      "0x014F": "Transcend Information",
      "0x2C00": "Micron Technology Inc.",
      "0x802C": "Micron Technology Inc.",
      "0x80AD": "Hynix Semiconductor Inc.",
      "0x80CE": "Samsung Electronics Inc.",
      "0xAD00": "Hynix Semiconductor Inc.",
      "0xCE00": "Samsung Electronics Inc.",
      "0x02FE": "Elpida",
      "0x5105": "Qimonda AG i. In.",
      "0x8551": "Qimonda AG i. In.",
      "0x859B": "Crucial",
      "0x04CD": "G-Skill"
    };
    function mem(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = {
            total: os.totalmem(),
            free: os.freemem(),
            used: os.totalmem() - os.freemem(),
            active: os.totalmem() - os.freemem(),
            available: os.freemem(),
            buffers: 0,
            cached: 0,
            slab: 0,
            buffcache: 0,
            swaptotal: 0,
            swapused: 0,
            swapfree: 0
          };
          if (_linux) {
            fs2.readFile("/proc/meminfo", function(error, stdout) {
              if (!error) {
                const lines = stdout.toString().split("\n");
                result.total = parseInt(util.getValue(lines, "memtotal"), 10);
                result.total = result.total ? result.total * 1024 : os.totalmem();
                result.free = parseInt(util.getValue(lines, "memfree"), 10);
                result.free = result.free ? result.free * 1024 : os.freemem();
                result.used = result.total - result.free;
                result.buffers = parseInt(util.getValue(lines, "buffers"), 10);
                result.buffers = result.buffers ? result.buffers * 1024 : 0;
                result.cached = parseInt(util.getValue(lines, "cached"), 10);
                result.cached = result.cached ? result.cached * 1024 : 0;
                result.slab = parseInt(util.getValue(lines, "slab"), 10);
                result.slab = result.slab ? result.slab * 1024 : 0;
                result.buffcache = result.buffers + result.cached + result.slab;
                let available = parseInt(util.getValue(lines, "memavailable"), 10);
                result.available = available ? available * 1024 : result.free + result.buffcache;
                result.active = result.total - result.available;
                result.swaptotal = parseInt(util.getValue(lines, "swaptotal"), 10);
                result.swaptotal = result.swaptotal ? result.swaptotal * 1024 : 0;
                result.swapfree = parseInt(util.getValue(lines, "swapfree"), 10);
                result.swapfree = result.swapfree ? result.swapfree * 1024 : 0;
                result.swapused = result.swaptotal - result.swapfree;
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_freebsd || _openbsd || _netbsd) {
            exec2('/sbin/sysctl -a 2>/dev/null | grep -E "hw.realmem|hw.physmem|vm.stats.vm.v_page_count|vm.stats.vm.v_wire_count|vm.stats.vm.v_active_count|vm.stats.vm.v_inactive_count|vm.stats.vm.v_cache_count|vm.stats.vm.v_free_count|vm.stats.vm.v_page_size"', function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                const pagesize = parseInt(util.getValue(lines, "vm.stats.vm.v_page_size"), 10);
                const inactive = parseInt(util.getValue(lines, "vm.stats.vm.v_inactive_count"), 10) * pagesize;
                const cache = parseInt(util.getValue(lines, "vm.stats.vm.v_cache_count"), 10) * pagesize;
                result.total = parseInt(util.getValue(lines, "hw.realmem"), 10);
                if (isNaN(result.total))
                  result.total = parseInt(util.getValue(lines, "hw.physmem"), 10);
                result.free = parseInt(util.getValue(lines, "vm.stats.vm.v_free_count"), 10) * pagesize;
                result.buffcache = inactive + cache;
                result.available = result.buffcache + result.free;
                result.active = result.total - result.free - result.buffcache;
                result.swaptotal = 0;
                result.swapfree = 0;
                result.swapused = 0;
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_sunos) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_darwin) {
            exec2('vm_stat 2>/dev/null | grep "Pages active"', function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                result.active = parseInt(lines[0].split(":")[1], 10) * 4096;
                result.buffcache = result.used - result.active;
                result.available = result.free + result.buffcache;
              }
              exec2("sysctl -n vm.swapusage 2>/dev/null", function(error2, stdout2) {
                if (!error2) {
                  let lines = stdout2.toString().split("\n");
                  if (lines.length > 0) {
                    let line = lines[0].replace(/,/g, ".").replace(/M/g, "");
                    line = line.trim().split("  ");
                    for (let i = 0; i < line.length; i++) {
                      if (line[i].toLowerCase().indexOf("total") !== -1)
                        result.swaptotal = parseFloat(line[i].split("=")[1].trim()) * 1024 * 1024;
                      if (line[i].toLowerCase().indexOf("used") !== -1)
                        result.swapused = parseFloat(line[i].split("=")[1].trim()) * 1024 * 1024;
                      if (line[i].toLowerCase().indexOf("free") !== -1)
                        result.swapfree = parseFloat(line[i].split("=")[1].trim()) * 1024 * 1024;
                    }
                  }
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            });
          }
          if (_windows) {
            let swaptotal = 0;
            let swapused = 0;
            try {
              util.wmic("pagefile get AllocatedBaseSize, CurrentUsage").then((stdout, error) => {
                if (!error) {
                  let lines = stdout.split("\r\n").filter((line) => line.trim() !== "").filter((line, idx) => idx > 0);
                  lines.forEach(function(line) {
                    if (line !== "") {
                      line = line.trim().split(/\s\s+/);
                      swaptotal = swaptotal + parseInt(line[0], 10);
                      swapused = swapused + parseInt(line[1], 10);
                    }
                  });
                }
                result.swaptotal = swaptotal * 1024 * 1024;
                result.swapused = swapused * 1024 * 1024;
                result.swapfree = result.swaptotal - result.swapused;
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.mem = mem;
    function memLayout(callback) {
      function getManufacturer(manId) {
        if ({}.hasOwnProperty.call(OSX_RAM_manufacturers, manId)) {
          return OSX_RAM_manufacturers[manId];
        }
        return manId;
      }
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = [];
          if (_linux || _freebsd || _openbsd || _netbsd) {
            exec2('export LC_ALL=C; dmidecode -t memory 2>/dev/null | grep -iE "Size:|Type|Speed|Manufacturer|Form Factor|Locator|Memory Device|Serial Number|Voltage|Part Number"; unset LC_ALL', function(error, stdout) {
              if (!error) {
                let devices = stdout.toString().split("Memory Device");
                devices.shift();
                devices.forEach(function(device) {
                  let lines = device.split("\n");
                  const sizeString = util.getValue(lines, "Size");
                  const size = sizeString.indexOf("GB") >= 0 ? parseInt(sizeString, 10) * 1024 * 1024 * 1024 : parseInt(sizeString, 10) * 1024 * 1024;
                  if (parseInt(util.getValue(lines, "Size"), 10) > 0) {
                    result.push({
                      size,
                      bank: util.getValue(lines, "Bank Locator"),
                      type: util.getValue(lines, "Type:"),
                      clockSpeed: util.getValue(lines, "Configured Clock Speed:") ? parseInt(util.getValue(lines, "Configured Clock Speed:"), 10) : util.getValue(lines, "Speed:") ? parseInt(util.getValue(lines, "Speed:"), 10) : -1,
                      formFactor: util.getValue(lines, "Form Factor:"),
                      manufacturer: util.getValue(lines, "Manufacturer:"),
                      partNum: util.getValue(lines, "Part Number:"),
                      serialNum: util.getValue(lines, "Serial Number:"),
                      voltageConfigured: parseFloat(util.getValue(lines, "Configured Voltage:") || -1),
                      voltageMin: parseFloat(util.getValue(lines, "Minimum Voltage:") || -1),
                      voltageMax: parseFloat(util.getValue(lines, "Maximum Voltage:") || -1)
                    });
                  } else {
                    result.push({
                      size: 0,
                      bank: util.getValue(lines, "Bank Locator"),
                      type: "Empty",
                      clockSpeed: 0,
                      formFactor: util.getValue(lines, "Form Factor:"),
                      partNum: "",
                      serialNum: "",
                      voltageConfigured: -1,
                      voltageMin: -1,
                      voltageMax: -1
                    });
                  }
                });
              }
              if (!result.length) {
                result.push({
                  size: os.totalmem(),
                  bank: "",
                  type: "",
                  clockSpeed: 0,
                  formFactor: "",
                  partNum: "",
                  serialNum: "",
                  voltageConfigured: -1,
                  voltageMin: -1,
                  voltageMax: -1
                });
                try {
                  let stdout2 = execSync("cat /proc/cpuinfo 2>/dev/null");
                  let lines = stdout2.toString().split("\n");
                  let model = util.getValue(lines, "hardware", ":", true).toUpperCase();
                  let version = util.getValue(lines, "revision", ":", true).toLowerCase();
                  if (model === "BCM2835" || model === "BCM2708" || model === "BCM2709" || model === "BCM2835" || model === "BCM2837") {
                    const clockSpeed = {
                      "0": 400,
                      "1": 450,
                      "2": 450,
                      "3": 3200
                    };
                    result[0].clockSpeed = version && version[2] && clockSpeed[version[2]] || 400;
                    result[0].clockSpeed = version && version[4] && version[4] === "d" ? "500" : result[0].clockSpeed;
                    result[0].type = "LPDDR2";
                    result[0].type = version && version[2] && version[2] === "3" ? "LPDDR4" : result[0].type;
                    result[0].formFactor = "SoC";
                    stdout2 = execSync("vcgencmd get_config sdram_freq 2>/dev/null");
                    lines = stdout2.toString().split("\n");
                    let freq = parseInt(util.getValue(lines, "sdram_freq", "=", true), 10) || 0;
                    if (freq) {
                      result.clockSpeed = freq;
                    }
                    stdout2 = execSync("vcgencmd measure_volts sdram_p 2>/dev/null");
                    lines = stdout2.toString().split("\n");
                    let voltage = parseFloat(util.getValue(lines, "volt", "=", true)) || 0;
                    if (voltage) {
                      result[0].voltageConfigured = voltage;
                      result[0].voltageMin = voltage;
                      result[0].voltageMax = voltage;
                    }
                  }
                } catch (e) {
                  util.noop();
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_darwin) {
            exec2("system_profiler SPMemoryDataType", function(error, stdout) {
              if (!error) {
                let devices = stdout.toString().split("        BANK ");
                let hasBank = true;
                if (devices.length === 1) {
                  devices = stdout.toString().split("        DIMM");
                  hasBank = false;
                }
                devices.shift();
                devices.forEach(function(device) {
                  let lines = device.split("\n");
                  const bank = (hasBank ? "BANK " : "DIMM") + lines[0].trim().split("/")[0];
                  const size = parseInt(util.getValue(lines, "          Size"));
                  if (size) {
                    result.push({
                      size: size * 1024 * 1024 * 1024,
                      bank,
                      type: util.getValue(lines, "          Type:"),
                      clockSpeed: parseInt(util.getValue(lines, "          Speed:"), 10),
                      formFactor: "",
                      manufacturer: getManufacturer(util.getValue(lines, "          Manufacturer:")),
                      partNum: util.getValue(lines, "          Part Number:"),
                      serialNum: util.getValue(lines, "          Serial Number:"),
                      voltageConfigured: -1,
                      voltageMin: -1,
                      voltageMax: -1
                    });
                  } else {
                    result.push({
                      size: 0,
                      bank,
                      type: "Empty",
                      clockSpeed: 0,
                      formFactor: "",
                      manufacturer: "",
                      partNum: "",
                      serialNum: "",
                      voltageConfigured: -1,
                      voltageMin: -1,
                      voltageMax: -1
                    });
                  }
                });
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_sunos) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_windows) {
            const memoryTypes = "Unknown|Other|DRAM|Synchronous DRAM|Cache DRAM|EDO|EDRAM|VRAM|SRAM|RAM|ROM|FLASH|EEPROM|FEPROM|EPROM|CDRAM|3DRAM|SDRAM|SGRAM|RDRAM|DDR|DDR2|DDR2 FB-DIMM|Reserved|DDR3|FBD2|DDR4|LPDDR|LPDDR2|LPDDR3|LPDDR4".split("|");
            const FormFactors = "Unknown|Other|SIP|DIP|ZIP|SOJ|Proprietary|SIMM|DIMM|TSOP|PGA|RIMM|SODIMM|SRIMM|SMD|SSMP|QFP|TQFP|SOIC|LCC|PLCC|BGA|FPBGA|LGA".split("|");
            try {
              util.wmic("memorychip get /value").then((stdout, error) => {
                if (!error) {
                  let devices = stdout.toString().split("BankL");
                  devices.shift();
                  devices.forEach(function(device) {
                    let lines = device.split("\r\n");
                    result.push({
                      size: parseInt(util.getValue(lines, "Capacity", "="), 10) || 0,
                      bank: util.getValue(lines, "abel", "="),
                      type: memoryTypes[parseInt(util.getValue(lines, "MemoryType", "="), 10)],
                      clockSpeed: parseInt(util.getValue(lines, "ConfiguredClockSpeed", "="), 10) || 0,
                      formFactor: FormFactors[parseInt(util.getValue(lines, "FormFactor", "="), 10) || 0],
                      manufacturer: util.getValue(lines, "Manufacturer", "="),
                      partNum: util.getValue(lines, "PartNumber", "="),
                      serialNum: util.getValue(lines, "SerialNumber", "="),
                      voltageConfigured: (parseInt(util.getValue(lines, "ConfiguredVoltage", "="), 10) || 0) / 1e3,
                      voltageMin: (parseInt(util.getValue(lines, "MinVoltage", "="), 10) || 0) / 1e3,
                      voltageMax: (parseInt(util.getValue(lines, "MaxVoltage", "="), 10) || 0) / 1e3
                    });
                  });
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.memLayout = memLayout;
  }
});

// node_modules/@jedithepro/system-info/lib/battery.js
var require_battery = __commonJS({
  "node_modules/@jedithepro/system-info/lib/battery.js"(exports, module2) {
    "use strict";
    var exec2 = require("child_process").exec;
    var fs2 = require("fs");
    var util = require_util2();
    var _platform = process.platform;
    var _linux = _platform === "linux";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    module2.exports = function(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = {
            hasbattery: false,
            cyclecount: 0,
            ischarging: false,
            designedcapacity: 0,
            maxcapacity: 0,
            currentcapacity: 0,
            voltage: 0,
            capacityUnit: "",
            percent: 0,
            timeremaining: -1,
            acconnected: true,
            type: "",
            model: "",
            manufacturer: "",
            serial: ""
          };
          if (_linux) {
            let battery_path = "";
            if (fs2.existsSync("/sys/class/power_supply/BAT1/uevent")) {
              battery_path = "/sys/class/power_supply/BAT1/";
            } else if (fs2.existsSync("/sys/class/power_supply/BAT0/uevent")) {
              battery_path = "/sys/class/power_supply/BAT0/";
            }
            if (battery_path) {
              fs2.readFile(battery_path + "uevent", function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  result.ischarging = util.getValue(lines, "POWER_SUPPLY_STATUS", "=").toLowerCase() === "charging";
                  result.acconnected = result.ischarging;
                  result.voltage = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_VOLTAGE_NOW", "="), 10) / 1e6;
                  result.capacityUnit = result.voltage ? "mWh" : "mAh";
                  result.cyclecount = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_CYCLE_COUNT", "="), 10);
                  result.maxcapacity = Math.round(parseInt("0" + util.getValue(lines, "POWER_SUPPLY_CHARGE_FULL", "="), 10) / 1e3 / (result.voltage || 1));
                  result.designedcapacity = Math.round(parseInt("0" + util.getValue(lines, "POWER_SUPPLY_CHARGE_FULL_DESIGN", "="), 10) / 1e3 / (result.voltage || 1)) | result.maxcapacity;
                  result.currentcapacity = Math.round(parseInt("0" + util.getValue(lines, "POWER_SUPPLY_CHARGE_NOW", "="), 10) / 1e3 / (result.voltage || 1));
                  if (!result.maxcapacity) {
                    result.maxcapacity = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_ENERGY_FULL", "="), 10) / 1e3;
                    result.designcapacity = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_ENERGY_FULL_DESIGN", "="), 10) / 1e3 | result.maxcapacity;
                    result.currentcapacity = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_ENERGY_NOW", "="), 10) / 1e3;
                  }
                  const percent = util.getValue(lines, "POWER_SUPPLY_CAPACITY", "=");
                  const energy = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_ENERGY_NOW", "="), 10);
                  const power = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_POWER_NOW", "="), 10);
                  const current = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_CURRENT_NOW", "="), 10);
                  result.percent = parseInt("0" + percent, 10);
                  if (result.maxcapacity && result.currentcapacity) {
                    result.hasbattery = true;
                    if (!percent) {
                      result.percent = 100 * result.currentcapacity / result.maxcapacity;
                    }
                  }
                  if (result.ischarging) {
                    result.hasbattery = true;
                  }
                  if (energy && power) {
                    result.timeremaining = Math.floor(energy / power * 60);
                  } else if (current && result.currentcapacity) {
                    result.timeremaining = Math.floor(result.currentcapacity / current * 60);
                  }
                  result.type = util.getValue(lines, "POWER_SUPPLY_TECHNOLOGY", "=");
                  result.model = util.getValue(lines, "POWER_SUPPLY_MODEL_NAME", "=");
                  result.manufacturer = util.getValue(lines, "POWER_SUPPLY_MANUFACTURER", "=");
                  result.serial = util.getValue(lines, "POWER_SUPPLY_SERIAL_NUMBER", "=");
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              });
            } else {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
          if (_freebsd || _openbsd || _netbsd) {
            exec2("sysctl hw.acpi.battery hw.acpi.acline", function(error, stdout) {
              let lines = stdout.toString().split("\n");
              const batteries = parseInt("0" + util.getValue(lines, "hw.acpi.battery.units"), 10);
              const percent = parseInt("0" + util.getValue(lines, "hw.acpi.battery.life"), 10);
              result.hasbattery = batteries > 0;
              result.cyclecount = -1;
              result.ischarging = util.getValue(lines, "hw.acpi.acline") !== "1";
              result.acconnected = result.ischarging;
              result.maxcapacity = -1;
              result.currentcapacity = -1;
              result.capacityUnit = "unknown";
              result.percent = batteries ? percent : -1;
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_darwin) {
            exec2('ioreg -n AppleSmartBattery -r | egrep "CycleCount|IsCharging|DesignCapacity|MaxCapacity|CurrentCapacity|BatterySerialNumber|TimeRemaining|Voltage"; pmset -g batt | grep %', function(error, stdout) {
              if (stdout) {
                let lines = stdout.toString().replace(/ +/g, "").replace(/"+/g, "").replace(/-/g, "").split("\n");
                result.cyclecount = parseInt("0" + util.getValue(lines, "cyclecount", "="), 10);
                result.voltage = parseInt("0" + util.getValue(lines, "voltage", "="), 10) / 1e3;
                result.capacityUnit = result.voltage ? "mWh" : "mAh";
                result.maxcapacity = Math.round(parseInt("0" + util.getValue(lines, "maxcapacity", "="), 10) * (result.voltage || 1));
                result.currentcapacity = Math.round(parseInt("0" + util.getValue(lines, "currentcapacity", "="), 10) * (result.voltage || 1));
                result.designedcapacity = Math.round(parseInt("0" + util.getValue(lines, "DesignCapacity", "="), 10) * (result.voltage || 1));
                result.manufacturer = "Apple";
                result.serial = util.getValue(lines, "BatterySerialNumber", "=");
                let percent = -1;
                const line = util.getValue(lines, "internal", "Battery");
                let parts = line.split(";");
                if (parts && parts[0]) {
                  let parts2 = parts[0].split("	");
                  if (parts2 && parts2[1]) {
                    percent = parseFloat(parts2[1].trim().replace(/%/g, ""));
                  }
                }
                if (parts && parts[1]) {
                  result.ischarging = parts[1].trim() === "charging";
                  result.acconnected = parts[1].trim() !== "discharging";
                } else {
                  result.ischarging = util.getValue(lines, "ischarging", "=").toLowerCase() === "yes";
                  result.acconnected = result.ischarging;
                }
                if (result.maxcapacity && result.currentcapacity) {
                  result.hasbattery = true;
                  result.type = "Li-ion";
                  result.percent = percent !== -1 ? percent : Math.round(100 * result.currentcapacity / result.maxcapacity);
                  if (!result.ischarging) {
                    result.timeremaining = parseInt("0" + util.getValue(lines, "TimeRemaining", "="), 10);
                  }
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_sunos) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_windows) {
            try {
              util.wmic("Path Win32_Battery Get BatteryStatus, DesignCapacity, EstimatedChargeRemaining, DesignVoltage, FullChargeCapacity /value").then((stdout) => {
                if (stdout) {
                  let lines = stdout.split("\r\n");
                  let status = util.getValue(lines, "BatteryStatus", "=").trim();
                  if (status && status != "10") {
                    const statusValue = parseInt(status);
                    result.hasbattery = true;
                    result.maxcapacity = parseInt(util.getValue(lines, "DesignCapacity", "=") || 0);
                    result.designcapacity = parseInt(util.getValue(lines, "DesignCapacity", "=") || 0);
                    result.voltage = parseInt(util.getValue(lines, "DesignVoltage", "=") || 0) / 1e3;
                    result.capacityUnit = "mWh";
                    result.percent = parseInt(util.getValue(lines, "EstimatedChargeRemaining", "=") || 0);
                    result.currentcapacity = parseInt(result.maxcapacity * result.percent / 100);
                    result.ischarging = statusValue >= 6 && statusValue <= 9 || statusValue === 11 || !(statusValue === 3) && !(statusValue === 1) && result.percent < 100;
                    result.acconnected = result.ischarging || statusValue === 2;
                  }
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    };
  }
});

// node_modules/@jedithepro/system-info/lib/graphics.js
var require_graphics = __commonJS({
  "node_modules/@jedithepro/system-info/lib/graphics.js"(exports) {
    "use strict";
    var os = require("os");
    var exec2 = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var util = require_util2();
    var _platform = process.platform;
    var _linux = _platform === "linux";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    var _resolutionx = 0;
    var _resolutiony = 0;
    var _pixeldepth = 0;
    var _refreshrate = 0;
    var videoTypes = {
      "-2": "UNINITIALIZED",
      "-1": "OTHER",
      "0": "HD15",
      "1": "SVIDEO",
      "2": "Composite video",
      "3": "Component video",
      "4": "DVI",
      "5": "HDMI",
      "6": "LVDS",
      "8": "D_JPN",
      "9": "SDI",
      "10": "DP",
      "11": "DP embedded",
      "12": "UDI",
      "13": "UDI embedded",
      "14": "SDTVDONGLE",
      "15": "MIRACAST",
      "2147483648": "INTERNAL"
    };
    function graphics(callback) {
      function parseLinesDarwin(lines) {
        let starts = [];
        let level = -1;
        let lastlevel = -1;
        let controllers = [];
        let displays = [];
        let currentController = {
          vendor: "",
          model: "",
          bus: "",
          vram: -1,
          vramDynamic: false
        };
        let currentDisplay = {
          vendor: "",
          model: "",
          deviceName: "",
          main: false,
          builtin: false,
          connection: "",
          sizex: -1,
          sizey: -1,
          pixeldepth: -1,
          resolutionx: -1,
          resolutiony: -1,
          currentResX: -1,
          currentResY: -1,
          positionX: 0,
          positionY: 0,
          currentRefreshRate: -1
        };
        for (let i = 0; i < lines.length; i++) {
          if ("" !== lines[i].trim()) {
            let start = lines[i].search(/\S|$/);
            if (-1 === starts.indexOf(start)) {
              starts.push(start);
            }
            level = starts.indexOf(start);
            if (level < lastlevel) {
              if (Object.keys(currentController).length > 0) {
                controllers.push(currentController);
                currentController = {
                  vendor: "",
                  model: "",
                  bus: "",
                  vram: -1,
                  vramDynamic: false
                };
              }
              if (Object.keys(currentDisplay).length > 0) {
                displays.push(currentDisplay);
                currentDisplay = {
                  vendor: "",
                  model: "",
                  deviceName: "",
                  main: false,
                  builtin: false,
                  connection: "",
                  sizex: -1,
                  sizey: -1,
                  pixeldepth: -1,
                  resolutionx: -1,
                  resolutiony: -1,
                  currentResX: -1,
                  currentResY: -1,
                  positionX: 0,
                  positionY: 0,
                  currentRefreshRate: -1
                };
              }
            }
            lastlevel = level;
            let parts = lines[i].split(":");
            if (2 === level) {
              if (parts.length > 1 && parts[0].replace(/ +/g, "").toLowerCase().indexOf("chipsetmodel") !== -1)
                currentController.model = parts[1].trim();
              if (parts.length > 1 && parts[0].replace(/ +/g, "").toLowerCase().indexOf("bus") !== -1)
                currentController.bus = parts[1].trim();
              if (parts.length > 1 && parts[0].replace(/ +/g, "").toLowerCase().indexOf("vendor") !== -1)
                currentController.vendor = parts[1].split("(")[0].trim();
              if (parts.length > 1 && parts[0].replace(/ +/g, "").toLowerCase().indexOf("vram(total)") !== -1) {
                currentController.vram = parseInt(parts[1]);
                if (parts[1].toLowerCase().indexOf("gb") !== -1) {
                  currentController.vram = currentController.vram * 1024;
                }
                currentController.vramDynamic = false;
              }
              if (parts.length > 1 && parts[0].replace(/ +/g, "").toLowerCase().indexOf("vram(dynamic,max)") !== -1) {
                currentController.vram = parseInt(parts[1]);
                if (parts[1].toLowerCase().indexOf("gb") !== -1) {
                  currentController.vram = currentController.vram * 1024;
                }
                currentController.vramDynamic = true;
              }
            }
            if (3 === level) {
              if (parts.length > 1 && "" === parts[1]) {
                currentDisplay.vendor = "";
                currentDisplay.model = parts[0].trim();
                currentDisplay.main = false;
                currentDisplay.builtin = false;
                currentDisplay.connection = "";
                currentDisplay.sizex = -1;
                currentDisplay.sizey = -1;
                currentDisplay.positionX = 0;
                currentDisplay.positionY = 0;
                currentDisplay.pixeldepth = -1;
              }
            }
            if (4 === level) {
              if (parts.length > 1 && parts[0].replace(/ +/g, "").toLowerCase().indexOf("resolution") !== -1) {
                let resolution = parts[1].split("x");
                currentDisplay.resolutionx = resolution.length > 1 ? parseInt(resolution[0]) : 0;
                currentDisplay.resolutiony = resolution.length > 1 ? parseInt(resolution[1]) : 0;
                currentDisplay.currentResX = currentDisplay.resolutionx;
                currentDisplay.currentResY = currentDisplay.resolutiony;
              }
              if (parts.length > 1 && parts[0].replace(/ +/g, "").toLowerCase().indexOf("pixeldepth") !== -1)
                currentDisplay.pixeldepth = parseInt(parts[1]);
              if (parts.length > 1 && parts[0].replace(/ +/g, "").toLowerCase().indexOf("framebufferdepth") !== -1)
                currentDisplay.pixeldepth = parseInt(parts[1]);
              if (parts.length > 1 && parts[0].replace(/ +/g, "").toLowerCase().indexOf("maindisplay") !== -1 && parts[1].replace(/ +/g, "").toLowerCase() === "yes")
                currentDisplay.main = true;
              if (parts.length > 1 && parts[0].replace(/ +/g, "").toLowerCase().indexOf("built-in") !== -1 && parts[1].replace(/ +/g, "").toLowerCase() === "yes") {
                currentDisplay.builtin = true;
                currentDisplay.connection = "";
              }
              if (parts.length > 1 && parts[0].replace(/ +/g, "").toLowerCase().indexOf("connectiontype") !== -1) {
                currentDisplay.builtin = false;
                currentDisplay.connection = parts[1].trim();
              }
            }
          }
        }
        if (Object.keys(currentController).length > 0) {
          controllers.push(currentController);
        }
        if (Object.keys(currentDisplay).length > 0) {
          displays.push(currentDisplay);
        }
        return {
          controllers,
          displays
        };
      }
      function parseLinesLinuxControllers(lines) {
        let controllers = [];
        let currentController = {
          vendor: "",
          model: "",
          bus: "",
          vram: -1,
          vramDynamic: false
        };
        let isGraphicsController = false;
        let pciIDs = [];
        try {
          pciIDs = execSync('export LC_ALL=C; dmidecode -t 9 2>/dev/null; unset LC_ALL | grep "Bus Address: "').toString().split("\n");
          for (let i = 0; i < pciIDs.length; i++) {
            pciIDs[i] = pciIDs[i].replace("Bus Address:", "").replace("0000:", "").trim();
          }
          pciIDs = pciIDs.filter(function(el) {
            return el != null && el;
          });
        } catch (e) {
          util.noop();
        }
        for (let i = 0; i < lines.length; i++) {
          if ("" !== lines[i].trim()) {
            if (" " !== lines[i][0] && "	" !== lines[i][0]) {
              let isExternal = pciIDs.indexOf(lines[i].split(" ")[0]) >= 0;
              let vgapos = lines[i].toLowerCase().indexOf(" vga ");
              let _3dcontrollerpos = lines[i].toLowerCase().indexOf("3d controller");
              if (vgapos !== -1 || _3dcontrollerpos !== -1) {
                if (_3dcontrollerpos !== -1 && vgapos === -1) {
                  vgapos = _3dcontrollerpos;
                }
                if (currentController.vendor || currentController.model || currentController.bus || currentController.vram !== -1 || currentController.vramDynamic) {
                  controllers.push(currentController);
                  currentController = {
                    vendor: "",
                    model: "",
                    bus: "",
                    vram: -1,
                    vramDynamic: false
                  };
                }
                isGraphicsController = true;
                let endpos = lines[i].search(/\[[0-9a-f]{4}:[0-9a-f]{4}]|$/);
                let parts = lines[i].substr(vgapos, endpos - vgapos).split(":");
                if (parts.length > 1) {
                  parts[1] = parts[1].trim();
                  if (parts[1].toLowerCase().indexOf("corporation") >= 0) {
                    currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf("corporation") + 11).trim();
                    currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf("corporation") + 11, 200).trim().split("(")[0];
                    currentController.bus = pciIDs.length > 0 && isExternal ? "PCIe" : "Onboard";
                    currentController.vram = -1;
                    currentController.vramDynamic = false;
                  } else if (parts[1].toLowerCase().indexOf(" inc.") >= 0) {
                    if ((parts[1].match(new RegExp("]", "g")) || []).length > 1) {
                      currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf("]") + 1).trim();
                      currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf("]") + 1, 200).trim().split("(")[0].trim();
                    } else {
                      currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf(" inc.") + 5).trim();
                      currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf(" inc.") + 5, 200).trim().split("(")[0].trim();
                    }
                    currentController.bus = pciIDs.length > 0 && isExternal ? "PCIe" : "Onboard";
                    currentController.vram = -1;
                    currentController.vramDynamic = false;
                  } else if (parts[1].toLowerCase().indexOf(" ltd.") >= 0) {
                    if ((parts[1].match(new RegExp("]", "g")) || []).length > 1) {
                      currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf("]") + 1).trim();
                      currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf("]") + 1, 200).trim().split("(")[0].trim();
                    } else {
                      currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf(" ltd.") + 5).trim();
                      currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf(" ltd.") + 5, 200).trim().split("(")[0].trim();
                    }
                  }
                }
              } else {
                isGraphicsController = false;
              }
            }
            if (isGraphicsController) {
              let parts = lines[i].split(":");
              if (parts.length > 1 && parts[0].replace(/ +/g, "").toLowerCase().indexOf("devicename") !== -1 && parts[1].toLowerCase().indexOf("onboard") !== -1)
                currentController.bus = "Onboard";
              if (parts.length > 1 && parts[0].replace(/ +/g, "").toLowerCase().indexOf("region") !== -1 && parts[1].toLowerCase().indexOf("memory") !== -1) {
                let memparts = parts[1].split("=");
                if (memparts.length > 1) {
                  currentController.vram = parseInt(memparts[1]);
                }
              }
            }
          }
        }
        if (currentController.vendor || currentController.model || currentController.bus || currentController.vram !== -1 || currentController.vramDynamic) {
          controllers.push(currentController);
        }
        return controllers;
      }
      function parseLinesLinuxEdid(edid) {
        let result = {
          vendor: "",
          model: "",
          deviceName: "",
          main: false,
          builtin: false,
          connection: "",
          sizex: -1,
          sizey: -1,
          pixeldepth: -1,
          resolutionx: -1,
          resolutiony: -1,
          currentResX: -1,
          currentResY: -1,
          positionX: 0,
          positionY: 0,
          currentRefreshRate: -1
        };
        let start = 108;
        if (edid.substr(start, 6) === "000000") {
          start += 36;
        }
        if (edid.substr(start, 6) === "000000") {
          start += 36;
        }
        if (edid.substr(start, 6) === "000000") {
          start += 36;
        }
        if (edid.substr(start, 6) === "000000") {
          start += 36;
        }
        result.resolutionx = parseInt("0x0" + edid.substr(start + 8, 1) + edid.substr(start + 4, 2));
        result.resolutiony = parseInt("0x0" + edid.substr(start + 14, 1) + edid.substr(start + 10, 2));
        result.sizex = parseInt("0x0" + edid.substr(start + 28, 1) + edid.substr(start + 24, 2));
        result.sizey = parseInt("0x0" + edid.substr(start + 29, 1) + edid.substr(start + 26, 2));
        start = edid.indexOf("000000fc00");
        if (start >= 0) {
          let model_raw = edid.substr(start + 10, 26);
          if (model_raw.indexOf("0a") !== -1) {
            model_raw = model_raw.substr(0, model_raw.indexOf("0a"));
          }
          try {
            if (model_raw.length > 2) {
              result.model = model_raw.match(/.{1,2}/g).map(function(v) {
                return String.fromCharCode(parseInt(v, 16));
              }).join("");
            }
          } catch (e) {
            util.noop();
          }
        } else {
          result.model = "";
        }
        return result;
      }
      function parseLinesLinuxDisplays(lines, depth) {
        let displays = [];
        let currentDisplay = {
          vendor: "",
          model: "",
          deviceName: "",
          main: false,
          builtin: false,
          connection: "",
          sizex: -1,
          sizey: -1,
          pixeldepth: -1,
          resolutionx: -1,
          resolutiony: -1,
          currentResX: -1,
          currentResY: -1,
          positionX: 0,
          positionY: 0,
          currentRefreshRate: -1
        };
        let is_edid = false;
        let is_current = false;
        let edid_raw = "";
        let start = 0;
        for (let i = 1; i < lines.length; i++) {
          if ("" !== lines[i].trim()) {
            if (" " !== lines[i][0] && "	" !== lines[i][0] && lines[i].toLowerCase().indexOf(" connected ") !== -1) {
              if (currentDisplay.model || currentDisplay.main || currentDisplay.builtin || currentDisplay.connection || currentDisplay.sizex !== -1 || currentDisplay.pixeldepth !== -1 || currentDisplay.resolutionx !== -1) {
                displays.push(currentDisplay);
                currentDisplay = {
                  vendor: "",
                  model: "",
                  main: false,
                  builtin: false,
                  connection: "",
                  sizex: -1,
                  sizey: -1,
                  pixeldepth: -1,
                  resolutionx: -1,
                  resolutiony: -1,
                  currentResX: -1,
                  currentResY: -1,
                  positionX: 0,
                  positionY: 0,
                  currentRefreshRate: -1
                };
              }
              let parts = lines[i].split(" ");
              currentDisplay.connection = parts[0];
              currentDisplay.main = lines[i].toLowerCase().indexOf(" primary ") >= 0;
              currentDisplay.builtin = parts[0].toLowerCase().indexOf("edp") >= 0;
            }
            if (is_edid) {
              if (lines[i].search(/\S|$/) > start) {
                edid_raw += lines[i].toLowerCase().trim();
              } else {
                let edid_decoded = parseLinesLinuxEdid(edid_raw);
                currentDisplay.vendor = edid_decoded.vendor;
                currentDisplay.model = edid_decoded.model;
                currentDisplay.resolutionx = edid_decoded.resolutionx;
                currentDisplay.resolutiony = edid_decoded.resolutiony;
                currentDisplay.sizex = edid_decoded.sizex;
                currentDisplay.sizey = edid_decoded.sizey;
                currentDisplay.pixeldepth = depth;
                is_edid = false;
              }
            }
            if (lines[i].toLowerCase().indexOf("edid:") >= 0) {
              is_edid = true;
              start = lines[i].search(/\S|$/);
            }
            if (lines[i].toLowerCase().indexOf("*current") >= 0) {
              const parts1 = lines[i].split("(");
              if (parts1 && parts1.length > 1 && parts1[0].indexOf("x") >= 0) {
                const resParts = parts1[0].trim().split("x");
                currentDisplay.currentResX = util.toInt(resParts[0]);
                currentDisplay.currentResY = util.toInt(resParts[1]);
              }
              is_current = true;
            }
            if (is_current && lines[i].toLowerCase().indexOf("clock") >= 0 && lines[i].toLowerCase().indexOf("hz") >= 0 && lines[i].toLowerCase().indexOf("v: height") >= 0) {
              const parts1 = lines[i].split("clock");
              if (parts1 && parts1.length > 1 && parts1[1].toLowerCase().indexOf("hz") >= 0) {
                currentDisplay.currentRefreshRate = util.toInt(parts1[1]);
              }
              is_current = false;
            }
          }
        }
        if (currentDisplay.model || currentDisplay.main || currentDisplay.builtin || currentDisplay.connection || currentDisplay.sizex !== -1 || currentDisplay.pixeldepth !== -1 || currentDisplay.resolutionx !== -1) {
          displays.push(currentDisplay);
        }
        return displays;
      }
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = {
            controllers: [],
            displays: []
          };
          if (_darwin) {
            let cmd = "system_profiler SPDisplaysDataType";
            exec2(cmd, function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                result = parseLinesDarwin(lines);
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_linux) {
            if (util.isRaspberry() && util.isRaspbian()) {
              let cmd = `fbset -s | grep 'mode "'; vcgencmd get_mem gpu; tvservice -s; tvservice -n;`;
              exec2(cmd, function(error, stdout) {
                let lines = stdout.toString().split("\n");
                if (lines.length > 3 && lines[0].indexOf('mode "') >= -1 && lines[2].indexOf("0x12000a") > -1) {
                  const parts = lines[0].replace("mode", "").replace(/"/g, "").trim().split("x");
                  if (parts.length === 2) {
                    result.displays.push({
                      vendor: "",
                      model: util.getValue(lines, "device_name", "="),
                      main: true,
                      builtin: false,
                      connection: "HDMI",
                      sizex: -1,
                      sizey: -1,
                      pixeldepth: -1,
                      resolutionx: parseInt(parts[0], 10),
                      resolutiony: parseInt(parts[1], 10),
                      currentResX: -1,
                      currentResY: -1,
                      positionX: 0,
                      positionY: 0,
                      currentRefreshRate: -1
                    });
                  }
                }
                if (lines.length > 1 && lines[1].indexOf("gpu=") >= -1) {
                  result.controllers.push({
                    vendor: "Broadcom",
                    model: "VideoCore IV",
                    bus: "",
                    vram: lines[1].replace("gpu=", ""),
                    vramDynamic: true
                  });
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } else {
              let cmd = "lspci -vvv  2>/dev/null";
              exec2(cmd, function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  result.controllers = parseLinesLinuxControllers(lines);
                }
                let cmd2 = "xdpyinfo 2>/dev/null | grep 'depth of root window' | awk '{ print $5 }'";
                exec2(cmd2, function(error2, stdout2) {
                  let depth = 0;
                  if (!error2) {
                    let lines = stdout2.toString().split("\n");
                    depth = parseInt(lines[0]) || 0;
                  }
                  let cmd3 = "xrandr --verbose 2>/dev/null";
                  exec2(cmd3, function(error3, stdout3) {
                    if (!error3) {
                      let lines = stdout3.toString().split("\n");
                      result.displays = parseLinesLinuxDisplays(lines, depth);
                    }
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  });
                });
              });
            }
          }
          if (_freebsd || _openbsd || _netbsd) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_sunos) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_windows) {
            try {
              const workload = [];
              workload.push(util.wmic("path win32_VideoController get /value"));
              workload.push(util.wmic("path win32_desktopmonitor get /value"));
              workload.push(util.powerShell("Get-CimInstance -Namespace root\\wmi -ClassName WmiMonitorBasicDisplayParams | fl"));
              workload.push(util.powerShell("Add-Type -AssemblyName System.Windows.Forms; [System.Windows.Forms.Screen]::AllScreens"));
              workload.push(util.powerShell("Get-CimInstance -Namespace root\\wmi -ClassName WmiMonitorConnectionParams | fl"));
              workload.push(util.powerShell('gwmi WmiMonitorID -Namespace root\\wmi | ForEach-Object {(($_.ManufacturerName -notmatch 0 | foreach {[char]$_}) -join "") + "|" + (($_.ProductCodeID -notmatch 0 | foreach {[char]$_}) -join "") + "|" + (($_.UserFriendlyName -notmatch 0 | foreach {[char]$_}) -join "") + "|" + (($_.SerialNumberID -notmatch 0 | foreach {[char]$_}) -join "") + "|" + $_.InstanceName}'));
              Promise.all(
                workload
              ).then((data) => {
                let csections = data[0].split(/\n\s*\n/);
                result.controllers = parseLinesWindowsControllers(csections);
                let dsections = data[1].split(/\n\s*\n/);
                dsections.shift();
                dsections.pop();
                let msections = data[2].split("Active ");
                msections.shift();
                let ssections = data[3].split("BitsPerPixel ");
                ssections.shift();
                let tsections = data[4].split(/\n\s*\n/);
                tsections.shift();
                const res = data[5].split(/\r\n/);
                let isections = [];
                res.forEach((element) => {
                  const parts = element.split("|");
                  if (parts.length === 5) {
                    isections.push({
                      vendor: parts[0],
                      code: parts[1],
                      model: parts[2],
                      serial: parts[3],
                      instanceId: parts[4]
                    });
                  }
                });
                result.displays = parseLinesWindowsDisplaysPowershell(ssections, msections, dsections, tsections, isections);
                if (result.displays.length === 1) {
                  if (_resolutionx) {
                    result.displays[0].resolutionx = _resolutionx;
                    if (!result.displays[0].currentResX) {
                      result.displays[0].currentResX = _resolutionx;
                    }
                  }
                  if (_resolutiony) {
                    result.displays[0].resolutiony = _resolutiony;
                    if (result.displays[0].currentResY === 0) {
                      result.displays[0].currentResY = _resolutiony;
                    }
                  }
                  if (_pixeldepth) {
                    result.displays[0].pixeldepth = _pixeldepth;
                  }
                  if (_refreshrate && !result.displays[0].refreshrate) {
                    result.displays[0].currentRefreshRate = _refreshrate;
                  }
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }).catch(() => {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
      function parseLinesWindowsControllers(sections) {
        let controllers = [];
        for (let i in sections) {
          if ({}.hasOwnProperty.call(sections, i)) {
            if (sections[i].trim() !== "") {
              let lines = sections[i].trim().split("\r\n");
              controllers.push({
                vendor: util.getValue(lines, "AdapterCompatibility", "="),
                model: util.getValue(lines, "name", "="),
                bus: util.getValue(lines, "PNPDeviceID", "=").startsWith("PCI") ? "PCI" : "",
                vram: parseInt(util.getValue(lines, "AdapterRAM", "="), 10) / 1024 / 1024,
                vramDynamic: util.getValue(lines, "VideoMemoryType", "=") === "2"
              });
              _resolutionx = util.toInt(util.getValue(lines, "CurrentHorizontalResolution", "=")) || _resolutionx;
              _resolutiony = util.toInt(util.getValue(lines, "CurrentVerticalResolution", "=")) || _resolutiony;
              _refreshrate = util.toInt(util.getValue(lines, "CurrentRefreshRate", "=")) || _refreshrate;
              _pixeldepth = util.toInt(util.getValue(lines, "CurrentBitsPerPixel", "=")) || _pixeldepth;
            }
          }
        }
        return controllers;
      }
      function parseLinesWindowsDisplaysPowershell(ssections, msections, dsections, tsections, isections) {
        let displays = [];
        let vendor = "";
        let model = "";
        let deviceID = "";
        let resolutionx = 0;
        let resolutiony = 0;
        if (dsections && dsections.length) {
          let linesDisplay = dsections[0].split(os.EOL);
          vendor = util.getValue(linesDisplay, "MonitorManufacturer", "=");
          model = util.getValue(linesDisplay, "Name", "=");
          deviceID = util.getValue(linesDisplay, "PNPDeviceID", "=").replace(/&amp;/g, "&").toLowerCase();
          resolutionx = util.toInt(util.getValue(linesDisplay, "ScreenWidth", "="));
          resolutiony = util.toInt(util.getValue(linesDisplay, "ScreenHeight", "="));
        }
        for (let i = 0; i < ssections.length; i++) {
          if (ssections[i].trim() !== "") {
            ssections[i] = "BitsPerPixel " + ssections[i];
            msections[i] = "Active " + msections[i];
            if (tsections.length === 0) {
              tsections[i] = "Unknown";
            }
            let linesScreen = ssections[i].split(os.EOL);
            let linesMonitor = msections[i].split(os.EOL);
            let linesConnection = tsections[i].split(os.EOL);
            const bitsPerPixel = util.getValue(linesScreen, "BitsPerPixel");
            const bounds = util.getValue(linesScreen, "Bounds").replace("{", "").replace("}", "").split(",");
            const primary = util.getValue(linesScreen, "Primary");
            const sizex = util.getValue(linesMonitor, "MaxHorizontalImageSize");
            const sizey = util.getValue(linesMonitor, "MaxVerticalImageSize");
            const instanceName = util.getValue(linesMonitor, "InstanceName").toLowerCase();
            const videoOutputTechnology = util.getValue(linesConnection, "VideoOutputTechnology");
            const deviceName = util.getValue(linesScreen, "DeviceName");
            let displayVendor = "";
            let displayModel = "";
            isections.forEach((element) => {
              if (element.instanceId.toLowerCase().startsWith(instanceName) && vendor.startsWith("(") && model.startsWith("PnP")) {
                displayVendor = element.vendor;
                displayModel = element.model;
              }
            });
            displays.push({
              vendor: instanceName.startsWith(deviceID) && displayVendor === "" ? vendor : displayVendor,
              model: instanceName.startsWith(deviceID) && displayModel === "" ? model : displayModel,
              deviceName,
              main: primary.toLowerCase() === "true",
              builtin: videoOutputTechnology === "2147483648",
              connection: videoOutputTechnology && videoTypes[videoOutputTechnology] ? videoTypes[videoOutputTechnology] : "",
              resolutionx: util.toInt(util.getValue(bounds, "Width", "=")),
              resolutiony: util.toInt(util.getValue(bounds, "Height", "=")),
              sizex: sizex ? parseInt(sizex, 10) : -1,
              sizey: sizey ? parseInt(sizey, 10) : -1,
              pixeldepth: bitsPerPixel,
              currentResX: util.toInt(util.getValue(bounds, "Width", "=")),
              currentResY: util.toInt(util.getValue(bounds, "Height", "=")),
              positionX: util.toInt(util.getValue(bounds, "X", "=")),
              positionY: util.toInt(util.getValue(bounds, "Y", "="))
            });
          }
        }
        if (ssections.length === 0) {
          displays.push({
            vendor,
            model,
            main: true,
            resolutionx,
            resolutiony,
            sizex: -1,
            sizey: -1,
            pixeldepth: -1,
            currentResX: resolutionx,
            currentResY: resolutiony,
            positionX: 0,
            positionY: 0
          });
        }
        return displays;
      }
    }
    exports.graphics = graphics;
  }
});

// node_modules/@jedithepro/system-info/lib/filesystem.js
var require_filesystem = __commonJS({
  "node_modules/@jedithepro/system-info/lib/filesystem.js"(exports) {
    "use strict";
    var exec2 = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var util = require_util2();
    var fs2 = require("fs");
    var _platform = process.platform;
    var _linux = _platform === "linux";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    var NOT_SUPPORTED = "not supported";
    var _fs_speed = {};
    var _disk_io = {};
    function fsSize(callback) {
      let macOsDisks = [];
      function getmacOsFsType(fs3) {
        if (!fs3.startsWith("/")) {
          return "NFS";
        }
        ;
        const parts = fs3.split("/");
        const fsShort = parts[parts.length - 1];
        const macOsDisksSingle = macOsDisks.filter((item) => item.indexOf(fsShort) >= 0);
        if (macOsDisksSingle.length === 1 && macOsDisksSingle[0].indexOf("APFS") >= 0) {
          return "APFS";
        }
        return "HFS";
      }
      function parseDf(lines) {
        let data = [];
        lines.forEach(function(line) {
          if (line !== "") {
            line = line.replace(/ +/g, " ").split(" ");
            if (line && (line[0].startsWith("/") || line[6] && line[6] === "/" || line[0].indexOf("/") > 0)) {
              const fs3 = line[0];
              const fstype = _linux || _freebsd || _openbsd || _netbsd ? line[1] : getmacOsFsType(line[0]);
              const size = parseInt(_linux || _freebsd || _openbsd || _netbsd ? line[2] : line[1]) * 1024;
              const used = parseInt(_linux || _freebsd || _openbsd || _netbsd ? line[3] : line[2]) * 1024;
              const use = parseFloat((100 * (_linux || _freebsd || _openbsd || _netbsd ? line[3] : line[2]) / (_linux || _freebsd || _openbsd || _netbsd ? line[2] : line[1])).toFixed(2));
              const mount = line[line.length - 1];
              if (!data.find((el) => el.fs === fs3 && el.type === fstype)) {
                data.push({
                  fs: fs3,
                  type: fstype,
                  size,
                  used,
                  use,
                  mount
                });
              }
            }
          }
        });
        return data;
      }
      return new Promise((resolve) => {
        process.nextTick(() => {
          let data = [];
          if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {
            let cmd = "";
            if (_darwin) {
              cmd = "df -kP";
              macOsDisks = execSync("diskutil list").toString().split("\n").filter((line) => {
                return !line.startsWith("/") && line.indexOf(":") > 0;
              });
            }
            if (_linux)
              cmd = "df -lkPTx squashfs | grep ^/";
            if (_freebsd || _openbsd || _netbsd)
              cmd = "df -lkPT";
            exec2(cmd, function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                data = parseDf(lines);
                if (callback) {
                  callback(data);
                }
                resolve(data);
              } else {
                exec2("df -kPT", function(error2, stdout2) {
                  if (!error2) {
                    let lines = stdout2.toString().split("\n");
                    data = parseDf(lines);
                  }
                  if (callback) {
                    callback(data);
                  }
                  resolve(data);
                });
              }
            });
          }
          if (_sunos) {
            if (callback) {
              callback(data);
            }
            resolve(data);
          }
          if (_windows) {
            try {
              util.wmic("logicaldisk get Caption,FileSystem,FreeSpace,Size").then((stdout) => {
                let lines = stdout.split("\r\n").filter((line) => line.trim() !== "").filter((line, idx) => idx > 0);
                lines.forEach(function(line) {
                  if (line !== "") {
                    line = line.trim().split(/\s\s+/);
                    data.push({
                      "fs": line[0],
                      "type": line[1],
                      "size": parseInt(line[3]),
                      "used": parseInt(line[3]) - parseInt(line[2]),
                      "use": parseFloat(100 * (parseInt(line[3]) - parseInt(line[2])) / parseInt(line[3])),
                      "mount": line[0]
                    });
                  }
                });
                if (callback) {
                  callback(data);
                }
                resolve(data);
              });
            } catch (e) {
              if (callback) {
                callback(data);
              }
              resolve(data);
            }
          }
        });
      });
    }
    exports.fsSize = fsSize;
    function fsOpenFiles(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          const result = {
            max: -1,
            allocated: -1,
            available: -1
          };
          if (_freebsd || _openbsd || _netbsd || _darwin) {
            let cmd = "sysctl -a | grep 'kern.*files'";
            exec2(cmd, function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                result.max = parseInt(util.getValue(lines, "kern.maxfiles", ":"), 10);
                result.allocated = parseInt(util.getValue(lines, "kern.num_files", ":"), 10);
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_linux) {
            fs2.readFile("/proc/sys/fs/file-nr", function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                if (lines[0]) {
                  const parts = lines[0].replace(/\s+/g, " ").split(" ");
                  if (parts.length === 3) {
                    result.allocated = parseInt(parts[0], 10);
                    result.available = parseInt(parts[1], 10);
                    result.max = parseInt(parts[2], 10);
                  }
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_sunos) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_windows) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        });
      });
    }
    exports.fsOpenFiles = fsOpenFiles;
    function parseBytes(s) {
      return parseInt(s.substr(s.indexOf(" (") + 2, s.indexOf(" Bytes)") - 10));
    }
    function parseDevices(lines) {
      let devices = [];
      let i = 0;
      lines.forEach((line) => {
        if (line.length > 0) {
          if (line[0] === "*") {
            i++;
          } else {
            let parts = line.split(":");
            if (parts.length > 1) {
              if (!devices[i])
                devices[i] = {
                  name: "",
                  identifier: "",
                  type: "disk",
                  fstype: "",
                  mount: "",
                  size: 0,
                  physical: "HDD",
                  uuid: "",
                  label: "",
                  model: "",
                  serial: "",
                  removable: false,
                  protocol: ""
                };
              parts[0] = parts[0].trim().toUpperCase().replace(/ +/g, "");
              parts[1] = parts[1].trim();
              if ("DEVICEIDENTIFIER" === parts[0])
                devices[i].identifier = parts[1];
              if ("DEVICENODE" === parts[0])
                devices[i].name = parts[1];
              if ("VOLUMENAME" === parts[0]) {
                if (parts[1].indexOf("Not applicable") === -1)
                  devices[i].label = parts[1];
              }
              if ("PROTOCOL" === parts[0])
                devices[i].protocol = parts[1];
              if ("DISKSIZE" === parts[0])
                devices[i].size = parseBytes(parts[1]);
              if ("FILESYSTEMPERSONALITY" === parts[0])
                devices[i].fstype = parts[1];
              if ("MOUNTPOINT" === parts[0])
                devices[i].mount = parts[1];
              if ("VOLUMEUUID" === parts[0])
                devices[i].uuid = parts[1];
              if ("READ-ONLYMEDIA" === parts[0] && parts[1] === "Yes")
                devices[i].physical = "CD/DVD";
              if ("SOLIDSTATE" === parts[0] && parts[1] === "Yes")
                devices[i].physical = "SSD";
              if ("VIRTUAL" === parts[0])
                devices[i].type = "virtual";
              if ("REMOVABLEMEDIA" === parts[0])
                devices[i].removable = parts[1] === "Removable";
              if ("PARTITIONTYPE" === parts[0])
                devices[i].type = "part";
              if ("DEVICE/MEDIANAME" === parts[0])
                devices[i].model = parts[1];
            }
          }
        }
      });
      return devices;
    }
    function parseBlk(lines) {
      let data = [];
      lines.filter((line) => line !== "").forEach((line) => {
        try {
          line = decodeURIComponent(line.replace(/\\x/g, "%"));
          line = line.replace(/\\/g, "\\\\");
          let disk = JSON.parse(line);
          data.push({
            "name": disk.name,
            "type": disk.type,
            "fstype": disk.fstype,
            "mount": disk.mountpoint,
            "size": parseInt(disk.size),
            "physical": disk.type === "disk" ? disk.rota === "0" ? "SSD" : "HDD" : disk.type === "rom" ? "CD/DVD" : "",
            "uuid": disk.uuid,
            "label": disk.label,
            "model": disk.model,
            "serial": disk.serial,
            "removable": disk.rm === "1",
            "protocol": disk.tran,
            "group": disk.group
          });
        } catch (e) {
          util.noop();
        }
      });
      data = util.unique(data);
      data = util.sortByKey(data, ["type", "name"]);
      return data;
    }
    function blkStdoutToObject(stdout) {
      return stdout.toString().replace(/NAME=/g, '{"name":').replace(/FSTYPE=/g, ',"fstype":').replace(/TYPE=/g, ',"type":').replace(/SIZE=/g, ',"size":').replace(/MOUNTPOINT=/g, ',"mountpoint":').replace(/UUID=/g, ',"uuid":').replace(/ROTA=/g, ',"rota":').replace(/RO=/g, ',"ro":').replace(/RM=/g, ',"rm":').replace(/TRAN=/g, ',"tran":').replace(/SERIAL=/g, ',"serial":').replace(/LABEL=/g, ',"label":').replace(/MODEL=/g, ',"model":').replace(/OWNER=/g, ',"owner":').replace(/GROUP=/g, ',"group":').replace(/\n/g, "}\n");
    }
    function blockDevices(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let data = [];
          if (_linux) {
            exec2("lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,TRAN,SERIAL,LABEL,MODEL,OWNER 2>/dev/null", function(error, stdout) {
              if (!error) {
                let lines = blkStdoutToObject(stdout).split("\n");
                data = parseBlk(lines);
                if (callback) {
                  callback(data);
                }
                resolve(data);
              } else {
                exec2("lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER 2>/dev/null", function(error2, stdout2) {
                  if (!error2) {
                    let lines = blkStdoutToObject(stdout2).split("\n");
                    data = parseBlk(lines);
                  }
                  if (callback) {
                    callback(data);
                  }
                  resolve(data);
                });
              }
            });
          }
          if (_darwin) {
            exec2("diskutil info -all", function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                data = parseDevices(lines);
              }
              if (callback) {
                callback(data);
              }
              resolve(data);
            });
          }
          if (_sunos) {
            if (callback) {
              callback(data);
            }
            resolve(data);
          }
          if (_windows) {
            let drivetypes = ["Unknown", "NoRoot", "Removable", "Local", "Network", "CD/DVD", "RAM"];
            try {
              util.wmic("logicaldisk get Caption,Description,DeviceID,DriveType,FileSystem,FreeSpace,Name,Size,VolumeName,VolumeSerialNumber /value").then((stdout, error) => {
                if (!error) {
                  let devices = stdout.toString().split(/\n\s*\n/);
                  devices.forEach(function(device) {
                    let lines = device.split("\r\n");
                    let drivetype = util.getValue(lines, "drivetype", "=");
                    if (drivetype) {
                      data.push({
                        name: util.getValue(lines, "name", "="),
                        identifier: util.getValue(lines, "caption", "="),
                        type: "disk",
                        fstype: util.getValue(lines, "filesystem", "=").toLowerCase(),
                        mount: util.getValue(lines, "caption", "="),
                        size: util.getValue(lines, "size", "="),
                        physical: drivetype >= 0 && drivetype <= 6 ? drivetypes[drivetype] : drivetypes[0],
                        uuid: util.getValue(lines, "volumeserialnumber", "="),
                        label: util.getValue(lines, "volumename", "="),
                        model: "",
                        serial: util.getValue(lines, "volumeserialnumber", "="),
                        removable: drivetype === "2",
                        protocol: ""
                      });
                    }
                  });
                }
                if (callback) {
                  callback(data);
                }
                resolve(data);
              });
            } catch (e) {
              if (callback) {
                callback(data);
              }
              resolve(data);
            }
          }
        });
      });
    }
    exports.blockDevices = blockDevices;
    function calcFsSpeed(rx, wx) {
      let result = {
        rx: 0,
        wx: 0,
        tx: 0,
        rx_sec: -1,
        wx_sec: -1,
        tx_sec: -1,
        ms: 0
      };
      if (_fs_speed && _fs_speed.ms) {
        result.rx = rx;
        result.wx = wx;
        result.tx = result.rx + result.wx;
        result.ms = Date.now() - _fs_speed.ms;
        result.rx_sec = (result.rx - _fs_speed.bytes_read) / (result.ms / 1e3);
        result.wx_sec = (result.wx - _fs_speed.bytes_write) / (result.ms / 1e3);
        result.tx_sec = result.rx_sec + result.wx_sec;
        _fs_speed.rx_sec = result.rx_sec;
        _fs_speed.wx_sec = result.wx_sec;
        _fs_speed.tx_sec = result.tx_sec;
        _fs_speed.bytes_read = result.rx;
        _fs_speed.bytes_write = result.wx;
        _fs_speed.bytes_overall = result.rx + result.wx;
        _fs_speed.ms = Date.now();
        _fs_speed.last_ms = result.ms;
      } else {
        result.rx = rx;
        result.wx = wx;
        result.tx = result.rx + result.wx;
        _fs_speed.rx_sec = -1;
        _fs_speed.wx_sec = -1;
        _fs_speed.tx_sec = -1;
        _fs_speed.bytes_read = result.rx;
        _fs_speed.bytes_write = result.wx;
        _fs_speed.bytes_overall = result.rx + result.wx;
        _fs_speed.ms = Date.now();
        _fs_speed.last_ms = 0;
      }
      return result;
    }
    function fsStats(callback) {
      return new Promise((resolve, reject) => {
        process.nextTick(() => {
          if (_windows) {
            let error = new Error(NOT_SUPPORTED);
            if (callback) {
              callback(NOT_SUPPORTED);
            }
            reject(error);
          }
          let result = {
            rx: 0,
            wx: 0,
            tx: 0,
            rx_sec: -1,
            wx_sec: -1,
            tx_sec: -1,
            ms: 0
          };
          let rx = 0;
          let wx = 0;
          if (_fs_speed && !_fs_speed.ms || _fs_speed && _fs_speed.ms && Date.now() - _fs_speed.ms >= 500) {
            if (_linux) {
              exec2("lsblk 2>/dev/null | grep /", function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  let fs_filter = [];
                  lines.forEach(function(line) {
                    if (line !== "") {
                      line = line.replace(/[]+/g, "").trim().split(" ");
                      if (fs_filter.indexOf(line[0]) === -1)
                        fs_filter.push(line[0]);
                    }
                  });
                  let output = fs_filter.join("|");
                  exec2('cat /proc/diskstats | egrep "' + output + '"', function(error2, stdout2) {
                    if (!error2) {
                      let lines2 = stdout2.toString().split("\n");
                      lines2.forEach(function(line) {
                        line = line.trim();
                        if (line !== "") {
                          line = line.replace(/ +/g, " ").split(" ");
                          rx += parseInt(line[5]) * 512;
                          wx += parseInt(line[9]) * 512;
                        }
                      });
                      result = calcFsSpeed(rx, wx);
                    }
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  });
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              });
            }
            if (_darwin) {
              exec2('ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n "/IOBlockStorageDriver/,/Statistics/p" | grep "Statistics" | tr -cd "01234567890,\n"', function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  lines.forEach(function(line) {
                    line = line.trim();
                    if (line !== "") {
                      line = line.split(",");
                      rx += parseInt(line[2]);
                      wx += parseInt(line[9]);
                    }
                  });
                  result = calcFsSpeed(rx, wx);
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            }
          } else {
            result.ms = _fs_speed.last_ms;
            result.rx = _fs_speed.bytes_read;
            result.wx = _fs_speed.bytes_write;
            result.tx = _fs_speed.bytes_read + _fs_speed.bytes_write;
            result.rx_sec = _fs_speed.rx_sec;
            result.wx_sec = _fs_speed.wx_sec;
            result.tx_sec = _fs_speed.tx_sec;
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        });
      });
    }
    exports.fsStats = fsStats;
    function calcDiskIO(rIO, wIO) {
      let result = {
        rIO: 0,
        wIO: 0,
        tIO: 0,
        rIO_sec: -1,
        wIO_sec: -1,
        tIO_sec: -1,
        ms: 0
      };
      if (_disk_io && _disk_io.ms) {
        result.rIO = rIO;
        result.wIO = wIO;
        result.tIO = rIO + wIO;
        result.ms = Date.now() - _disk_io.ms;
        result.rIO_sec = (result.rIO - _disk_io.rIO) / (result.ms / 1e3);
        result.wIO_sec = (result.wIO - _disk_io.wIO) / (result.ms / 1e3);
        result.tIO_sec = result.rIO_sec + result.wIO_sec;
        _disk_io.rIO = rIO;
        _disk_io.wIO = wIO;
        _disk_io.rIO_sec = result.rIO_sec;
        _disk_io.wIO_sec = result.wIO_sec;
        _disk_io.tIO_sec = result.tIO_sec;
        _disk_io.last_ms = result.ms;
        _disk_io.ms = Date.now();
      } else {
        result.rIO = rIO;
        result.wIO = wIO;
        result.tIO = rIO + wIO;
        _disk_io.rIO = rIO;
        _disk_io.wIO = wIO;
        _disk_io.rIO_sec = -1;
        _disk_io.wIO_sec = -1;
        _disk_io.tIO_sec = -1;
        _disk_io.last_ms = 0;
        _disk_io.ms = Date.now();
      }
      return result;
    }
    function disksIO(callback) {
      return new Promise((resolve, reject) => {
        process.nextTick(() => {
          if (_windows) {
            let error = new Error(NOT_SUPPORTED);
            if (callback) {
              callback(NOT_SUPPORTED);
            }
            reject(error);
          }
          if (_sunos) {
            let error = new Error(NOT_SUPPORTED);
            if (callback) {
              callback(NOT_SUPPORTED);
            }
            reject(error);
          }
          let result = {
            rIO: 0,
            wIO: 0,
            tIO: 0,
            rIO_sec: -1,
            wIO_sec: -1,
            tIO_sec: -1,
            ms: 0
          };
          let rIO = 0;
          let wIO = 0;
          if (_disk_io && !_disk_io.ms || _disk_io && _disk_io.ms && Date.now() - _disk_io.ms >= 500) {
            if (_linux || _freebsd || _openbsd || _netbsd) {
              let cmd = 'for mount in `lsblk 2>/dev/null | grep " disk " | sed "s/[\u2502\u2514\u2500\u251C]//g" | awk \'{$1=$1};1\' | cut -d " " -f 1 | sort -u`; do cat /sys/block/$mount/stat | sed -r "s/ +/;/g" | sed -r "s/^;//"; done';
              exec2(cmd, function(error, stdout) {
                if (!error) {
                  let lines = stdout.split("\n");
                  lines.forEach(function(line) {
                    if (!line)
                      return;
                    let stats = line.split(";");
                    rIO += parseInt(stats[0]);
                    wIO += parseInt(stats[4]);
                  });
                  result = calcDiskIO(rIO, wIO);
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              });
            }
            if (_darwin) {
              exec2('ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n "/IOBlockStorageDriver/,/Statistics/p" | grep "Statistics" | tr -cd "01234567890,\n"', function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  lines.forEach(function(line) {
                    line = line.trim();
                    if (line !== "") {
                      line = line.split(",");
                      rIO += parseInt(line[10]);
                      wIO += parseInt(line[0]);
                    }
                  });
                  result = calcDiskIO(rIO, wIO);
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            }
          } else {
            result.rIO = _disk_io.rIO;
            result.wIO = _disk_io.wIO;
            result.tIO = _disk_io.rIO + _disk_io.wIO;
            result.ms = _disk_io.last_ms;
            result.rIO_sec = _disk_io.rIO_sec;
            result.wIO_sec = _disk_io.wIO_sec;
            result.tIO_sec = _disk_io.tIO_sec;
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        });
      });
    }
    exports.disksIO = disksIO;
    function diskLayout(callback) {
      function getVendorFromModel(model) {
        const diskManufacturers = [
          { pattern: "^WESTERN.+", manufacturer: "Western Digital" },
          { pattern: "^WDC.+", manufacturer: "Western Digital" },
          { pattern: "WD.+", manufacturer: "Western Digital" },
          { pattern: "^TOSHIBA.+", manufacturer: "Toshiba" },
          { pattern: "^HITACHI.+", manufacturer: "Hitachi" },
          { pattern: "^IC.+", manufacturer: "Hitachi" },
          { pattern: "^HTS.+", manufacturer: "Hitachi" },
          { pattern: "^SANDISK.+", manufacturer: "SanDisk" },
          { pattern: "^KINGSTON.+", manufacturer: "Kingston Technonogy" },
          { pattern: "^SONY.+", manufacturer: "Sony" },
          { pattern: "^TRANSCEND.+", manufacturer: "Transcend" },
          { pattern: "SAMSUNG.+", manufacturer: "Samsung" },
          { pattern: "^ST(?!I\\ ).+", manufacturer: "Seagate" },
          { pattern: "^STI\\ .+", manufacturer: "SimpleTech" },
          { pattern: "^D...-.+", manufacturer: "IBM" },
          { pattern: "^IBM.+", manufacturer: "IBM" },
          { pattern: "^FUJITSU.+", manufacturer: "Fujitsu" },
          { pattern: "^MP.+", manufacturer: "Fujitsu" },
          { pattern: "^MK.+", manufacturer: "Toshiba" },
          { pattern: "^MAXTOR.+", manufacturer: "Maxtor" },
          { pattern: "^Pioneer.+", manufacturer: "Pioneer" },
          { pattern: "^PHILIPS.+", manufacturer: "Philips" },
          { pattern: "^QUANTUM.+", manufacturer: "Quantum Technology" },
          { pattern: "FIREBALL.+", manufacturer: "Quantum Technology" },
          { pattern: "^VBOX.+", manufacturer: "VirtualBox" },
          { pattern: "CORSAIR.+", manufacturer: "Corsair Components" },
          { pattern: "CRUCIAL.+", manufacturer: "Crucial" },
          { pattern: "ECM.+", manufacturer: "ECM" },
          { pattern: "INTEL.+", manufacturer: "INTEL" }
        ];
        let result = "";
        if (model) {
          model = model.toUpperCase();
          diskManufacturers.forEach((manufacturer) => {
            const re = RegExp(manufacturer.pattern);
            if (re.test(model)) {
              result = manufacturer.manufacturer;
            }
          });
        }
        return result;
      }
      return new Promise((resolve) => {
        process.nextTick(() => {
          const commitResult = (res) => {
            for (let i = 0; i < res.length; i++) {
              delete res[i].BSDName;
            }
            if (callback) {
              callback(res);
            }
            resolve(res);
          };
          let result = [];
          let cmd = "";
          if (_linux) {
            let cmdFullSmart = "";
            exec2("export LC_ALL=C; lsblk -ablJO 2>/dev/null; unset LC_ALL", function(error, stdout) {
              if (!error) {
                try {
                  const out = stdout.toString().trim();
                  let devices = [];
                  try {
                    const outJSON = JSON.parse(out);
                    if (outJSON && {}.hasOwnProperty.call(outJSON, "blockdevices")) {
                      devices = outJSON.blockdevices.filter((item) => {
                        return (item.group === "disk" || item.type === "disk") && item.size > 0 && (item.model !== null || item.mountpoint === null && item.label === null && item.fstype === null && item.parttype === null);
                      });
                    }
                  } catch (e) {
                    const out2 = execSync("export LC_ALL=C; lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER,GROUP 2>/dev/null; unset LC_ALL").toString();
                    let lines = blkStdoutToObject(out2).split("\n");
                    const data = parseBlk(lines);
                    devices = data.filter((item) => {
                      return (item.group === "disk" || item.type === "disk") && item.size > 0 && (item.model !== null && item.model !== "" || item.mountpoint === "" && item.label === "" && item.fstype === "");
                    });
                  }
                  devices.forEach((device) => {
                    let mediumType = "";
                    const BSDName = "/dev/" + device.name;
                    const logical = device.name;
                    try {
                      mediumType = execSync("cat /sys/block/" + logical + "/queue/rotational 2>/dev/null").toString().split("\n")[0];
                    } catch (e) {
                      util.noop();
                    }
                    let interfaceType = device.tran ? device.tran.toUpperCase().trim() : "";
                    if (interfaceType === "NVME") {
                      mediumType = "2";
                      interfaceType = "PCIe";
                    }
                    result.push({
                      device: BSDName,
                      type: mediumType === "0" ? "SSD" : mediumType === "1" ? "HD" : mediumType === "2" ? "NVMe" : device.model && device.model.indexOf("SSD") > -1 ? "SSD" : device.model && device.model.indexOf("NVM") > -1 ? "NVMe" : "HD",
                      name: device.model || "",
                      vendor: getVendorFromModel(device.model) || (device.vendor ? device.vendor.trim() : ""),
                      size: device.size || 0,
                      bytesPerSector: -1,
                      totalCylinders: -1,
                      totalHeads: -1,
                      totalSectors: -1,
                      totalTracks: -1,
                      tracksPerCylinder: -1,
                      sectorsPerTrack: -1,
                      firmwareRevision: device.rev ? device.rev.trim() : "",
                      serialNum: device.serial ? device.serial.trim() : "",
                      interfaceType,
                      smartStatus: "unknown",
                      BSDName
                    });
                    cmd += `printf "
${BSDName}|"; smartctl -H ${BSDName} | grep overall;`;
                    cmdFullSmart += `${cmdFullSmart ? 'printf ",";' : ""}smartctl -a -j ${BSDName};`;
                  });
                } catch (e) {
                  util.noop();
                }
              }
              if (cmdFullSmart) {
                exec2(cmdFullSmart, function(error2, stdout2) {
                  try {
                    const data = JSON.parse(`[${stdout2}]`);
                    data.forEach((disk) => {
                      const diskBSDName = disk.smartctl.argv[disk.smartctl.argv.length - 1];
                      for (let i = 0; i < result.length; i++) {
                        if (result[i].BSDName === diskBSDName) {
                          result[i].smartStatus = disk.smart_status.passed ? "Ok" : disk.smart_status.passed === false ? "Predicted Failure" : "unknown";
                          result[i].smartData = disk;
                        }
                      }
                    });
                    commitResult(result);
                  } catch (e) {
                    if (cmd) {
                      cmd = cmd + 'printf "\n"';
                      exec2(cmd, function(error3, stdout3) {
                        let lines = stdout3.toString().split("\n");
                        lines.forEach((line) => {
                          if (line) {
                            let parts = line.split("|");
                            if (parts.length === 2) {
                              let BSDName = parts[0];
                              parts[1] = parts[1].trim();
                              let parts2 = parts[1].split(":");
                              if (parts2.length === 2) {
                                parts2[1] = parts2[1].trim();
                                let status = parts2[1].toLowerCase();
                                for (let i = 0; i < result.length; i++) {
                                  if (result[i].BSDName === BSDName) {
                                    result[i].smartStatus = status === "passed" ? "Ok" : status === "failed!" ? "Predicted Failure" : "unknown";
                                  }
                                }
                              }
                            }
                          }
                        });
                        commitResult(result);
                      });
                    } else {
                      commitResult(result);
                    }
                  }
                });
              } else {
                commitResult(result);
              }
            });
          }
          if (_freebsd || _openbsd || _netbsd) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_sunos) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_darwin) {
            exec2("system_profiler SPSerialATADataType SPNVMeDataType", function(error, stdout) {
              if (!error) {
                let parts = stdout.toString().split("NVMExpress:");
                let devices = parts[0].split(" Physical Interconnect: ");
                devices.shift();
                devices.forEach(function(device) {
                  device = "InterfaceType: " + device;
                  let lines = device.split("\n");
                  const mediumType = util.getValue(lines, "Medium Type", ":", true).trim();
                  const sizeStr = util.getValue(lines, "capacity", ":", true).trim();
                  const BSDName = util.getValue(lines, "BSD Name", ":", true).trim();
                  if (sizeStr) {
                    let sizeValue = 0;
                    if (sizeStr.indexOf("(") >= 0) {
                      sizeValue = parseInt(sizeStr.match(/\(([^)]+)\)/)[1].replace(/\./g, "").replace(/,/g, ""));
                    }
                    if (!sizeValue) {
                      sizeValue = parseInt(sizeStr);
                    }
                    if (sizeValue) {
                      result.push({
                        device: BSDName,
                        type: mediumType.startsWith("Solid") ? "SSD" : "HD",
                        name: util.getValue(lines, "Model", ":", true).trim(),
                        vendor: getVendorFromModel(util.getValue(lines, "Model", ":", true).trim()),
                        size: sizeValue,
                        bytesPerSector: -1,
                        totalCylinders: -1,
                        totalHeads: -1,
                        totalSectors: -1,
                        totalTracks: -1,
                        tracksPerCylinder: -1,
                        sectorsPerTrack: -1,
                        firmwareRevision: util.getValue(lines, "Revision", ":", true).trim(),
                        serialNum: util.getValue(lines, "Serial Number", ":", true).trim(),
                        interfaceType: util.getValue(lines, "InterfaceType", ":", true).trim(),
                        smartStatus: "unknown",
                        BSDName
                      });
                      cmd = cmd + 'printf "\n' + BSDName + '|"; diskutil info /dev/' + BSDName + " | grep SMART;";
                    }
                  }
                });
                if (parts.length > 1) {
                  let devices2 = parts[1].split("\n\n          Capacity:");
                  devices2.shift();
                  devices2.forEach(function(device) {
                    device = "!Capacity: " + device;
                    let lines = device.split("\n");
                    const linkWidth = util.getValue(lines, "link width", ":", true).trim();
                    const sizeStr = util.getValue(lines, "!capacity", ":", true).trim();
                    const BSDName = util.getValue(lines, "BSD Name", ":", true).trim();
                    if (sizeStr) {
                      let sizeValue = 0;
                      if (sizeStr.indexOf("(") >= 0) {
                        sizeValue = parseInt(sizeStr.match(/\(([^)]+)\)/)[1].replace(/\./g, "").replace(/,/g, ""));
                      }
                      if (!sizeValue) {
                        sizeValue = parseInt(sizeStr);
                      }
                      if (sizeValue) {
                        result.push({
                          device: BSDName,
                          type: "NVMe",
                          name: util.getValue(lines, "Model", ":", true).trim(),
                          vendor: getVendorFromModel(util.getValue(lines, "Model", ":", true).trim()),
                          size: sizeValue,
                          bytesPerSector: -1,
                          totalCylinders: -1,
                          totalHeads: -1,
                          totalSectors: -1,
                          totalTracks: -1,
                          tracksPerCylinder: -1,
                          sectorsPerTrack: -1,
                          firmwareRevision: util.getValue(lines, "Revision", ":", true).trim(),
                          serialNum: util.getValue(lines, "Serial Number", ":", true).trim(),
                          interfaceType: ("PCIe " + linkWidth).trim(),
                          smartStatus: "unknown",
                          BSDName
                        });
                        cmd = cmd + 'printf "\n' + BSDName + '|"; diskutil info /dev/' + BSDName + " | grep SMART;";
                      }
                    }
                  });
                }
              }
              if (cmd) {
                cmd = cmd + 'printf "\n"';
                exec2(cmd, function(error2, stdout2) {
                  let lines = stdout2.toString().split("\n");
                  lines.forEach((line) => {
                    if (line) {
                      let parts = line.split("|");
                      if (parts.length === 2) {
                        let BSDName = parts[0];
                        parts[1] = parts[1].trim();
                        let parts2 = parts[1].split(":");
                        if (parts2.length === 2) {
                          parts2[1] = parts2[1].trim();
                          let status = parts2[1].toLowerCase();
                          for (let i = 0; i < result.length; i++) {
                            if (result[i].BSDName === BSDName) {
                              result[i].smartStatus = status === "not supported" ? "not supported" : status === "verified" ? "Ok" : status === "failing" ? "Predicted Failure" : "unknown";
                            }
                          }
                        }
                      }
                    }
                  });
                  for (let i = 0; i < result.length; i++) {
                    delete result[i].BSDName;
                  }
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                });
              } else {
                for (let i = 0; i < result.length; i++) {
                  delete result[i].BSDName;
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            });
          }
          if (_windows) {
            try {
              util.wmic("diskdrive get /value").then((stdout, error) => {
                let devices = stdout.toString().split(/\n\s*\n/);
                devices.forEach(function(device) {
                  let lines = device.split("\r\n");
                  const size = util.getValue(lines, "Size", "=").trim();
                  const status = util.getValue(lines, "Status", "=").trim().toLowerCase();
                  if (size) {
                    result.push({
                      device: "",
                      type: device.indexOf("SSD") > -1 ? "SSD" : "HD",
                      name: util.getValue(lines, "Caption", "="),
                      vendor: util.getValue(lines, "Manufacturer", "="),
                      size: parseInt(size),
                      bytesPerSector: parseInt(util.getValue(lines, "BytesPerSector", "=")),
                      totalCylinders: parseInt(util.getValue(lines, "TotalCylinders", "=")),
                      totalHeads: parseInt(util.getValue(lines, "TotalHeads", "=")),
                      totalSectors: parseInt(util.getValue(lines, "TotalSectors", "=")),
                      totalTracks: parseInt(util.getValue(lines, "TotalTracks", "=")),
                      tracksPerCylinder: parseInt(util.getValue(lines, "TracksPerCylinder", "=")),
                      sectorsPerTrack: parseInt(util.getValue(lines, "SectorsPerTrack", "=")),
                      firmwareRevision: util.getValue(lines, "FirmwareRevision", "=").trim(),
                      serialNum: util.getValue(lines, "SerialNumber", "=").trim(),
                      interfaceType: util.getValue(lines, "InterfaceType", "=").trim(),
                      smartStatus: status === "ok" ? "Ok" : status === "degraded" ? "Degraded" : status === "pred fail" ? "Predicted Failure" : "Unknown"
                    });
                  }
                });
                util.powerShell("Get-PhysicalDisk | Format-List").then((data) => {
                  let devices2 = data.split(/\n\s*\n/);
                  devices2.forEach(function(device) {
                    let lines = device.split("\r\n");
                    const serialNum = util.getValue(lines, "SerialNumber", ":").trim();
                    const name = util.getValue(lines, "FriendlyName", ":").trim().replace("Msft ", "Microsoft");
                    const size = util.getValue(lines, "Size", ":").trim();
                    const model = util.getValue(lines, "Model", ":").trim();
                    const interfaceType = util.getValue(lines, "BusType", ":").trim();
                    let mediaType = util.getValue(lines, "MediaType", ":").trim();
                    if (mediaType === "3" || mediaType === "HDD") {
                      mediaType = "HD";
                    }
                    if (mediaType === "4") {
                      mediaType = "SSD";
                    }
                    if (mediaType === "5") {
                      mediaType = "SCM";
                    }
                    if (mediaType === "Unspecified" && (model.toLowerCase().indexOf("virtual") > -1 || model.toLowerCase().indexOf("vbox") > -1)) {
                      mediaType = "Virtual";
                    }
                    if (size) {
                      let i = util.findObjectByKey(result, "serialNum", serialNum);
                      if (i === -1 || serialNum === "") {
                        i = util.findObjectByKey(result, "name", name);
                      }
                      if (i != -1) {
                        result[i].type = mediaType;
                        result[i].interfaceType = interfaceType;
                      }
                    }
                  });
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }).catch(() => {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                });
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.diskLayout = diskLayout;
  }
});

// node_modules/@jedithepro/system-info/lib/network.js
var require_network = __commonJS({
  "node_modules/@jedithepro/system-info/lib/network.js"(exports) {
    "use strict";
    var os = require("os");
    var exec2 = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var fs2 = require("fs");
    var util = require_util2();
    var _platform = process.platform;
    var _linux = _platform === "linux";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    var _network = {};
    var _default_iface = "";
    var _ifaces = {};
    var _dhcpNics = [];
    var _networkInterfaces = [];
    var _mac = {};
    var pathToIp;
    function getDefaultNetworkInterface() {
      let ifaces = os.networkInterfaces();
      let ifacename = "";
      let ifacenameFirst = "";
      let scopeid = 9999;
      for (let dev in ifaces) {
        if ({}.hasOwnProperty.call(ifaces, dev)) {
          ifaces[dev].forEach(function(details) {
            if (details && details.internal === false) {
              ifacenameFirst = ifacenameFirst || dev;
              if (details.scopeid && details.scopeid < scopeid) {
                ifacename = dev;
                scopeid = details.scopeid;
              }
            }
          });
        }
      }
      ifacename = ifacename || ifacenameFirst || "";
      try {
        if (_windows) {
          let defaultIp = "";
          const cmd = "netstat -r";
          const result = execSync(cmd);
          const lines = result.toString().split(os.EOL);
          lines.forEach((line) => {
            line = line.replace(/\s+/g, " ").trim();
            if (line.indexOf("0.0.0.0 0.0.0.0") > -1 && !/[a-zA-Z]/.test(line)) {
              const parts = line.split(" ");
              if (parts.length >= 5) {
                defaultIp = parts[parts.length - 2];
              }
            }
          });
          if (defaultIp) {
            for (let dev in ifaces) {
              if ({}.hasOwnProperty.call(ifaces, dev)) {
                ifaces[dev].forEach(function(details) {
                  if (details && details.address && details.address === defaultIp) {
                    ifacename = dev;
                  }
                });
              }
            }
          }
        }
        if (_linux) {
          let cmd = "ip route 2> /dev/null | grep default";
          let result = execSync(cmd);
          let parts = result.toString().split("\n")[0].split(/\s+/);
          if (parts[0] === "none" && parts[5]) {
            ifacename = parts[5];
          } else if (parts[4]) {
            ifacename = parts[4];
          }
          if (ifacename.indexOf(":") > -1) {
            ifacename = ifacename.split(":")[1].trim();
          }
        }
        if (_darwin || _freebsd || _openbsd || _netbsd || _sunos) {
          let cmd = "";
          if (_linux)
            cmd = "ip route 2> /dev/null | grep default | awk '{print $5}'";
          if (_darwin)
            cmd = "route -n get default 2>/dev/null | grep interface: | awk '{print $2}'";
          if (_freebsd || _openbsd || _netbsd || _sunos)
            cmd = "route get 0.0.0.0 | grep interface:";
          let result = execSync(cmd);
          ifacename = result.toString().split("\n")[0];
          if (ifacename.indexOf(":") > -1) {
            ifacename = ifacename.split(":")[1].trim();
          }
        }
      } catch (e) {
        util.noop();
      }
      if (ifacename)
        _default_iface = ifacename;
      return _default_iface;
    }
    exports.getDefaultNetworkInterface = getDefaultNetworkInterface;
    function getMacAddresses() {
      let iface = "";
      let mac = "";
      let result = {};
      if (_linux || _freebsd || _openbsd || _netbsd) {
        if (typeof pathToIp === "undefined") {
          try {
            const lines = execSync("which ip").toString().split("\n");
            if (lines.length && lines[0].indexOf(":") === -1 && lines[0].indexOf("/") === 0) {
              pathToIp = lines[0];
            } else {
              pathToIp = "";
            }
          } catch (e) {
            pathToIp = "";
          }
        }
        try {
          const cmd = "export LC_ALL=C; " + (pathToIp ? pathToIp + " link show up" : "/sbin/ifconfig") + "; unset LC_ALL";
          let res = execSync(cmd);
          const lines = res.toString().split("\n");
          for (let i = 0; i < lines.length; i++) {
            if (lines[i] && lines[i][0] !== " ") {
              if (pathToIp) {
                let nextline = lines[i + 1].trim().split(" ");
                if (nextline[0] === "link/ether") {
                  iface = lines[i].split(" ")[1];
                  iface = iface.slice(0, iface.length - 1);
                  mac = nextline[1];
                }
              } else {
                iface = lines[i].split(" ")[0];
                mac = lines[i].split("HWaddr ")[1];
              }
              if (iface && mac) {
                result[iface] = mac.trim();
                iface = "";
                mac = "";
              }
            }
          }
        } catch (e) {
          util.noop();
        }
      }
      if (_darwin) {
        try {
          const cmd = "/sbin/ifconfig";
          let res = execSync(cmd);
          const lines = res.toString().split("\n");
          for (let i = 0; i < lines.length; i++) {
            if (lines[i] && lines[i][0] !== "	" && lines[i].indexOf(":") > 0) {
              iface = lines[i].split(":")[0];
            } else if (lines[i].indexOf("	ether ") === 0) {
              mac = lines[i].split("	ether ")[1];
              if (iface && mac) {
                result[iface] = mac.trim();
                iface = "";
                mac = "";
              }
            }
          }
        } catch (e) {
          util.noop();
        }
      }
      return result;
    }
    function networkInterfaceDefault(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = getDefaultNetworkInterface();
          if (callback) {
            callback(result);
          }
          resolve(result);
        });
      });
    }
    exports.networkInterfaceDefault = networkInterfaceDefault;
    function parseLinesWindowsNics(sections, nconfigsections) {
      let nics = [];
      for (let i in sections) {
        if ({}.hasOwnProperty.call(sections, i)) {
          if (sections[i].trim() !== "") {
            let lines = sections[i].trim().split("\r\n");
            let linesNicConfig = nconfigsections[i].trim().split("\r\n");
            let netEnabled = util.getValue(lines, "NetEnabled", "=");
            if (netEnabled !== "") {
              const speed = parseInt(util.getValue(lines, "speed", "=").trim(), 10) / 1e6;
              nics.push({
                mac: util.getValue(lines, "MACAddress", "=").toLowerCase(),
                dhcp: util.getValue(linesNicConfig, "dhcpEnabled", "=").toLowerCase(),
                name: util.getValue(lines, "Name", "=").replace(/\]/g, ")").replace(/\[/g, "("),
                netEnabled: netEnabled === "TRUE",
                speed: isNaN(speed) ? -1 : speed,
                operstate: util.getValue(lines, "NetConnectionStatus", "=") === "2" ? "up" : "down",
                type: util.getValue(lines, "AdapterTypeID", "=") === "9" ? "wireless" : "wired"
              });
            }
          }
        }
      }
      return nics;
    }
    function getWindowsNics() {
      const cmd = util.getWmic() + " nic get MACAddress, name, NetEnabled, Speed, NetConnectionStatus, AdapterTypeId /value";
      const cmdnicconfig = util.getWmic() + " nicconfig get dhcpEnabled /value";
      try {
        const nsections = execSync(cmd, util.execOptsWin).split(/\n\s*\n/);
        const nconfigsections = execSync(cmdnicconfig, util.execOptsWin).split(/\n\s*\n/);
        return parseLinesWindowsNics(nsections, nconfigsections);
      } catch (e) {
        return [];
      }
    }
    function getWindowsDNSsuffixes() {
      let iface = {};
      let dnsSuffixes = {
        primaryDNS: "",
        exitCode: 0,
        ifaces: []
      };
      try {
        const ipconfig = execSync("ipconfig /all", util.execOptsWin);
        const ipconfigArray = ipconfig.split("\r\n\r\n");
        ipconfigArray.forEach((element, index) => {
          if (index == 1) {
            const longPrimaryDNS = element.split("\r\n").filter((element2) => {
              return element2.toUpperCase().includes("DNS");
            });
            const primaryDNS = longPrimaryDNS[0].substring(longPrimaryDNS[0].lastIndexOf(":") + 1);
            dnsSuffixes.primaryDNS = primaryDNS.trim();
            if (!dnsSuffixes.primaryDNS)
              dnsSuffixes.primaryDNS = "Not defined";
          }
          if (index > 1) {
            if (index % 2 == 0) {
              const name = element.substring(element.lastIndexOf(" ") + 1).replace(":", "");
              iface.name = name;
            } else {
              const connectionSpecificDNS = element.split("\r\n").filter((element2) => {
                return element2.toUpperCase().includes("DNS");
              });
              const dnsSuffix = connectionSpecificDNS[0].substring(connectionSpecificDNS[0].lastIndexOf(":") + 1);
              iface.dnsSuffix = dnsSuffix.trim();
              dnsSuffixes.ifaces.push(iface);
              iface = {};
            }
          }
        });
        return dnsSuffixes;
      } catch (error) {
        return {
          primaryDNS: "",
          exitCode: 0,
          ifaces: []
        };
      }
    }
    function getWindowsIfaceDNSsuffix(ifaces, ifacename) {
      let dnsSuffix = "";
      const interfaceName = ifacename + ".";
      try {
        const connectionDnsSuffix = ifaces.filter((iface) => {
          return interfaceName.includes(iface.name + ".");
        }).map((iface) => iface.dnsSuffix);
        if (connectionDnsSuffix[0]) {
          dnsSuffix = connectionDnsSuffix[0];
        }
        if (!dnsSuffix)
          dnsSuffix = "";
        return dnsSuffix;
      } catch (error) {
        return "Unknown";
      }
    }
    function getWindowsWiredProfilesInformation() {
      try {
        const result = execSync("netsh lan show profiles", util.execOptsWin);
        const profileList = result.split("\r\nProfile on interface");
        return profileList;
      } catch (error) {
        if (error.status === 1 && error.stdout.includes("AutoConfig")) {
          return "Disabled";
        }
        return [];
      }
    }
    function getWindowsWirelessIfaceSSID(interfaceName) {
      try {
        const result = execSync(`netsh wlan show  interface name="${interfaceName}" | findstr "SSID"`, util.execOptsWin);
        const SSID = result.split("\r\n").shift();
        const parseSSID = SSID.split(":").pop();
        return parseSSID;
      } catch (error) {
        return "Unknown";
      }
    }
    function getWindowsIEEE8021x(connectionType, iface, ifaces) {
      let i8021x = {
        state: "Unknown",
        protocol: "Unknown"
      };
      if (ifaces === "Disabled") {
        i8021x.state = "Disabled";
        i8021x.protocol = "Not defined";
        return i8021x;
      }
      if (connectionType == "wired" && ifaces.length > 0) {
        try {
          const iface8021xInfo = ifaces.find((element) => {
            return element.includes(iface + "\r\n");
          });
          const arrayIface8021xInfo = iface8021xInfo.split("\r\n");
          const state8021x = arrayIface8021xInfo.find((element) => {
            return element.includes("802.1x");
          });
          if (state8021x.includes("Disabled")) {
            i8021x.state = "Disabled";
            i8021x.protocol = "Not defined";
          } else if (state8021x.includes("Enabled")) {
            const protocol8021x = arrayIface8021xInfo.find((element) => {
              return element.includes("EAP");
            });
            i8021x.protocol = protocol8021x.split(":").pop();
            i8021x.state = "Enabled";
          }
        } catch (error) {
          return i8021x;
        }
      } else if (connectionType == "wireless") {
        let i8021xState = "";
        let i8021xProtocol = "";
        try {
          const SSID = getWindowsWirelessIfaceSSID(iface);
          if (SSID !== "Unknown") {
            i8021xState = execSync(`netsh wlan show profiles "${SSID}" | findstr "802.1X"`, util.execOptsWin);
            i8021xProtocol = execSync(`netsh wlan show profiles "${SSID}" | findstr "EAP"`, util.execOptsWin);
          }
          if (i8021xState.includes(":") && i8021xProtocol.includes(":")) {
            i8021x.state = i8021xState.split(":").pop();
            i8021x.protocol = i8021xProtocol.split(":").pop();
          }
        } catch (error) {
          if (error.status === 1 && error.stdout.includes("AutoConfig")) {
            i8021x.state = "Disabled";
            i8021x.protocol = "Not defined";
          }
          return i8021x;
        }
      }
      return i8021x;
    }
    function splitSectionsNics(lines) {
      const result = [];
      let section = [];
      lines.forEach(function(line) {
        if (!line.startsWith("	") && !line.startsWith(" ")) {
          if (section.length) {
            result.push(section);
            section = [];
          }
        }
        section.push(line);
      });
      if (section.length) {
        result.push(section);
      }
      return result;
    }
    function parseLinesDarwinNics(sections) {
      let nics = [];
      sections.forEach((section) => {
        let nic = {
          iface: "",
          mtu: -1,
          mac: "",
          ip6: "",
          ip4: "",
          speed: -1,
          type: "",
          operstate: "",
          duplex: "",
          internal: false
        };
        const first = section[0];
        nic.iface = first.split(":")[0].trim();
        let parts = first.split("> mtu");
        nic.mtu = parts.length > 1 ? parseInt(parts[1], 10) : -1;
        if (isNaN(nic.mtu)) {
          nic.mtu = -1;
        }
        nic.internal = parts[0].toLowerCase().indexOf("loopback") > -1;
        section.forEach((line) => {
          if (line.trim().startsWith("ether ")) {
            nic.mac = line.split("ether ")[1].toLowerCase().trim();
          }
          if (line.trim().startsWith("inet6 ") && !nic.ip6) {
            nic.ip6 = line.split("inet6 ")[1].toLowerCase().split("%")[0].split(" ")[0];
          }
          if (line.trim().startsWith("inet ") && !nic.ip4) {
            nic.ip4 = line.split("inet ")[1].toLowerCase().split(" ")[0];
          }
        });
        let speed = util.getValue(section, "link rate");
        nic.speed = speed ? parseFloat(speed) : -1;
        if (nic.speed === -1) {
          speed = util.getValue(section, "uplink rate");
          nic.speed = speed ? parseFloat(speed) : -1;
          if (nic.speed > -1 && speed.toLowerCase().indexOf("gbps") >= 0) {
            nic.speed = nic.speed * 1e3;
          }
        } else {
          if (speed.toLowerCase().indexOf("gbps") >= 0) {
            nic.speed = nic.speed * 1e3;
          }
        }
        nic.type = util.getValue(section, "type").toLowerCase().indexOf("wi-fi") > -1 ? "wireless" : "wired";
        nic.operstate = util.getValue(section, "status").toLowerCase().indexOf("active") > -1 ? "up" : "down";
        nic.duplex = util.getValue(section, "media").toLowerCase().indexOf("half-duplex") > -1 ? "half" : "full";
        if (nic.ip6 || nic.ip4 || nic.mac) {
          nics.push(nic);
        }
      });
      return nics;
    }
    function getDarwinNics() {
      const cmd = "/sbin/ifconfig -v";
      try {
        const lines = execSync(cmd, { maxBuffer: 1024 * 2e4 }).toString().split("\n");
        const nsections = splitSectionsNics(lines);
        return parseLinesDarwinNics(nsections);
      } catch (e) {
        return [];
      }
    }
    function getLinuxIfaceConnectionName(interfaceName) {
      const cmd = `nmcli device status 2>/dev/null | grep ${interfaceName}`;
      try {
        const result = execSync(cmd).toString();
        const resultFormat = result.replace(/\s+/g, " ").trim();
        const connectionNameLines = resultFormat.split(" ").slice(3);
        const connectionName = connectionNameLines.join(" ");
        return connectionName != "--" ? connectionName : "";
      } catch (e) {
        return "";
      }
    }
    function checkLinuxDCHPInterfaces(file) {
      let result = [];
      try {
        let cmd = `cat ${file} 2> /dev/null | grep 'iface\\|source'`;
        const lines = execSync(cmd, { maxBuffer: 1024 * 2e4 }).toString().split("\n");
        lines.forEach((line) => {
          const parts = line.replace(/\s+/g, " ").trim().split(" ");
          if (parts.length >= 4) {
            if (line.toLowerCase().indexOf(" inet ") >= 0 && line.toLowerCase().indexOf("dhcp") >= 0) {
              result.push(parts[1]);
            }
          }
          if (line.toLowerCase().includes("source")) {
            let file2 = line.split(" ")[1];
            result = result.concat(checkLinuxDCHPInterfaces(file2));
          }
        });
      } catch (e) {
        util.noop();
      }
      return result;
    }
    function getLinuxDHCPNics() {
      let cmd = "ip a 2> /dev/null";
      let result = [];
      try {
        const lines = execSync(cmd, { maxBuffer: 1024 * 2e4 }).toString().split("\n");
        const nsections = splitSectionsNics(lines);
        result = parseLinuxDHCPNics(nsections);
      } catch (e) {
        util.noop();
      }
      try {
        result = checkLinuxDCHPInterfaces("/etc/network/interfaces");
      } catch (e) {
        util.noop();
      }
      return result;
    }
    function parseLinuxDHCPNics(sections) {
      const result = [];
      if (sections && sections.length) {
        sections.forEach((lines) => {
          if (lines && lines.length) {
            const parts = lines[0].split(":");
            if (parts.length > 2) {
              for (let line of lines) {
                if (line.indexOf(" inet ") >= 0 && line.indexOf(" dynamic ") >= 0) {
                  const parts2 = line.split(" ");
                  const nic = parts2[parts2.length - 1].trim();
                  result.push(nic);
                  break;
                }
              }
            }
          }
        });
      }
      return result;
    }
    function getLinuxIfaceDHCPstatus(iface, connectionName, DHCPNics) {
      let result = false;
      if (connectionName) {
        const cmd = `nmcli connection show "${connectionName}" 2>/dev/null | grep ipv4.method;`;
        try {
          const lines = execSync(cmd).toString();
          const resultFormat = lines.replace(/\s+/g, " ").trim();
          let dhcStatus = resultFormat.split(" ").slice(1).toString();
          switch (dhcStatus) {
            case "auto":
              result = true;
              break;
            default:
              result = false;
              break;
          }
          return result;
        } catch (e) {
          return DHCPNics.indexOf(iface) >= 0;
        }
      } else {
        return DHCPNics.indexOf(iface) >= 0;
      }
    }
    function getDarwinIfaceDHCPstatus(iface) {
      let result = false;
      const cmd = `ipconfig getpacket "${iface}" 2>/dev/null | grep lease_time;`;
      try {
        const lines = execSync(cmd).toString().split("\n");
        if (lines.length && lines[0].startsWith("lease_time")) {
          result = true;
        }
      } catch (e) {
        util.noop();
      }
      return result;
    }
    function getLinuxIfaceDNSsuffix(connectionName) {
      if (connectionName) {
        const cmd = `nmcli connection show "${connectionName}" 2>/dev/null | grep ipv4.dns-search;`;
        try {
          const result = execSync(cmd).toString();
          const resultFormat = result.replace(/\s+/g, " ").trim();
          const dnsSuffix = resultFormat.split(" ").slice(1).toString();
          return dnsSuffix == "--" ? "Not defined" : dnsSuffix;
        } catch (e) {
          return "Unknown";
        }
      } else {
        return "Unknown";
      }
    }
    function getLinuxIfaceIEEE8021xAuth(connectionName) {
      if (connectionName) {
        const cmd = `nmcli connection show "${connectionName}" 2>/dev/null | grep 802-1x.eap;`;
        try {
          const result = execSync(cmd).toString();
          const resultFormat = result.replace(/\s+/g, " ").trim();
          const authenticationProtocol = resultFormat.split(" ").slice(1).toString();
          return authenticationProtocol == "--" ? "" : authenticationProtocol;
        } catch (e) {
          return "Not defined";
        }
      } else {
        return "Not defined";
      }
    }
    function getLinuxIfaceIEEE8021xState(authenticationProtocol) {
      if (authenticationProtocol) {
        if (authenticationProtocol == "Not defined") {
          return "Disabled";
        }
        return "Enabled";
      } else {
        return "Unknown";
      }
    }
    function testVirtualNic(iface, ifaceName, mac) {
      const virtualMacs = ["00:00:00:00:00:00", "00:03:FF", "00:05:69", "00:0C:29", "00:0F:4B", "00:0F:4B", "00:13:07", "00:13:BE", "00:15:5d", "00:16:3E", "00:1C:42", "00:21:F6", "00:21:F6", "00:24:0B", "00:24:0B", "00:50:56", "00:A0:B1", "00:E0:C8", "08:00:27", "0A:00:27", "18:92:2C", "16:DF:49", "3C:F3:92", "54:52:00", "FC:15:97"];
      if (mac) {
        return virtualMacs.filter((item) => {
          return mac.toUpperCase().toUpperCase().startsWith(item.substr(0, mac.length));
        }).length > 0 || iface.toLowerCase().indexOf(" virtual ") > -1 || ifaceName.toLowerCase().indexOf(" virtual ") > -1 || iface.toLowerCase().indexOf("vethernet ") > -1 || ifaceName.toLowerCase().indexOf("vethernet ") > -1 || iface.toLowerCase().startsWith("veth") || ifaceName.toLowerCase().startsWith("veth") || iface.toLowerCase().startsWith("vboxnet") || ifaceName.toLowerCase().startsWith("vboxnet");
      } else
        return false;
    }
    function networkInterfaces(callback, rescan = true) {
      if (typeof callback === "boolean") {
        rescan = callback;
        callback = null;
      }
      return new Promise((resolve) => {
        process.nextTick(() => {
          let ifaces = os.networkInterfaces();
          let result = [];
          let nics = [];
          let dnsSuffixes = [];
          let nics8021xInfo = [];
          if (_darwin || _freebsd || _openbsd || _netbsd) {
            nics = getDarwinNics();
            nics.forEach((nic) => {
              if ({}.hasOwnProperty.call(ifaces, nic.iface)) {
                ifaces[nic.iface].forEach(function(details) {
                  if (details.family === "IPv4") {
                    nic.ip4subnet = details.netmask;
                  }
                  if (details.family === "IPv6") {
                    nic.ip6subnet = details.netmask;
                  }
                });
              }
              result.push({
                iface: nic.iface,
                ifaceName: nic.iface,
                ip4: nic.ip4,
                ip4subnet: nic.ip4subnet || "",
                ip6: nic.ip6,
                ip6subnet: nic.ip6subnet || "",
                mac: nic.mac,
                internal: nic.internal,
                virtual: nic.internal ? false : testVirtualNic(nic.iface, nic.iface, nic.mac),
                operstate: nic.operstate,
                type: nic.type,
                duplex: nic.duplex,
                mtu: nic.mtu,
                speed: nic.speed,
                dhcp: getDarwinIfaceDHCPstatus(nic.iface),
                dnsSuffix: "",
                ieee8021xAuth: "",
                ieee8021xState: "",
                carrierChanges: 0
              });
            });
            _networkInterfaces = result;
            if (callback) {
              callback(result);
            }
            resolve(result);
          } else {
            if (JSON.stringify(ifaces) === JSON.stringify(_ifaces) && !rescan) {
              result = _networkInterfaces;
              if (callback) {
                callback(result);
              }
              resolve(result);
            } else {
              _ifaces = Object.assign({}, ifaces);
              if (_windows) {
                nics = getWindowsNics();
                nics.forEach((nic) => {
                  let found = false;
                  Object.keys(ifaces).forEach((key) => {
                    if (!found) {
                      ifaces[key].forEach((value) => {
                        if (Object.keys(value).indexOf("mac") >= 0) {
                          found = value["mac"] === nic.mac;
                        }
                      });
                    }
                  });
                  if (!found) {
                    ifaces[nic.name] = [{ mac: nic.mac }];
                  }
                });
                nics8021xInfo = getWindowsWiredProfilesInformation();
                dnsSuffixes = getWindowsDNSsuffixes();
              }
              if (_linux) {
                _dhcpNics = getLinuxDHCPNics();
              }
              for (let dev in ifaces) {
                let ip4 = "";
                let ip4subnet = "";
                let ip6 = "";
                let ip6subnet = "";
                let mac = "";
                let duplex = "";
                let mtu = "";
                let speed = -1;
                let carrierChanges = 0;
                let operstate = "down";
                let dhcp = false;
                let dnsSuffix = "";
                let ieee8021xAuth = "";
                let ieee8021xState = "";
                let type = "";
                if ({}.hasOwnProperty.call(ifaces, dev)) {
                  let ifaceName = dev;
                  ifaces[dev].forEach(function(details) {
                    if (details.family === "IPv4") {
                      ip4 = details.address;
                      ip4subnet = details.netmask;
                    }
                    if (details.family === "IPv6") {
                      if (!ip6 || ip6.match(/^fe80::/i)) {
                        ip6 = details.address;
                        ip6subnet = details.netmask;
                      }
                    }
                    mac = details.mac;
                    if (mac.indexOf("00:00:0") > -1 && (_linux || _darwin) && parseInt(process.versions.node.split("."), 10) === 8) {
                      if (Object.keys(_mac).length === 0) {
                        _mac = getMacAddresses();
                      }
                      mac = _mac[dev] || "";
                    }
                  });
                  if (_linux) {
                    let iface = dev.split(":")[0].trim().toLowerCase();
                    const cmd = `echo -n "addr_assign_type: "; cat /sys/class/net/${iface}/addr_assign_type 2>/dev/null; echo;
            echo -n "address: "; cat /sys/class/net/${iface}/address 2>/dev/null; echo;
            echo -n "addr_len: "; cat /sys/class/net/${iface}/addr_len 2>/dev/null; echo;
            echo -n "broadcast: "; cat /sys/class/net/${iface}/broadcast 2>/dev/null; echo;
            echo -n "carrier: "; cat /sys/class/net/${iface}/carrier 2>/dev/null; echo;
            echo -n "carrier_changes: "; cat /sys/class/net/${iface}/carrier_changes 2>/dev/null; echo;
            echo -n "dev_id: "; cat /sys/class/net/${iface}/dev_id 2>/dev/null; echo;
            echo -n "dev_port: "; cat /sys/class/net/${iface}/dev_port 2>/dev/null; echo;
            echo -n "dormant: "; cat /sys/class/net/${iface}/dormant 2>/dev/null; echo;
            echo -n "duplex: "; cat /sys/class/net/${iface}/duplex 2>/dev/null; echo;
            echo -n "flags: "; cat /sys/class/net/${iface}/flags 2>/dev/null; echo;
            echo -n "gro_flush_timeout: "; cat /sys/class/net/${iface}/gro_flush_timeout 2>/dev/null; echo;
            echo -n "ifalias: "; cat /sys/class/net/${iface}/ifalias 2>/dev/null; echo;
            echo -n "ifindex: "; cat /sys/class/net/${iface}/ifindex 2>/dev/null; echo;
            echo -n "iflink: "; cat /sys/class/net/${iface}/iflink 2>/dev/null; echo;
            echo -n "link_mode: "; cat /sys/class/net/${iface}/link_mode 2>/dev/null; echo;
            echo -n "mtu: "; cat /sys/class/net/${iface}/mtu 2>/dev/null; echo;
            echo -n "netdev_group: "; cat /sys/class/net/${iface}/netdev_group 2>/dev/null; echo;
            echo -n "operstate: "; cat /sys/class/net/${iface}/operstate 2>/dev/null; echo;
            echo -n "proto_down: "; cat /sys/class/net/${iface}/proto_down 2>/dev/null; echo;
            echo -n "speed: "; cat /sys/class/net/${iface}/speed 2>/dev/null; echo;
            echo -n "tx_queue_len: "; cat /sys/class/net/${iface}/tx_queue_len 2>/dev/null; echo;
            echo -n "type: "; cat /sys/class/net/${iface}/type 2>/dev/null; echo;
            echo -n "wireless: "; cat /proc/net/wireless 2>/dev/null | grep ${iface}; echo;
            echo -n "wirelessspeed: "; iw dev ${iface} link 2>&1 | grep bitrate; echo;`;
                    let lines = [];
                    try {
                      lines = execSync(cmd).toString().split("\n");
                      const connectionName = getLinuxIfaceConnectionName(iface);
                      dhcp = getLinuxIfaceDHCPstatus(iface, connectionName, _dhcpNics);
                      dnsSuffix = getLinuxIfaceDNSsuffix(connectionName);
                      ieee8021xAuth = getLinuxIfaceIEEE8021xAuth(connectionName);
                      ieee8021xState = getLinuxIfaceIEEE8021xState(ieee8021xAuth);
                    } catch (e) {
                      util.noop();
                    }
                    duplex = util.getValue(lines, "duplex");
                    duplex = duplex.startsWith("cat") ? "" : duplex;
                    mtu = parseInt(util.getValue(lines, "mtu"), 10);
                    let myspeed = parseInt(util.getValue(lines, "speed"), 10);
                    speed = isNaN(myspeed) ? -1 : myspeed;
                    let wirelessspeed = util.getValue(lines, "wirelessspeed").split("tx bitrate: ");
                    if (speed === -1 && wirelessspeed.length === 2) {
                      myspeed = parseFloat(wirelessspeed[1]);
                      speed = isNaN(myspeed) ? -1 : myspeed;
                    }
                    carrierChanges = parseInt(util.getValue(lines, "carrier_changes"), 10);
                    operstate = util.getValue(lines, "operstate");
                    type = operstate === "up" ? util.getValue(lines, "wireless").trim() ? "wireless" : "wired" : "unknown";
                    if (iface === "lo" || iface.startsWith("bond")) {
                      type = "virtual";
                    }
                  }
                  if (_windows) {
                    dnsSuffix = getWindowsIfaceDNSsuffix(dnsSuffixes.ifaces, dev);
                    nics.forEach((detail) => {
                      if (detail.mac === mac) {
                        ifaceName = detail.name;
                        dhcp = detail.dhcp;
                        operstate = detail.operstate;
                        speed = detail.speed;
                        type = detail.type;
                      }
                    });
                    if (dev.toLowerCase().indexOf("wlan") >= 0 || ifaceName.toLowerCase().indexOf("wlan") >= 0 || ifaceName.toLowerCase().indexOf("802.11n") >= 0 || ifaceName.toLowerCase().indexOf("wireless") >= 0 || ifaceName.toLowerCase().indexOf("wi-fi") >= 0 || ifaceName.toLowerCase().indexOf("wifi") >= 0) {
                      type = "wireless";
                    }
                    const IEEE8021x = getWindowsIEEE8021x(type, dev, nics8021xInfo);
                    ieee8021xAuth = IEEE8021x.protocol;
                    ieee8021xState = IEEE8021x.state;
                  }
                  let internal = ifaces[dev] && ifaces[dev][0] ? ifaces[dev][0].internal : false;
                  if (dev.toLowerCase().indexOf("loopback") > -1 || ifaceName.toLowerCase().indexOf("loopback") > -1) {
                    internal = true;
                  }
                  const virtual = internal ? false : testVirtualNic(dev, ifaceName, mac);
                  result.push({
                    iface: dev,
                    ifaceName,
                    ip4,
                    ip4subnet,
                    ip6,
                    ip6subnet,
                    mac,
                    internal,
                    virtual,
                    operstate,
                    type,
                    duplex,
                    mtu,
                    speed,
                    dhcp,
                    dnsSuffix,
                    ieee8021xAuth,
                    ieee8021xState,
                    carrierChanges
                  });
                }
              }
              _networkInterfaces = result;
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.networkInterfaces = networkInterfaces;
    function calcNetworkSpeed(iface, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors) {
      let result = {
        iface,
        operstate,
        rx_bytes,
        rx_dropped,
        rx_errors,
        tx_bytes,
        tx_dropped,
        tx_errors,
        rx_sec: -1,
        tx_sec: -1,
        ms: 0
      };
      if (_network[iface] && _network[iface].ms) {
        result.ms = Date.now() - _network[iface].ms;
        result.rx_sec = rx_bytes - _network[iface].rx_bytes >= 0 ? (rx_bytes - _network[iface].rx_bytes) / (result.ms / 1e3) : 0;
        result.tx_sec = tx_bytes - _network[iface].tx_bytes >= 0 ? (tx_bytes - _network[iface].tx_bytes) / (result.ms / 1e3) : 0;
        _network[iface].rx_bytes = rx_bytes;
        _network[iface].tx_bytes = tx_bytes;
        _network[iface].rx_sec = result.rx_sec;
        _network[iface].tx_sec = result.tx_sec;
        _network[iface].ms = Date.now();
        _network[iface].last_ms = result.ms;
        _network[iface].operstate = operstate;
      } else {
        if (!_network[iface])
          _network[iface] = {};
        _network[iface].rx_bytes = rx_bytes;
        _network[iface].tx_bytes = tx_bytes;
        _network[iface].rx_sec = -1;
        _network[iface].tx_sec = -1;
        _network[iface].ms = Date.now();
        _network[iface].last_ms = 0;
        _network[iface].operstate = operstate;
      }
      return result;
    }
    function networkStats(ifaces, callback) {
      let ifacesArray = [];
      if (util.isFunction(ifaces) && !callback) {
        callback = ifaces;
        ifacesArray = [getDefaultNetworkInterface()];
      } else {
        ifaces = ifaces || getDefaultNetworkInterface();
        ifaces = ifaces.trim().toLowerCase().replace(/,+/g, "|");
        ifacesArray = ifaces.split("|");
      }
      return new Promise((resolve) => {
        process.nextTick(() => {
          const result = [];
          const workload = [];
          if (ifacesArray.length && ifacesArray[0].trim() === "*") {
            ifacesArray = [];
            networkInterfaces(false).then((allIFaces) => {
              for (let iface of allIFaces) {
                ifacesArray.push(iface.iface);
              }
              networkStats(ifacesArray.join(",")).then((result2) => {
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              });
            });
          } else {
            for (let iface of ifacesArray) {
              workload.push(networkStatsSingle(iface.trim()));
            }
            if (workload.length) {
              Promise.all(
                workload
              ).then((data) => {
                if (callback) {
                  callback(data);
                }
                resolve(data);
              });
            } else {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    function networkStatsSingle(iface) {
      function parseLinesWindowsPerfData(sections) {
        let perfData = [];
        for (let i in sections) {
          if ({}.hasOwnProperty.call(sections, i)) {
            if (sections[i].trim() !== "") {
              let lines = sections[i].trim().split("\r\n");
              perfData.push({
                name: util.getValue(lines, "Name", "=").replace(/[()\[\] ]+/g, "").replace("#", "_").toLowerCase(),
                rx_bytes: parseInt(util.getValue(lines, "BytesReceivedPersec", "="), 10),
                rx_errors: parseInt(util.getValue(lines, "PacketsReceivedErrors", "="), 10),
                rx_dropped: parseInt(util.getValue(lines, "PacketsReceivedDiscarded", "="), 10),
                tx_bytes: parseInt(util.getValue(lines, "BytesSentPersec", "="), 10),
                tx_errors: parseInt(util.getValue(lines, "PacketsOutboundErrors", "="), 10),
                tx_dropped: parseInt(util.getValue(lines, "PacketsOutboundDiscarded", "="), 10)
              });
            }
          }
        }
        return perfData;
      }
      return new Promise((resolve) => {
        process.nextTick(() => {
          const ifaceSanitized = util.sanitizeShellString(iface);
          let result = {
            iface: ifaceSanitized,
            operstate: "unknown",
            rx_bytes: 0,
            rx_dropped: 0,
            rx_errors: 0,
            tx_bytes: 0,
            tx_dropped: 0,
            tx_errors: 0,
            rx_sec: -1,
            tx_sec: -1,
            ms: 0
          };
          let operstate = "unknown";
          let rx_bytes = 0;
          let tx_bytes = 0;
          let rx_dropped = 0;
          let rx_errors = 0;
          let tx_dropped = 0;
          let tx_errors = 0;
          let cmd, lines, stats;
          if (!_network[ifaceSanitized] || _network[ifaceSanitized] && !_network[ifaceSanitized].ms || _network[ifaceSanitized] && _network[ifaceSanitized].ms && Date.now() - _network[ifaceSanitized].ms >= 500) {
            if (_linux) {
              if (fs2.existsSync("/sys/class/net/" + ifaceSanitized)) {
                cmd = "cat /sys/class/net/" + ifaceSanitized + "/operstate; cat /sys/class/net/" + ifaceSanitized + "/statistics/rx_bytes; cat /sys/class/net/" + ifaceSanitized + "/statistics/tx_bytes; cat /sys/class/net/" + ifaceSanitized + "/statistics/rx_dropped; cat /sys/class/net/" + ifaceSanitized + "/statistics/rx_errors; cat /sys/class/net/" + ifaceSanitized + "/statistics/tx_dropped; cat /sys/class/net/" + ifaceSanitized + "/statistics/tx_errors; ";
                exec2(cmd, function(error, stdout) {
                  if (!error) {
                    lines = stdout.toString().split("\n");
                    operstate = lines[0].trim();
                    rx_bytes = parseInt(lines[1], 10);
                    tx_bytes = parseInt(lines[2], 10);
                    rx_dropped = parseInt(lines[3], 10);
                    rx_errors = parseInt(lines[4], 10);
                    tx_dropped = parseInt(lines[5], 10);
                    tx_errors = parseInt(lines[6], 10);
                    result = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);
                  }
                  resolve(result);
                });
              } else {
                resolve(result);
              }
            }
            if (_freebsd || _openbsd || _netbsd) {
              cmd = "netstat -ibndI " + ifaceSanitized;
              exec2(cmd, function(error, stdout) {
                if (!error) {
                  lines = stdout.toString().split("\n");
                  for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].replace(/ +/g, " ").split(" ");
                    if (line && line[0] && line[7] && line[10]) {
                      rx_bytes = rx_bytes + parseInt(line[7]);
                      if (line[6].trim() !== "-") {
                        rx_dropped = rx_dropped + parseInt(line[6]);
                      }
                      if (line[5].trim() !== "-") {
                        rx_errors = rx_errors + parseInt(line[5]);
                      }
                      tx_bytes = tx_bytes + parseInt(line[10]);
                      if (line[12].trim() !== "-") {
                        tx_dropped = tx_dropped + parseInt(line[12]);
                      }
                      if (line[9].trim() !== "-") {
                        tx_errors = tx_errors + parseInt(line[9]);
                      }
                      operstate = "up";
                    }
                  }
                  result = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);
                }
                resolve(result);
              });
            }
            if (_darwin) {
              cmd = "ifconfig " + ifaceSanitized + ' | grep "status"';
              exec2(cmd, function(error, stdout) {
                result.operstate = (stdout.toString().split(":")[1] || "").trim();
                result.operstate = (result.operstate || "").toLowerCase();
                result.operstate = result.operstate === "active" ? "up" : result.operstate === "inactive" ? "down" : "unknown";
                cmd = "netstat -bdI " + ifaceSanitized;
                exec2(cmd, function(error2, stdout2) {
                  if (!error2) {
                    lines = stdout2.toString().split("\n");
                    if (lines.length > 1 && lines[1].trim() !== "") {
                      stats = lines[1].replace(/ +/g, " ").split(" ");
                      rx_bytes = parseInt(stats[6]);
                      rx_dropped = parseInt(stats[11]);
                      rx_errors = parseInt(stats[5]);
                      tx_bytes = parseInt(stats[9]);
                      tx_dropped = parseInt(stats[11]);
                      tx_errors = parseInt(stats[8]);
                      result = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, result.operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);
                    }
                  }
                  resolve(result);
                });
              });
            }
            if (_windows) {
              let perfData = [];
              let ifaceName = ifaceSanitized;
              util.wmic("path Win32_PerfRawData_Tcpip_NetworkInterface Get name,BytesReceivedPersec,BytesSentPersec,BytesTotalPersec,PacketsOutboundDiscarded,PacketsOutboundErrors,PacketsReceivedDiscarded,PacketsReceivedErrors /value").then((stdout, error) => {
                if (!error) {
                  const psections = stdout.toString().split(/\n\s*\n/);
                  perfData = parseLinesWindowsPerfData(psections);
                }
                networkInterfaces(false).then((interfaces) => {
                  rx_bytes = 0;
                  tx_bytes = 0;
                  perfData.forEach((detail) => {
                    interfaces.forEach((det) => {
                      if ((det.iface.toLowerCase() === ifaceSanitized.toLowerCase() || det.mac.toLowerCase() === ifaceSanitized.toLowerCase() || det.ip4.toLowerCase() === ifaceSanitized.toLowerCase() || det.ip6.toLowerCase() === ifaceSanitized.toLowerCase() || det.ifaceName.replace(/[()\[\] ]+/g, "").replace("#", "_").toLowerCase() === ifaceSanitized.replace(/[()\[\] ]+/g, "").replace("#", "_").toLowerCase()) && det.ifaceName.replace(/[()\[\] ]+/g, "").replace("#", "_").toLowerCase() === detail.name) {
                        ifaceName = det.iface;
                        rx_bytes = detail.rx_bytes;
                        rx_dropped = detail.rx_dropped;
                        rx_errors = detail.rx_errors;
                        tx_bytes = detail.tx_bytes;
                        tx_dropped = detail.tx_dropped;
                        tx_errors = detail.tx_errors;
                        operstate = det.operstate;
                      }
                    });
                  });
                  if (rx_bytes && tx_bytes) {
                    result = calcNetworkSpeed(ifaceName, parseInt(rx_bytes), parseInt(tx_bytes), operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);
                  }
                  resolve(result);
                });
              });
            }
          } else {
            result.rx_bytes = _network[ifaceSanitized].rx_bytes;
            result.tx_bytes = _network[ifaceSanitized].tx_bytes;
            result.rx_sec = _network[ifaceSanitized].rx_sec;
            result.tx_sec = _network[ifaceSanitized].tx_sec;
            result.ms = _network[ifaceSanitized].last_ms;
            result.operstate = _network[ifaceSanitized].operstate;
            resolve(result);
          }
        });
      });
    }
    exports.networkStats = networkStats;
    function networkConnections(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = [];
          if (_linux || _freebsd || _openbsd || _netbsd) {
            let cmd = 'export LC_ALL=C; netstat -tunap | grep "ESTABLISHED\\|SYN_SENT\\|SYN_RECV\\|FIN_WAIT1\\|FIN_WAIT2\\|TIME_WAIT\\|CLOSE\\|CLOSE_WAIT\\|LAST_ACK\\|LISTEN\\|CLOSING\\|UNKNOWN"; unset LC_ALL';
            if (_freebsd || _openbsd || _netbsd)
              cmd = 'export LC_ALL=C; netstat -na | grep "ESTABLISHED\\|SYN_SENT\\|SYN_RECV\\|FIN_WAIT1\\|FIN_WAIT2\\|TIME_WAIT\\|CLOSE\\|CLOSE_WAIT\\|LAST_ACK\\|LISTEN\\|CLOSING\\|UNKNOWN"; unset LC_ALL';
            exec2(cmd, { maxBuffer: 1024 * 2e4 }, function(error, stdout) {
              let lines = stdout.toString().split("\n");
              if (!error && (lines.length > 1 || lines[0] != "")) {
                lines.forEach(function(line) {
                  line = line.replace(/ +/g, " ").split(" ");
                  if (line.length >= 7) {
                    let localip = line[3];
                    let localport = "";
                    let localaddress = line[3].split(":");
                    if (localaddress.length > 1) {
                      localport = localaddress[localaddress.length - 1];
                      localaddress.pop();
                      localip = localaddress.join(":");
                    }
                    let peerip = line[4];
                    let peerport = "";
                    let peeraddress = line[4].split(":");
                    if (peeraddress.length > 1) {
                      peerport = peeraddress[peeraddress.length - 1];
                      peeraddress.pop();
                      peerip = peeraddress.join(":");
                    }
                    let connstate = line[5];
                    let proc = line[6].split("/");
                    if (connstate) {
                      result.push({
                        protocol: line[0],
                        localaddress: localip,
                        localport,
                        peeraddress: peerip,
                        peerport,
                        state: connstate,
                        pid: proc[0] && proc[0] !== "-" ? parseInt(proc[0], 10) : -1,
                        process: proc[1] ? proc[1].split(" ")[0] : ""
                      });
                    }
                  }
                });
                if (callback) {
                  callback(result);
                }
                resolve(result);
              } else {
                cmd = 'ss -tunap | grep "ESTAB\\|SYN-SENT\\|SYN-RECV\\|FIN-WAIT1\\|FIN-WAIT2\\|TIME-WAIT\\|CLOSE\\|CLOSE-WAIT\\|LAST-ACK\\|LISTEN\\|CLOSING"';
                exec2(cmd, { maxBuffer: 1024 * 2e4 }, function(error2, stdout2) {
                  if (!error2) {
                    let lines2 = stdout2.toString().split("\n");
                    lines2.forEach(function(line) {
                      line = line.replace(/ +/g, " ").split(" ");
                      if (line.length >= 6) {
                        let localip = line[4];
                        let localport = "";
                        let localaddress = line[4].split(":");
                        if (localaddress.length > 1) {
                          localport = localaddress[localaddress.length - 1];
                          localaddress.pop();
                          localip = localaddress.join(":");
                        }
                        let peerip = line[5];
                        let peerport = "";
                        let peeraddress = line[5].split(":");
                        if (peeraddress.length > 1) {
                          peerport = peeraddress[peeraddress.length - 1];
                          peeraddress.pop();
                          peerip = peeraddress.join(":");
                        }
                        let connstate = line[1];
                        if (connstate === "ESTAB")
                          connstate = "ESTABLISHED";
                        if (connstate === "TIME-WAIT")
                          connstate = "TIME_WAIT";
                        let pid = -1;
                        let process2 = "";
                        if (line.length >= 7 && line[6].indexOf("users:") > -1) {
                          let proc = line[6].replace('users:(("', "").replace(/"/g, "").split(",");
                          if (proc.length > 2) {
                            process2 = proc[0].split(" ")[0];
                            pid = parseInt(proc[1], 10);
                          }
                        }
                        if (connstate) {
                          result.push({
                            protocol: line[0],
                            localaddress: localip,
                            localport,
                            peeraddress: peerip,
                            peerport,
                            state: connstate,
                            pid,
                            process: process2
                          });
                        }
                      }
                    });
                  }
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                });
              }
            });
          }
          if (_darwin) {
            let cmd = 'netstat -natv | grep "ESTABLISHED\\|SYN_SENT\\|SYN_RECV\\|FIN_WAIT1\\|FIN_WAIT2\\|TIME_WAIT\\|CLOSE\\|CLOSE_WAIT\\|LAST_ACK\\|LISTEN\\|CLOSING\\|UNKNOWN"';
            exec2(cmd, { maxBuffer: 1024 * 2e4 }, function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                lines.forEach(function(line) {
                  line = line.replace(/ +/g, " ").split(" ");
                  if (line.length >= 8) {
                    let localip = line[3];
                    let localport = "";
                    let localaddress = line[3].split(".");
                    if (localaddress.length > 1) {
                      localport = localaddress[localaddress.length - 1];
                      localaddress.pop();
                      localip = localaddress.join(".");
                    }
                    let peerip = line[4];
                    let peerport = "";
                    let peeraddress = line[4].split(".");
                    if (peeraddress.length > 1) {
                      peerport = peeraddress[peeraddress.length - 1];
                      peeraddress.pop();
                      peerip = peeraddress.join(".");
                    }
                    let connstate = line[5];
                    let pid = parseInt(line[8], 10);
                    if (connstate) {
                      result.push({
                        protocol: line[0],
                        localaddress: localip,
                        localport,
                        peeraddress: peerip,
                        peerport,
                        state: connstate,
                        pid,
                        process: ""
                      });
                    }
                  }
                });
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            });
          }
          if (_windows) {
            let cmd = "netstat -nao";
            try {
              exec2(cmd, util.execOptsWin, function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\r\n");
                  lines.forEach(function(line) {
                    line = line.trim().replace(/ +/g, " ").split(" ");
                    if (line.length >= 4) {
                      let localip = line[1];
                      let localport = "";
                      let localaddress = line[1].split(":");
                      if (localaddress.length > 1) {
                        localport = localaddress[localaddress.length - 1];
                        localaddress.pop();
                        localip = localaddress.join(":");
                      }
                      let peerip = line[2];
                      let peerport = "";
                      let peeraddress = line[2].split(":");
                      if (peeraddress.length > 1) {
                        peerport = peeraddress[peeraddress.length - 1];
                        peeraddress.pop();
                        peerip = peeraddress.join(":");
                      }
                      let pid = line[4];
                      let connstate = line[3];
                      if (connstate === "HERGESTELLT")
                        connstate = "ESTABLISHED";
                      if (connstate.startsWith("ABH"))
                        connstate = "LISTEN";
                      if (connstate === "SCHLIESSEN_WARTEN")
                        connstate = "CLOSE_WAIT";
                      if (connstate === "WARTEND")
                        connstate = "TIME_WAIT";
                      if (connstate === "SYN_GESENDET")
                        connstate = "SYN_SENT";
                      if (connstate === "LISTENING")
                        connstate = "LISTEN";
                      if (connstate === "SYN_RECEIVED")
                        connstate = "SYN_RECV";
                      if (connstate === "FIN_WAIT_1")
                        connstate = "FIN_WAIT1";
                      if (connstate === "FIN_WAIT_2")
                        connstate = "FIN_WAIT2";
                      if (connstate) {
                        result.push({
                          protocol: line[0].toLowerCase(),
                          localaddress: localip,
                          localport,
                          peeraddress: peerip,
                          peerport,
                          state: connstate,
                          pid,
                          process: ""
                        });
                      }
                    }
                  });
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.networkConnections = networkConnections;
    function networkGatewayDefault(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = "";
          if (_linux || _freebsd || _openbsd || _netbsd) {
            let cmd = "ip route get 1";
            try {
              exec2(cmd, { maxBuffer: 1024 * 2e4 }, function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  const line = lines && lines[0] ? lines[0] : "";
                  let parts = line.split(" via ");
                  if (parts && parts[1]) {
                    parts = parts[1].split(" ");
                    result = parts[0];
                  }
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
          if (_darwin) {
            let cmd = "route -n get default";
            try {
              exec2(cmd, { maxBuffer: 1024 * 2e4 }, function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n").map((line) => line.trim());
                  result = util.getValue(lines, "gateway");
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
          if (_windows) {
            try {
              exec2("netstat -r", util.execOptsWin, function(error, stdout) {
                const lines = stdout.toString().split(os.EOL);
                lines.forEach((line) => {
                  line = line.replace(/\s+/g, " ").trim();
                  if (line.indexOf("0.0.0.0 0.0.0.0") > -1 && !/[a-zA-Z]/.test(line)) {
                    const parts = line.split(" ");
                    if (parts.length >= 5 && parts[parts.length - 3].indexOf(".") > -1) {
                      result = parts[parts.length - 3];
                    }
                  }
                });
                if (!result) {
                  util.powerShell("Get-CimInstance -ClassName Win32_IP4RouteTable | Where-Object { $_.Destination -eq '0.0.0.0' -and $_.Mask -eq '0.0.0.0' }").then((data) => {
                    let lines2 = data.toString().split("\r\n");
                    if (lines2.length > 1 && !result) {
                      result = util.getValue(lines2, "NextHop");
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                    }
                  });
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.networkGatewayDefault = networkGatewayDefault;
  }
});

// node_modules/@jedithepro/system-info/lib/wifi.js
var require_wifi = __commonJS({
  "node_modules/@jedithepro/system-info/lib/wifi.js"(exports) {
    "use strict";
    var os = require("os");
    var exec2 = require("child_process").exec;
    var util = require_util2();
    var _platform = process.platform;
    var _linux = _platform === "linux";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    function wifiDBFromQuality(quality) {
      return parseFloat(quality) / 2 - 100;
    }
    function wifiQualityFromDB(db) {
      const result = 2 * (parseFloat(db) + 100);
      return result <= 100 ? result : 100;
    }
    function wifiFrequencyFromChannel(channel) {
      const frequencies = {
        1: 2412,
        2: 2417,
        3: 2422,
        4: 2427,
        5: 2432,
        6: 2437,
        7: 2442,
        8: 2447,
        9: 2452,
        10: 2457,
        11: 2462,
        12: 2467,
        13: 2472,
        14: 2484,
        32: 5160,
        34: 5170,
        36: 5180,
        38: 5190,
        40: 5200,
        42: 5210,
        44: 5220,
        46: 5230,
        48: 5240,
        50: 5250,
        52: 5260,
        54: 5270,
        56: 5280,
        58: 5290,
        60: 5300,
        62: 5310,
        64: 5320,
        68: 5340,
        96: 5480,
        100: 5500,
        102: 5510,
        104: 5520,
        106: 5530,
        108: 5540,
        110: 5550,
        112: 5560,
        114: 5570,
        116: 5580,
        118: 5590,
        120: 5600,
        122: 5610,
        124: 5620,
        126: 5630,
        128: 5640,
        132: 5660,
        134: 5670,
        136: 5680,
        138: 5690,
        140: 5700,
        142: 5710,
        144: 5720,
        149: 5745,
        151: 5755,
        153: 5765,
        155: 5775,
        157: 5785,
        159: 5795,
        161: 5805,
        165: 5825,
        169: 5845,
        173: 5865,
        183: 4915,
        184: 4920,
        185: 4925,
        187: 4935,
        188: 4940,
        189: 4945,
        192: 4960,
        196: 4980
      };
      return {}.hasOwnProperty.call(frequencies, channel) ? frequencies[channel] : -1;
    }
    function wifiNetworks(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = [];
          if (_linux) {
            let cmd = "nmcli --terse --fields active,ssid,bssid,mode,chan,freq,signal,security,wpa-flags,rsn-flags device wifi list 2>/dev/null";
            exec2(cmd, { maxBuffer: 1024 * 2e4 }, function(error, stdout) {
              const parts = stdout.toString().split("ACTIVE:");
              parts.shift();
              parts.forEach((part) => {
                part = "ACTIVE:" + part;
                const lines = part.split(os.EOL);
                const channel = util.getValue(lines, "CHAN");
                const frequency = util.getValue(lines, "FREQ").toLowerCase().replace("mhz", "").trim();
                const security = util.getValue(lines, "SECURITY").replace("(", "").replace(")", "");
                const wpaFlags = util.getValue(lines, "WPA-FLAGS").replace("(", "").replace(")", "");
                const rsnFlags = util.getValue(lines, "RSN-FLAGS").replace("(", "").replace(")", "");
                result.push({
                  ssid: util.getValue(lines, "SSID"),
                  bssid: util.getValue(lines, "BSSID"),
                  mode: util.getValue(lines, "MODE"),
                  channel: channel ? parseInt(channel, 10) : -1,
                  frequency: frequency ? parseInt(frequency, 10) : -1,
                  signalLevel: wifiDBFromQuality(util.getValue(lines, "SIGNAL")),
                  quality: parseFloat(util.getValue(lines, "SIGNAL")),
                  security: security && security !== "none" ? security.split(" ") : [],
                  wpaFlags: wpaFlags && wpaFlags !== "none" ? wpaFlags.split(" ") : [],
                  rsnFlags: rsnFlags && rsnFlags !== "none" ? rsnFlags.split(" ") : []
                });
              });
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } else if (_darwin) {
            let cmd = "/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -s";
            exec2(cmd, { maxBuffer: 1024 * 2e4 }, function(error, stdout) {
              const lines = stdout.toString().split(os.EOL);
              if (lines && lines.length > 1) {
                const parsedhead = util.parseHead(lines[0], 1);
                if (parsedhead.length >= 7) {
                  lines.shift();
                  lines.forEach((line) => {
                    if (line.trim()) {
                      const channelStr = line.substring(parsedhead[3].from, parsedhead[3].to).trim();
                      const channel = channelStr ? parseInt(channelStr, 10) : -1;
                      const signalLevel = line.substring(parsedhead[2].from, parsedhead[2].to).trim();
                      const securityAll = line.substring(parsedhead[6].from, 1e3).trim().split(" ");
                      let security = [];
                      let wpaFlags = [];
                      securityAll.forEach((securitySingle) => {
                        if (securitySingle.indexOf("(") > 0) {
                          const parts = securitySingle.split("(");
                          security.push(parts[0]);
                          wpaFlags = wpaFlags.concat(parts[1].replace(")", "").split(","));
                        }
                      });
                      wpaFlags = Array.from(new Set(wpaFlags));
                      result.push({
                        ssid: line.substring(parsedhead[0].from, parsedhead[0].to).trim(),
                        bssid: line.substring(parsedhead[1].from, parsedhead[1].to).trim(),
                        mode: "",
                        channel,
                        frequency: wifiFrequencyFromChannel(channel),
                        signalLevel: signalLevel ? parseInt(signalLevel, 10) : -1,
                        quality: wifiQualityFromDB(signalLevel),
                        security,
                        wpaFlags,
                        rsnFlags: []
                      });
                    }
                  });
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } else if (_windows) {
            let cmd = "chcp 65001 && netsh wlan show networks mode=Bssid";
            exec2(cmd, util.execOptsWin, function(error, stdout) {
              const parts = stdout.toString("utf8").split(os.EOL + os.EOL + "SSID ");
              parts.shift();
              parts.forEach((part) => {
                const lines = part.split(os.EOL);
                if (lines && lines.length >= 8 && lines[0].indexOf(":") >= 0) {
                  let bssid = lines[4].split(":");
                  bssid.shift();
                  bssid = bssid.join(":").trim();
                  const channel = lines[7].split(":").pop().trim();
                  const quality = lines[5].split(":").pop().trim();
                  result.push({
                    ssid: lines[0].split(":").pop().trim(),
                    bssid,
                    mode: "",
                    channel: channel ? parseInt(channel, 10) : -1,
                    frequency: wifiFrequencyFromChannel(channel),
                    signalLevel: wifiDBFromQuality(quality),
                    quality: quality ? parseInt(quality, 10) : -1,
                    security: [lines[2].split(":").pop().trim()],
                    wpaFlags: [lines[3].split(":").pop().trim()],
                    rsnFlags: []
                  });
                }
              });
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } else {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        });
      });
    }
    exports.wifiNetworks = wifiNetworks;
  }
});

// node_modules/@jedithepro/system-info/lib/processes.js
var require_processes = __commonJS({
  "node_modules/@jedithepro/system-info/lib/processes.js"(exports) {
    "use strict";
    var os = require("os");
    var fs2 = require("fs");
    var path3 = require("path");
    var exec2 = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var util = require_util2();
    var _platform = process.platform;
    var _linux = _platform === "linux";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    var _processes_cpu = {
      all: 0,
      list: {},
      ms: 0,
      result: {}
    };
    var _services_cpu = {
      all: 0,
      list: {},
      ms: 0,
      result: {}
    };
    var _process_cpu = {
      all: 0,
      list: {},
      ms: 0,
      result: {}
    };
    var _winStatusValues = {
      "0": "unknown",
      "1": "other",
      "2": "ready",
      "3": "running",
      "4": "blocked",
      "5": "suspended blocked",
      "6": "suspended ready",
      "7": "terminated",
      "8": "stopped",
      "9": "growing"
    };
    function parseTimeWin(time) {
      time = time || "";
      if (time) {
        return time.substr(0, 4) + "-" + time.substr(4, 2) + "-" + time.substr(6, 2) + " " + time.substr(8, 2) + ":" + time.substr(10, 2) + ":" + time.substr(12, 2);
      } else {
        return "";
      }
    }
    function parseTimeUnix(time) {
      let result = time;
      let parts = time.replace(/ +/g, " ").split(" ");
      if (parts.length === 5) {
        result = parts[4] + "-" + ("0" + ("JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC".indexOf(parts[1].toUpperCase()) / 3 + 1)).slice(-2) + "-" + ("0" + parts[2]).slice(-2) + " " + parts[3];
      }
      return result;
    }
    function services(srv, callback) {
      if (util.isFunction(srv) && !callback) {
        callback = srv;
        srv = "";
      }
      return new Promise((resolve) => {
        process.nextTick(() => {
          if (srv) {
            let srvString = util.sanitizeShellString(srv);
            srvString = srvString.trim().toLowerCase().replace(/, /g, "|").replace(/,+/g, "|");
            if (srvString === "") {
              srvString = "*";
            }
            let srvs = srvString.split("|");
            let result = [];
            let dataSrv = [];
            let allSrv = [];
            if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {
              if ((_linux || _freebsd || _openbsd || _netbsd) && srvString === "*") {
                srvString = "";
                let tmpsrv = execSync("service --status-all 2> /dev/null").toString().split("\n");
                for (const s of tmpsrv) {
                  const parts = s.split("]");
                  if (parts.length === 2) {
                    srvString += (srvString !== "" ? "|" : "") + parts[1].trim();
                    allSrv.push({ name: parts[1].trim(), running: parts[0].indexOf("+") > 0 });
                  }
                }
                srvs = srvString.split("|");
              }
              let comm = _darwin ? "ps -caxo pcpu,pmem,pid,command" : "ps -axo pcpu,pmem,pid,command";
              if (srvString !== "" && srvs.length > 0) {
                exec2(comm + ' | grep -v grep | grep -iE "' + srvString + '"', { maxBuffer: 1024 * 2e4 }, function(error, stdout) {
                  if (!error) {
                    let lines = stdout.toString().replace(/ +/g, " ").replace(/,+/g, ".").split("\n");
                    srvs.forEach(function(srv2) {
                      let ps;
                      if (_darwin) {
                        ps = lines.filter(function(e) {
                          return e.toLowerCase().indexOf(srv2) !== -1;
                        });
                      } else {
                        ps = lines.filter(function(e) {
                          return e.toLowerCase().indexOf(" " + srv2 + ":") !== -1 || e.toLowerCase().indexOf("/" + srv2) !== -1;
                        });
                      }
                      let singleSrv = allSrv.filter((item) => {
                        return item.name === srv2;
                      });
                      const pids = [];
                      for (const p of ps) {
                        const pid = p.trim().split(" ")[2];
                        if (pid) {
                          pids.push(parseInt(pid, 10));
                        }
                      }
                      result.push({
                        name: srv2,
                        running: allSrv.length && singleSrv.length ? singleSrv[0].running : ps.length > 0,
                        startmode: "",
                        pids,
                        pcpu: parseFloat(ps.reduce(function(pv, cv) {
                          return pv + parseFloat(cv.trim().split(" ")[0]);
                        }, 0).toFixed(2)),
                        pmem: parseFloat(ps.reduce(function(pv, cv) {
                          return pv + parseFloat(cv.trim().split(" ")[1]);
                        }, 0).toFixed(2))
                      });
                    });
                    if (_linux) {
                      let cmd = 'cat /proc/stat | grep "cpu "';
                      for (let i in result) {
                        for (let j in result[i].pids) {
                          cmd += ";cat /proc/" + result[i].pids[j] + "/stat";
                        }
                      }
                      exec2(cmd, { maxBuffer: 1024 * 2e4 }, function(error2, stdout2) {
                        let curr_processes = stdout2.toString().split("\n");
                        let all = parseProcStat(curr_processes.shift());
                        let list_new = {};
                        let resultProcess = {};
                        for (let i = 0; i < curr_processes.length; i++) {
                          resultProcess = calcProcStatLinux(curr_processes[i], all, _services_cpu);
                          if (resultProcess.pid) {
                            let listPos = -1;
                            for (let i2 in result) {
                              for (let j in result[i2].pids) {
                                if (parseInt(result[i2].pids[j]) === parseInt(resultProcess.pid)) {
                                  listPos = i2;
                                }
                              }
                            }
                            if (listPos >= 0) {
                              result[listPos].pcpu += resultProcess.pcpuu + resultProcess.pcpus;
                            }
                            list_new[resultProcess.pid] = {
                              pcpuu: resultProcess.pcpuu,
                              pcpus: resultProcess.pcpus,
                              utime: resultProcess.utime,
                              stime: resultProcess.stime,
                              cutime: resultProcess.cutime,
                              cstime: resultProcess.cstime
                            };
                          }
                        }
                        _services_cpu.all = all;
                        _services_cpu.list = Object.assign({}, list_new);
                        _services_cpu.ms = Date.now() - _services_cpu.ms;
                        _services_cpu.result = Object.assign({}, result);
                        if (callback) {
                          callback(result);
                        }
                        resolve(result);
                      });
                    } else {
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                    }
                  } else {
                    exec2('ps -o comm | grep -v grep | egrep "' + srvString + '"', { maxBuffer: 1024 * 2e4 }, function(error2, stdout2) {
                      if (!error2) {
                        let lines = stdout2.toString().replace(/ +/g, " ").replace(/,+/g, ".").split("\n");
                        srvs.forEach(function(srv2) {
                          let ps = lines.filter(function(e) {
                            return e.indexOf(srv2) !== -1;
                          });
                          result.push({
                            name: srv2,
                            running: ps.length > 0,
                            startmode: "",
                            pcpu: 0,
                            pmem: 0
                          });
                        });
                        if (callback) {
                          callback(result);
                        }
                        resolve(result);
                      } else {
                        srvs.forEach(function(srv2) {
                          result.push({
                            name: srv2,
                            running: false,
                            startmode: "",
                            pcpu: 0,
                            pmem: 0
                          });
                        });
                        if (callback) {
                          callback(result);
                        }
                        resolve(result);
                      }
                    });
                  }
                });
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            }
            if (_windows) {
              try {
                util.wmic("service get /value").then((stdout, error) => {
                  if (!error) {
                    let serviceSections = stdout.split(/\n\s*\n/);
                    for (let i = 0; i < serviceSections.length; i++) {
                      if (serviceSections[i].trim() !== "") {
                        let lines = serviceSections[i].trim().split("\r\n");
                        let srvName = util.getValue(lines, "Name", "=", true).toLowerCase();
                        let started = util.getValue(lines, "Started", "=", true);
                        let startMode = util.getValue(lines, "StartMode", "=", true);
                        let pid = util.getValue(lines, "ProcessId", "=", true);
                        if (srvString === "*" || srvs.indexOf(srvName) >= 0) {
                          result.push({
                            name: srvName,
                            running: started === "TRUE",
                            startmode: startMode,
                            pids: [pid],
                            pcpu: 0,
                            pmem: 0
                          });
                          dataSrv.push(srvName);
                        }
                      }
                    }
                    if (srvString !== "*") {
                      let srvsMissing = srvs.filter(function(e) {
                        return dataSrv.indexOf(e) === -1;
                      });
                      srvsMissing.forEach(function(srvName) {
                        result.push({
                          name: srvName,
                          running: false,
                          startmode: "",
                          pids: [],
                          pcpu: 0,
                          pmem: 0
                        });
                      });
                    }
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  } else {
                    srvs.forEach(function(srvName) {
                      result.push({
                        name: srvName,
                        running: false,
                        startmode: "",
                        pcpu: 0,
                        pmem: 0
                      });
                    });
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  }
                });
              } catch (e) {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            }
          } else {
            if (callback) {
              callback({});
            }
            resolve({});
          }
        });
      });
    }
    exports.services = services;
    function parseProcStat(line) {
      let parts = line.replace(/ +/g, " ").split(" ");
      let user = parts.length >= 2 ? parseInt(parts[1]) : 0;
      let nice = parts.length >= 3 ? parseInt(parts[2]) : 0;
      let system = parts.length >= 4 ? parseInt(parts[3]) : 0;
      let idle = parts.length >= 5 ? parseInt(parts[4]) : 0;
      let iowait = parts.length >= 6 ? parseInt(parts[5]) : 0;
      let irq = parts.length >= 7 ? parseInt(parts[6]) : 0;
      let softirq = parts.length >= 8 ? parseInt(parts[7]) : 0;
      let steal = parts.length >= 9 ? parseInt(parts[8]) : 0;
      let guest = parts.length >= 10 ? parseInt(parts[9]) : 0;
      let guest_nice = parts.length >= 11 ? parseInt(parts[10]) : 0;
      return user + nice + system + idle + iowait + irq + softirq + steal + guest + guest_nice;
    }
    function calcProcStatLinux(line, all, _cpu_old) {
      let statparts = line.replace(/ +/g, " ").split(")");
      if (statparts.length >= 2) {
        let parts = statparts[1].split(" ");
        if (parts.length >= 16) {
          let pid = parseInt(statparts[0].split(" ")[0]);
          let utime = parseInt(parts[12]);
          let stime = parseInt(parts[13]);
          let cutime = parseInt(parts[14]);
          let cstime = parseInt(parts[15]);
          let pcpuu = 0;
          let pcpus = 0;
          if (_cpu_old.all > 0 && _cpu_old.list[pid]) {
            pcpuu = (utime + cutime - _cpu_old.list[pid].utime - _cpu_old.list[pid].cutime) / (all - _cpu_old.all) * 100;
            pcpus = (stime + cstime - _cpu_old.list[pid].stime - _cpu_old.list[pid].cstime) / (all - _cpu_old.all) * 100;
          } else {
            pcpuu = (utime + cutime) / all * 100;
            pcpus = (stime + cstime) / all * 100;
          }
          return {
            pid,
            utime,
            stime,
            cutime,
            cstime,
            pcpuu,
            pcpus
          };
        } else {
          return {
            pid: 0,
            utime: 0,
            stime: 0,
            cutime: 0,
            cstime: 0,
            pcpuu: 0,
            pcpus: 0
          };
        }
      } else {
        return {
          pid: 0,
          utime: 0,
          stime: 0,
          cutime: 0,
          cstime: 0,
          pcpuu: 0,
          pcpus: 0
        };
      }
    }
    function calcProcStatWin(procStat, all, _cpu_old) {
      let pcpuu = 0;
      let pcpus = 0;
      if (_cpu_old.all > 0 && _cpu_old.list[procStat.pid]) {
        pcpuu = (procStat.utime - _cpu_old.list[procStat.pid].utime) / (all - _cpu_old.all) * 100;
        pcpus = (procStat.stime - _cpu_old.list[procStat.pid].stime) / (all - _cpu_old.all) * 100;
      } else {
        pcpuu = procStat.utime / all * 100;
        pcpus = procStat.stime / all * 100;
      }
      return {
        pid: procStat.pid,
        utime: procStat.utime,
        stime: procStat.stime,
        pcpuu,
        pcpus
      };
    }
    function processes(callback) {
      let parsedhead = [];
      function getName(command) {
        command = command || "";
        let result = command.split(" ")[0];
        if (result.substr(-1) === ":") {
          result = result.substr(0, result.length - 1);
        }
        if (result.substr(0, 1) !== "[") {
          let parts = result.split("/");
          if (isNaN(parseInt(parts[parts.length - 1]))) {
            result = parts[parts.length - 1];
          } else {
            result = parts[0];
          }
        }
        return result;
      }
      function parseLine(line) {
        let offset = 0;
        let offset2 = 0;
        function checkColumn(i) {
          offset = offset2;
          offset2 = line.substring(parsedhead[i].to + offset, 1e3).indexOf(" ");
        }
        checkColumn(0);
        const pid = parseInt(line.substring(parsedhead[0].from + offset, parsedhead[0].to + offset2));
        checkColumn(1);
        const ppid = parseInt(line.substring(parsedhead[1].from + offset, parsedhead[1].to + offset2));
        checkColumn(2);
        const pcpu = parseFloat(line.substring(parsedhead[2].from + offset, parsedhead[2].to + offset2).replace(/,/g, "."));
        checkColumn(3);
        const pmem = parseFloat(line.substring(parsedhead[3].from + offset, parsedhead[3].to + offset2).replace(/,/g, "."));
        checkColumn(4);
        const priority = parseInt(line.substring(parsedhead[4].from + offset, parsedhead[4].to + offset2));
        checkColumn(5);
        const vsz = parseInt(line.substring(parsedhead[5].from + offset, parsedhead[5].to + offset2));
        checkColumn(6);
        const rss = parseInt(line.substring(parsedhead[6].from + offset, parsedhead[6].to + offset2));
        checkColumn(7);
        const nice = parseInt(line.substring(parsedhead[7].from + offset, parsedhead[7].to + offset2)) || 0;
        checkColumn(8);
        const started = parseTimeUnix(line.substring(parsedhead[8].from + offset, parsedhead[8].to + offset2).trim());
        checkColumn(9);
        let state = line.substring(parsedhead[9].from + offset, parsedhead[9].to + offset2).trim();
        state = state[0] === "R" ? "running" : state[0] === "S" ? "sleeping" : state[0] === "T" ? "stopped" : state[0] === "W" ? "paging" : state[0] === "X" ? "dead" : state[0] === "Z" ? "zombie" : state[0] === "D" || state[0] === "U" ? "blocked" : "unknown";
        checkColumn(10);
        let tty = line.substring(parsedhead[10].from + offset, parsedhead[10].to + offset2).trim();
        if (tty === "?" || tty === "??")
          tty = "";
        checkColumn(11);
        const user = line.substring(parsedhead[11].from + offset, parsedhead[11].to + offset2).trim();
        checkColumn(12);
        const fullcommand = line.substring(parsedhead[12].from + offset, parsedhead[12].to + offset2).trim().replace(/\[/g, "").replace(/]/g, "");
        let cmdPath = "";
        let command = "";
        let params = "";
        let firstParamPos = fullcommand.indexOf(" -");
        let firstParamPathPos = fullcommand.indexOf(" /");
        firstParamPos = firstParamPos >= 0 ? firstParamPos : 1e4;
        firstParamPathPos = firstParamPathPos >= 0 ? firstParamPathPos : 1e4;
        const firstPos = Math.min(firstParamPos, firstParamPathPos);
        let tmpCommand = fullcommand.substr(0, firstPos);
        const tmpParams = fullcommand.substr(firstPos);
        const lastSlashPos = tmpCommand.lastIndexOf("/");
        if (lastSlashPos >= 0) {
          cmdPath = tmpCommand.substr(0, lastSlashPos);
          tmpCommand = tmpCommand.substr(lastSlashPos + 1);
        }
        if (firstPos === 1e4 && tmpCommand.indexOf(" ") > -1) {
          const parts = tmpCommand.split(" ");
          if (fs2.existsSync(path3.join(cmdPath, parts[0]))) {
            command = parts.shift();
            params = (parts.join(" ") + " " + tmpParams).trim();
          } else {
            command = tmpCommand.trim();
            params = tmpParams.trim();
          }
        } else {
          command = tmpCommand.trim();
          params = tmpParams.trim();
        }
        return {
          pid,
          parentPid: ppid,
          name: _linux ? getName(command) : command,
          pcpu,
          pcpuu: 0,
          pcpus: 0,
          pmem,
          priority,
          mem_vsz: vsz,
          mem_rss: rss,
          nice,
          started,
          state,
          tty,
          user,
          command,
          params,
          path: cmdPath
        };
      }
      function parseProcesses(lines) {
        let result = [];
        if (lines.length > 1) {
          let head = lines[0];
          parsedhead = util.parseHead(head, 8);
          lines.shift();
          lines.forEach(function(line) {
            if (line.trim() !== "") {
              result.push(parseLine(line));
            }
          });
        }
        return result;
      }
      function parseProcesses2(lines) {
        function formatDateTime(time) {
          const month = ("0" + (time.getMonth() + 1).toString()).substr(-2);
          const year = time.getFullYear().toString();
          const day = ("0" + time.getDay().toString()).substr(-2);
          const hours = time.getHours().toString();
          const mins = time.getMinutes().toString();
          const secs = ("0" + time.getSeconds().toString()).substr(-2);
          return year + "-" + month + "-" + day + " " + hours + ":" + mins + ":" + secs;
        }
        let result = [];
        lines.forEach(function(line) {
          if (line.trim() !== "") {
            line = line.trim().replace(/ +/g, " ").replace(/,+/g, ".");
            const parts = line.split(" ");
            const command = parts.slice(9).join(" ");
            const pmem = parseFloat((1 * parseInt(parts[3]) * 1024 / os.totalmem()).toFixed(1));
            const elapsed_parts = parts[5].split(":");
            const started = formatDateTime(new Date(Date.now() - (elapsed_parts.length > 1 ? (elapsed_parts[0] * 60 + elapsed_parts[1]) * 1e3 : elapsed_parts[0] * 1e3)));
            result.push({
              pid: parseInt(parts[0]),
              parentPid: parseInt(parts[1]),
              name: getName(command),
              pcpu: 0,
              pcpuu: 0,
              pcpus: 0,
              pmem,
              priority: 0,
              mem_vsz: parseInt(parts[2]),
              mem_rss: parseInt(parts[3]),
              nice: parseInt(parts[4]),
              started,
              state: parts[6] === "R" ? "running" : parts[6] === "S" ? "sleeping" : parts[6] === "T" ? "stopped" : parts[6] === "W" ? "paging" : parts[6] === "X" ? "dead" : parts[6] === "Z" ? "zombie" : parts[6] === "D" || parts[6] === "U" ? "blocked" : "unknown",
              tty: parts[7],
              user: parts[8],
              command
            });
          }
        });
        return result;
      }
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = {
            all: 0,
            running: 0,
            blocked: 0,
            sleeping: 0,
            unknown: 0,
            list: []
          };
          let cmd = "";
          if (_processes_cpu.ms && Date.now() - _processes_cpu.ms >= 500 || _processes_cpu.ms === 0) {
            if (_linux || _freebsd || _openbsd || _netbsd || _darwin || _sunos) {
              if (_linux)
                cmd = "export LC_ALL=C; ps -axo pid:11,ppid:11,pcpu:6,pmem:6,pri:5,vsz:11,rss:11,ni:5,lstart:30,state:5,tty:15,user:20,command; unset LC_ALL";
              if (_freebsd || _openbsd || _netbsd)
                cmd = "export LC_ALL=C; ps -axo pid,ppid,pcpu,pmem,pri,vsz,rss,ni,lstart,state,tty,user,command; unset LC_ALL";
              if (_darwin)
                cmd = "export LC_ALL=C; ps -axo pid,ppid,pcpu,pmem,pri,vsz,rss,nice,lstart,state,tty,user,command -r; unset LC_ALL";
              if (_sunos)
                cmd = "ps -Ao pid,ppid,pcpu,pmem,pri,vsz,rss,nice,stime,s,tty,user,comm";
              exec2(cmd, { maxBuffer: 1024 * 2e4 }, function(error, stdout) {
                if (!error) {
                  result.list = parseProcesses(stdout.toString().split("\n")).slice();
                  result.all = result.list.length;
                  result.running = result.list.filter(function(e) {
                    return e.state === "running";
                  }).length;
                  result.blocked = result.list.filter(function(e) {
                    return e.state === "blocked";
                  }).length;
                  result.sleeping = result.list.filter(function(e) {
                    return e.state === "sleeping";
                  }).length;
                  if (_linux) {
                    cmd = 'cat /proc/stat | grep "cpu "';
                    for (let i = 0; i < result.list.length; i++) {
                      cmd += ";cat /proc/" + result.list[i].pid + "/stat";
                    }
                    exec2(cmd, { maxBuffer: 1024 * 2e4 }, function(error2, stdout2) {
                      let curr_processes = stdout2.toString().split("\n");
                      let all = parseProcStat(curr_processes.shift());
                      let list_new = {};
                      let resultProcess = {};
                      for (let i = 0; i < curr_processes.length; i++) {
                        resultProcess = calcProcStatLinux(curr_processes[i], all, _processes_cpu);
                        if (resultProcess.pid) {
                          let listPos = result.list.map(function(e) {
                            return e.pid;
                          }).indexOf(resultProcess.pid);
                          if (listPos >= 0) {
                            result.list[listPos].pcpu = resultProcess.pcpuu + resultProcess.pcpus;
                            result.list[listPos].pcpuu = resultProcess.pcpuu;
                            result.list[listPos].pcpus = resultProcess.pcpus;
                          }
                          list_new[resultProcess.pid] = {
                            pcpuu: resultProcess.pcpuu,
                            pcpus: resultProcess.pcpus,
                            utime: resultProcess.utime,
                            stime: resultProcess.stime,
                            cutime: resultProcess.cutime,
                            cstime: resultProcess.cstime
                          };
                        }
                      }
                      _processes_cpu.all = all;
                      _processes_cpu.list = Object.assign({}, list_new);
                      _processes_cpu.ms = Date.now() - _processes_cpu.ms;
                      _processes_cpu.result = Object.assign({}, result);
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                    });
                  } else {
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  }
                } else {
                  cmd = "ps -o pid,ppid,vsz,rss,nice,etime,stat,tty,user,comm";
                  if (_sunos) {
                    cmd = "ps -o pid,ppid,vsz,rss,nice,etime,s,tty,user,comm";
                  }
                  exec2(cmd, { maxBuffer: 1024 * 2e4 }, function(error2, stdout2) {
                    if (!error2) {
                      let lines = stdout2.toString().split("\n");
                      lines.shift();
                      result.list = parseProcesses2(lines).slice();
                      result.all = result.list.length;
                      result.running = result.list.filter(function(e) {
                        return e.state === "running";
                      }).length;
                      result.blocked = result.list.filter(function(e) {
                        return e.state === "blocked";
                      }).length;
                      result.sleeping = result.list.filter(function(e) {
                        return e.state === "sleeping";
                      }).length;
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                    } else {
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                    }
                  });
                }
              });
            } else if (_windows) {
              try {
                util.wmic("process get /value").then((stdout, error) => {
                  if (!error) {
                    let processSections = stdout.split(/\n\s*\n/);
                    let procs = [];
                    let procStats = [];
                    let list_new = {};
                    let allcpuu = 0;
                    let allcpus = 0;
                    for (let i = 0; i < processSections.length; i++) {
                      if (processSections[i].trim() !== "") {
                        let lines = processSections[i].trim().split("\r\n");
                        let pid = parseInt(util.getValue(lines, "ProcessId", "=", true), 10);
                        let parentPid = parseInt(util.getValue(lines, "ParentProcessId", "=", true), 10);
                        let statusValue = util.getValue(lines, "ExecutionState", "=");
                        let name = util.getValue(lines, "Caption", "=", true);
                        let commandLine = util.getValue(lines, "CommandLine", "=", true);
                        let commandPath = util.getValue(lines, "ExecutablePath", "=", true);
                        let utime = parseInt(util.getValue(lines, "UserModeTime", "=", true), 10);
                        let stime = parseInt(util.getValue(lines, "KernelModeTime", "=", true), 10);
                        let mem = parseInt(util.getValue(lines, "WorkingSetSize", "=", true), 10);
                        allcpuu = allcpuu + utime;
                        allcpus = allcpus + stime;
                        result.all++;
                        if (!statusValue) {
                          result.unknown++;
                        }
                        if (statusValue === "3") {
                          result.running++;
                        }
                        if (statusValue === "4" || statusValue === "5") {
                          result.blocked++;
                        }
                        procStats.push({
                          pid,
                          utime,
                          stime,
                          pcpu: 0,
                          pcpuu: 0,
                          pcpus: 0
                        });
                        procs.push({
                          pid,
                          parentPid,
                          name,
                          pcpu: 0,
                          pcpuu: 0,
                          pcpus: 0,
                          pmem: mem / os.totalmem() * 100,
                          priority: parseInt(util.getValue(lines, "Priority", "=", true), 10),
                          mem_vsz: parseInt(util.getValue(lines, "PageFileUsage", "=", true), 10),
                          mem_rss: Math.floor(parseInt(util.getValue(lines, "WorkingSetSize", "=", true), 10) / 1024),
                          nice: 0,
                          started: parseTimeWin(util.getValue(lines, "CreationDate", "=", true)),
                          state: !statusValue ? _winStatusValues[0] : _winStatusValues[statusValue],
                          tty: "",
                          user: "",
                          command: commandLine || name,
                          path: commandPath,
                          params: ""
                        });
                      }
                    }
                    result.sleeping = result.all - result.running - result.blocked - result.unknown;
                    result.list = procs;
                    for (let i = 0; i < procStats.length; i++) {
                      let resultProcess = calcProcStatWin(procStats[i], allcpuu + allcpus, _processes_cpu);
                      let listPos = result.list.map(function(e) {
                        return e.pid;
                      }).indexOf(resultProcess.pid);
                      if (listPos >= 0) {
                        result.list[listPos].pcpu = resultProcess.pcpuu + resultProcess.pcpus;
                        result.list[listPos].pcpuu = resultProcess.pcpuu;
                        result.list[listPos].pcpus = resultProcess.pcpus;
                      }
                      list_new[resultProcess.pid] = {
                        pcpuu: resultProcess.pcpuu,
                        pcpus: resultProcess.pcpus,
                        utime: resultProcess.utime,
                        stime: resultProcess.stime
                      };
                    }
                    _processes_cpu.all = allcpuu + allcpus;
                    _processes_cpu.list = Object.assign({}, list_new);
                    _processes_cpu.ms = Date.now() - _processes_cpu.ms;
                    _processes_cpu.result = Object.assign({}, result);
                  }
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                });
              } catch (e) {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            } else {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          } else {
            if (callback) {
              callback(_processes_cpu.result);
            }
            resolve(_processes_cpu.result);
          }
        });
      });
    }
    exports.processes = processes;
    function processLoad(proc, callback) {
      if (util.isFunction(proc) && !callback) {
        callback = proc;
        proc = "";
      }
      return new Promise((resolve) => {
        process.nextTick(() => {
          const procSanitized = util.sanitizeShellString(proc);
          let result = {
            "proc": procSanitized,
            "pid": -1,
            "cpu": 0,
            "mem": 0
          };
          if (procSanitized) {
            if (_windows) {
              try {
                util.wmic("process get /value").then((stdout, error) => {
                  if (!error) {
                    let processSections = stdout.split(/\n\s*\n/);
                    let procStats = [];
                    let list_new = {};
                    let allcpuu = 0;
                    let allcpus = 0;
                    for (let i = 0; i < processSections.length; i++) {
                      if (processSections[i].trim() !== "") {
                        let lines = processSections[i].trim().split("\r\n");
                        let pid = parseInt(util.getValue(lines, "ProcessId", "=", true), 10);
                        let name = util.getValue(lines, "Caption", "=", true);
                        let utime = parseInt(util.getValue(lines, "UserModeTime", "=", true), 10);
                        let stime = parseInt(util.getValue(lines, "KernelModeTime", "=", true), 10);
                        let mem = parseInt(util.getValue(lines, "WorkingSetSize", "=", true), 10);
                        allcpuu = allcpuu + utime;
                        allcpus = allcpus + stime;
                        procStats.push({
                          pid,
                          utime,
                          stime,
                          pcpu: 0,
                          pcpuu: 0,
                          pcpus: 0
                        });
                        if (name.toLowerCase().indexOf(procSanitized.toLowerCase()) >= 0) {
                          if (result.pid === -1) {
                            result = {
                              proc: name,
                              pid,
                              pids: [pid],
                              cpu: 0,
                              mem: mem / os.totalmem() * 100
                            };
                          } else {
                            result.pids.push(pid);
                            result.mem += mem / os.totalmem() * 100;
                          }
                        }
                      }
                    }
                    for (let i = 0; i < procStats.length; i++) {
                      let resultProcess = calcProcStatWin(procStats[i], allcpuu + allcpus, _process_cpu);
                      if (result && result.pids && result.pids.length > 0) {
                        let listPos = result.pids.indexOf(resultProcess.pid);
                        if (listPos >= 0) {
                          result.cpu = resultProcess.pcpuu + resultProcess.pcpus;
                        }
                      }
                      list_new[resultProcess.pid] = {
                        pcpuu: resultProcess.pcpuu,
                        pcpus: resultProcess.pcpus,
                        utime: resultProcess.utime,
                        stime: resultProcess.stime
                      };
                    }
                    _process_cpu.all = allcpuu + allcpus;
                    _process_cpu.list = Object.assign({}, list_new);
                    _process_cpu.ms = Date.now() - _process_cpu.ms;
                    _process_cpu.result = Object.assign({}, result);
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  }
                });
              } catch (e) {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            }
            if (_darwin || _linux) {
              exec2("ps -axo pid,pcpu,pmem,comm | grep -i " + procSanitized + " | grep -v grep", { maxBuffer: 1024 * 2e4 }, function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  let pid = 0;
                  let pids = [];
                  let cpu = 0;
                  let mem = 0;
                  lines.forEach(function(line) {
                    let data = line.trim().replace(/ +/g, " ").split(" ");
                    if (data.length > 3) {
                      pid = !pid ? parseInt(data[0]) : 0;
                      pids.push(parseInt(data[0], 10));
                      cpu = cpu + parseFloat(data[1].replace(",", "."));
                      mem = mem + parseFloat(data[2].replace(",", "."));
                    }
                  });
                  result = {
                    "proc": procSanitized,
                    "pid": pid,
                    "pids": pids,
                    "cpu": parseFloat((cpu / lines.length).toFixed(2)),
                    "mem": parseFloat((mem / lines.length).toFixed(2))
                  };
                  if (_linux) {
                    let cmd = 'cat /proc/stat | grep "cpu "';
                    for (let i = 0; i < result.pids.length; i++) {
                      cmd += ";cat /proc/" + result.pids[i] + "/stat";
                    }
                    exec2(cmd, { maxBuffer: 1024 * 2e4 }, function(error2, stdout2) {
                      let curr_processes = stdout2.toString().split("\n");
                      let all = parseProcStat(curr_processes.shift());
                      let list_new = {};
                      let resultProcess = {};
                      result.cpu = 0;
                      for (let i = 0; i < curr_processes.length; i++) {
                        resultProcess = calcProcStatLinux(curr_processes[i], all, _process_cpu);
                        if (resultProcess.pid) {
                          result.cpu += resultProcess.pcpuu + resultProcess.pcpus;
                          list_new[resultProcess.pid] = {
                            pcpuu: resultProcess.pcpuu,
                            pcpus: resultProcess.pcpus,
                            utime: resultProcess.utime,
                            stime: resultProcess.stime,
                            cutime: resultProcess.cutime,
                            cstime: resultProcess.cstime
                          };
                        }
                      }
                      result.cpu = Math.round(result.cpu * 100) / 100;
                      _process_cpu.all = all;
                      _process_cpu.list = Object.assign({}, list_new);
                      _process_cpu.ms = Date.now() - _process_cpu.ms;
                      _process_cpu.result = Object.assign({}, result);
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                    });
                  } else {
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  }
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              });
            }
          }
        });
      });
    }
    exports.processLoad = processLoad;
  }
});

// node_modules/@jedithepro/system-info/lib/users.js
var require_users = __commonJS({
  "node_modules/@jedithepro/system-info/lib/users.js"(exports) {
    "use strict";
    var exec2 = require("child_process").exec;
    var util = require_util2();
    var _platform = process.platform;
    var _linux = _platform === "linux";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    var _winDateFormat = {
      dateFormat: "",
      dateSeperator: "",
      timeFormat: "",
      timeSeperator: "",
      amDesignator: "",
      pmDesignator: ""
    };
    function getWinCulture() {
      return new Promise((resolve) => {
        process.nextTick(() => {
          if (!_winDateFormat.dateFormat) {
            util.powerShell("(get-culture).DateTimeFormat").then((data) => {
              let lines = data.toString().split("\r\n");
              _winDateFormat.dateFormat = util.getValue(lines, "ShortDatePattern", ":");
              _winDateFormat.dateSeperator = util.getValue(lines, "DateSeparator", ":");
              _winDateFormat.timeFormat = util.getValue(lines, "ShortTimePattern", ":");
              _winDateFormat.timeSeperator = util.getValue(lines, "TimeSeparator", ":");
              _winDateFormat.amDesignator = util.getValue(lines, "AMDesignator", ":");
              _winDateFormat.pmDesignator = util.getValue(lines, "PMDesignator", ":");
              resolve(_winDateFormat);
            }).catch(() => {
              resolve(_winDateFormat);
            });
          } else {
            resolve(_winDateFormat);
          }
        });
      });
    }
    function parseUsersLinux(lines, phase) {
      let result = [];
      let result_who = [];
      let result_w = {};
      let w_first = true;
      let w_header = [];
      let w_pos = [];
      let who_line = {};
      let is_whopart = true;
      lines.forEach(function(line) {
        if (line === "---") {
          is_whopart = false;
        } else {
          let l = line.replace(/ +/g, " ").split(" ");
          if (is_whopart) {
            result_who.push({
              user: l[0],
              tty: l[1],
              date: l[2],
              time: l[3],
              ip: l && l.length > 4 ? l[4].replace(/\(/g, "").replace(/\)/g, "") : ""
            });
          } else {
            if (w_first) {
              w_header = l;
              w_header.forEach(function(item) {
                w_pos.push(line.indexOf(item));
              });
              w_first = false;
            } else {
              result_w.user = line.substring(w_pos[0], w_pos[1] - 1).trim();
              result_w.tty = line.substring(w_pos[1], w_pos[2] - 1).trim();
              result_w.ip = line.substring(w_pos[2], w_pos[3] - 1).replace(/\(/g, "").replace(/\)/g, "").trim();
              result_w.command = line.substring(w_pos[7], 1e3).trim();
              who_line = result_who.filter(function(obj) {
                return obj.user.substring(0, 8).trim() === result_w.user && obj.tty === result_w.tty;
              });
              if (who_line.length === 1) {
                result.push({
                  user: who_line[0].user,
                  tty: who_line[0].tty,
                  date: who_line[0].date,
                  time: who_line[0].time,
                  ip: who_line[0].ip,
                  command: result_w.command
                });
              }
            }
          }
        }
      });
      if (result.length === 0 && phase === 2) {
        return result_who;
      } else {
        return result;
      }
    }
    function parseUsersDarwin(lines) {
      let result = [];
      let result_who = [];
      let result_w = {};
      let who_line = {};
      let is_whopart = true;
      lines.forEach(function(line) {
        if (line === "---") {
          is_whopart = false;
        } else {
          let l = line.replace(/ +/g, " ").split(" ");
          if (is_whopart) {
            result_who.push({
              user: l[0],
              tty: l[1],
              date: "" + new Date().getFullYear() + "-" + ("0" + ("JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC".indexOf(l[2].toUpperCase()) / 3 + 1)).slice(-2) + "-" + ("0" + l[3]).slice(-2),
              time: l[4]
            });
          } else {
            result_w.user = l[0];
            result_w.tty = l[1];
            result_w.ip = l[2] !== "-" ? l[2] : "";
            result_w.command = l.slice(5, 1e3).join(" ");
            who_line = result_who.filter(function(obj) {
              return obj.user === result_w.user && (obj.tty.substring(3, 1e3) === result_w.tty || obj.tty === result_w.tty);
            });
            if (who_line.length === 1) {
              result.push({
                user: who_line[0].user,
                tty: who_line[0].tty,
                date: who_line[0].date,
                time: who_line[0].time,
                ip: result_w.ip,
                command: result_w.command
              });
            }
          }
        }
      });
      return result;
    }
    function parseUsersWin(lines, culture) {
      let result = [];
      const header = lines[0];
      const headerDelimiter = [];
      if (header) {
        const start = header[0] === " " ? 1 : 0;
        headerDelimiter.push(start - 1);
        let nextSpace = 0;
        for (let i = start + 1; i < header.length; i++) {
          if (header[i] === " " && (header[i - 1] === " " || header[i - 1] === ".")) {
            nextSpace = i;
          } else {
            if (nextSpace) {
              headerDelimiter.push(nextSpace);
              nextSpace = 0;
            }
          }
        }
        for (let i = 1; i < lines.length; i++) {
          if (lines[i].trim()) {
            const user = lines[i].substring(headerDelimiter[0] + 1, headerDelimiter[1]).trim() || "";
            const tty = lines[i].substring(headerDelimiter[1] + 1, headerDelimiter[2] - 2).trim() || "";
            const dateTime = util.parseDateTime(lines[i].substring(headerDelimiter[5] + 1, 2e3).trim(), culture) || "";
            result.push({
              user,
              tty,
              date: dateTime.date,
              time: dateTime.time,
              ip: "",
              command: ""
            });
          }
        }
      }
      return result;
    }
    function users(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = [];
          if (_linux) {
            exec2('who --ips; echo "---"; w | tail -n +2', function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                result = parseUsersLinux(lines, 1);
                if (result.length === 0) {
                  exec2('who; echo "---"; w | tail -n +2', function(error2, stdout2) {
                    if (!error2) {
                      lines = stdout2.toString().split("\n");
                      result = parseUsersLinux(lines, 2);
                    }
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  });
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            });
          }
          if (_freebsd || _openbsd || _netbsd) {
            exec2('who; echo "---"; w -ih', function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                result = parseUsersDarwin(lines);
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_sunos) {
            exec2('who; echo "---"; w -h', function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                result = parseUsersDarwin(lines);
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_darwin) {
            exec2('who; echo "---"; w -ih', function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                result = parseUsersDarwin(lines);
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_windows) {
            try {
              exec2("query user", util.execOptsWin, function(error, stdout) {
                if (stdout) {
                  let lines = stdout.toString().split("\r\n");
                  getWinCulture().then((culture) => {
                    result = parseUsersWin(lines, culture);
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  });
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.users = users;
  }
});

// node_modules/@jedithepro/system-info/lib/internet.js
var require_internet = __commonJS({
  "node_modules/@jedithepro/system-info/lib/internet.js"(exports) {
    "use strict";
    var exec2 = require("child_process").exec;
    var util = require_util2();
    var _platform = process.platform;
    var _linux = _platform === "linux";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    function inetChecksite(url, callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let urlSanitized = util.sanitizeShellString(url).toLowerCase();
          urlSanitized = urlSanitized.replace(/ /g, "");
          urlSanitized = urlSanitized.replace(/\$/g, "");
          urlSanitized = urlSanitized.replace(/\(/g, "");
          urlSanitized = urlSanitized.replace(/\)/g, "");
          urlSanitized = urlSanitized.replace(/{/g, "");
          urlSanitized = urlSanitized.replace(/}/g, "");
          let result = {
            url: urlSanitized,
            ok: false,
            status: 404,
            ms: -1
          };
          if (urlSanitized) {
            let t = Date.now();
            if (_linux || _freebsd || _openbsd || _netbsd || _darwin || _sunos) {
              let args = " -I --connect-timeout 5 -m 5 " + urlSanitized + ' 2>/dev/null | head -n 1 | cut -d " " -f2';
              let cmd = "curl";
              exec2(cmd + args, function(error, stdout) {
                let statusCode = parseInt(stdout.toString());
                result.status = statusCode || 404;
                result.ok = !error && (statusCode === 200 || statusCode === 301 || statusCode === 302 || statusCode === 304);
                result.ms = result.ok ? Date.now() - t : -1;
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            }
            if (_windows) {
              const http = urlSanitized.startsWith("https:") ? require("https") : require("http");
              try {
                http.get(urlSanitized, (res) => {
                  const statusCode = res.statusCode;
                  result.status = statusCode || 404;
                  result.ok = statusCode === 200 || statusCode === 301 || statusCode === 302 || statusCode === 304;
                  if (statusCode !== 200) {
                    res.resume();
                    result.ms = result.ok ? Date.now() - t : -1;
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  } else {
                    res.on("data", () => {
                    });
                    res.on("end", () => {
                      result.ms = result.ok ? Date.now() - t : -1;
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                    });
                  }
                }).on("error", () => {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                });
              } catch (err) {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            }
          } else {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        });
      });
    }
    exports.inetChecksite = inetChecksite;
    function inetLatency(host, callback) {
      if (util.isFunction(host) && !callback) {
        callback = host;
        host = "";
      }
      host = host || "8.8.8.8";
      const hostSanitized = util.sanitizeShellString(host);
      return new Promise((resolve) => {
        process.nextTick(() => {
          let cmd;
          if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {
            if (_linux) {
              cmd = "ping -c 2 -w 3 " + hostSanitized + " | grep rtt";
            }
            if (_freebsd || _openbsd || _netbsd) {
              cmd = "ping -c 2 -t 3 " + hostSanitized + " | grep round-trip";
            }
            if (_darwin) {
              cmd = "ping -c 2 -t 3 " + hostSanitized + " | grep avg";
            }
            exec2(cmd, function(error, stdout) {
              let result = -1;
              if (!error) {
                const line = stdout.toString().split("=");
                if (line.length > 1) {
                  const parts = line[1].split("/");
                  if (parts.length > 1) {
                    result = parseFloat(parts[1]);
                  }
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_sunos) {
            exec2("ping -s -a " + hostSanitized + " 56 2 | grep avg", { timeout: 3e3 }, function(error, stdout) {
              let result = -1;
              if (!error) {
                const line = stdout.toString().split("=");
                if (line.length > 1) {
                  const parts = line[1].split("/");
                  if (parts.length > 1) {
                    result = parseFloat(parts[1].replace(",", "."));
                  }
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_windows) {
            let result = -1;
            try {
              exec2("ping " + hostSanitized + " -n 1", util.execOptsWin, function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\r\n");
                  lines.shift();
                  lines.forEach(function(line) {
                    if ((line.toLowerCase().match(/ms/g) || []).length === 3) {
                      let l = line.replace(/ +/g, " ").split(" ");
                      if (l.length > 6) {
                        result = parseFloat(l[l.length - 1]);
                      }
                    }
                  });
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.inetLatency = inetLatency;
  }
});

// node_modules/@jedithepro/system-info/lib/dockerSocket.js
var require_dockerSocket = __commonJS({
  "node_modules/@jedithepro/system-info/lib/dockerSocket.js"(exports, module2) {
    "use strict";
    var net = require("net");
    var isWin = require("os").type() === "Windows_NT";
    var socketPath = isWin ? "//./pipe/docker_engine" : "/var/run/docker.sock";
    var DockerSocket = class {
      getInfo(callback) {
        try {
          let socket = net.createConnection({ path: socketPath });
          let alldata = "";
          let data;
          socket.on("connect", () => {
            socket.write("GET http:/info HTTP/1.0\r\n\r\n");
          });
          socket.on("data", (data2) => {
            alldata = alldata + data2.toString();
          });
          socket.on("error", () => {
            socket = false;
            callback({});
          });
          socket.on("end", () => {
            let startbody = alldata.indexOf("\r\n\r\n");
            alldata = alldata.substring(startbody + 4);
            socket = false;
            try {
              data = JSON.parse(alldata);
              callback(data);
            } catch (err) {
              callback({});
            }
          });
        } catch (err) {
          callback({});
        }
      }
      listContainers(all, callback) {
        try {
          let socket = net.createConnection({ path: socketPath });
          let alldata = "";
          let data;
          socket.on("connect", () => {
            socket.write("GET http:/containers/json" + (all ? "?all=1" : "") + " HTTP/1.0\r\n\r\n");
          });
          socket.on("data", (data2) => {
            alldata = alldata + data2.toString();
          });
          socket.on("error", () => {
            socket = false;
            callback({});
          });
          socket.on("end", () => {
            let startbody = alldata.indexOf("\r\n\r\n");
            alldata = alldata.substring(startbody + 4);
            socket = false;
            try {
              data = JSON.parse(alldata);
              callback(data);
            } catch (err) {
              callback({});
            }
          });
        } catch (err) {
          callback({});
        }
      }
      getStats(id, callback) {
        id = id || "";
        if (id) {
          try {
            let socket = net.createConnection({ path: socketPath });
            let alldata = "";
            let data;
            socket.on("connect", () => {
              socket.write("GET http:/containers/" + id + "/stats?stream=0 HTTP/1.0\r\n\r\n");
            });
            socket.on("data", (data2) => {
              alldata = alldata + data2.toString();
            });
            socket.on("error", () => {
              socket = false;
              callback({});
            });
            socket.on("end", () => {
              let startbody = alldata.indexOf("\r\n\r\n");
              alldata = alldata.substring(startbody + 4);
              socket = false;
              try {
                data = JSON.parse(alldata);
                callback(data);
              } catch (err) {
                callback({});
              }
            });
          } catch (err) {
            callback({});
          }
        } else {
          callback({});
        }
      }
      getInspect(id, callback) {
        id = id || "";
        if (id) {
          try {
            let socket = net.createConnection({ path: socketPath });
            let alldata = "";
            let data;
            socket.on("connect", () => {
              socket.write("GET http:/containers/" + id + "/json?stream=0 HTTP/1.0\r\n\r\n");
            });
            socket.on("data", (data2) => {
              alldata = alldata + data2.toString();
            });
            socket.on("error", () => {
              socket = false;
              callback({});
            });
            socket.on("end", () => {
              let startbody = alldata.indexOf("\r\n\r\n");
              alldata = alldata.substring(startbody + 4);
              socket = false;
              try {
                data = JSON.parse(alldata);
                callback(data);
              } catch (err) {
                callback({});
              }
            });
          } catch (err) {
            callback({});
          }
        } else {
          callback({});
        }
      }
      getProcesses(id, callback) {
        id = id || "";
        if (id) {
          try {
            let socket = net.createConnection({ path: socketPath });
            let alldata = "";
            let data;
            socket.on("connect", () => {
              socket.write("GET http:/containers/" + id + "/top?ps_args=-opid,ppid,pgid,vsz,time,etime,nice,ruser,user,rgroup,group,stat,rss,args HTTP/1.0\r\n\r\n");
            });
            socket.on("data", (data2) => {
              alldata = alldata + data2.toString();
            });
            socket.on("error", () => {
              socket = false;
              callback({});
            });
            socket.on("end", () => {
              let startbody = alldata.indexOf("\r\n\r\n");
              alldata = alldata.substring(startbody + 4);
              socket = false;
              try {
                data = JSON.parse(alldata);
                callback(data);
              } catch (err) {
                callback({});
              }
            });
          } catch (err) {
            callback({});
          }
        } else {
          callback({});
        }
      }
    };
    module2.exports = DockerSocket;
  }
});

// node_modules/@jedithepro/system-info/lib/docker.js
var require_docker = __commonJS({
  "node_modules/@jedithepro/system-info/lib/docker.js"(exports) {
    "use strict";
    var util = require_util2();
    var DockerSocket = require_dockerSocket();
    var _platform = process.platform;
    var _windows = _platform === "win32";
    var _docker_container_stats = {};
    var _docker_socket;
    var _docker_last_read = 0;
    function dockerInfo(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          if (!_docker_socket) {
            _docker_socket = new DockerSocket();
          }
          const result = {};
          _docker_socket.getInfo((data) => {
            result.id = data.ID;
            result.containers = data.Containers;
            result.containersRunning = data.ContainersRunning;
            result.containersPaused = data.ContainersPaused;
            result.containersStopped = data.ContainersStopped;
            result.images = data.Images;
            result.driver = data.Driver;
            result.memoryLimit = data.MemoryLimit;
            result.swapLimit = data.SwapLimit;
            result.kernelMemory = data.KernelMemory;
            result.cpuCfsPeriod = data.CpuCfsPeriod;
            result.cpuCfsQuota = data.CpuCfsQuota;
            result.cpuShares = data.CPUShares;
            result.cpuSet = data.CPUSet;
            result.ipv4Forwarding = data.IPv4Forwarding;
            result.bridgeNfIptables = data.BridgeNfIptables;
            result.bridgeNfIp6tables = data.BridgeNfIp6tables;
            result.debug = data.Debug;
            result.nfd = data.NFd;
            result.oomKillDisable = data.OomKillDisable;
            result.ngoroutines = data.NGoroutines;
            result.systemTime = data.SystemTime;
            result.loggingDriver = data.LoggingDriver;
            result.cgroupDriver = data.CgroupDriver;
            result.nEventsListener = data.NEventsListener;
            result.kernelVersion = data.KernelVersion;
            result.operatingSystem = data.OperatingSystem;
            result.osType = data.OSType;
            result.architecture = data.Architecture;
            result.ncpu = data.NCPU;
            result.memTotal = data.MemTotal;
            result.dockerRootDir = data.DockerRootDir;
            result.httpProxy = data.HttpProxy;
            result.httpsProxy = data.HttpsProxy;
            result.noProxy = data.NoProxy;
            result.name = data.Name;
            result.labels = data.Labels;
            result.experimentalBuild = data.ExperimentalBuild;
            result.serverVersion = data.ServerVersion;
            result.clusterStore = data.ClusterStore;
            result.clusterAdvertise = data.ClusterAdvertise;
            result.defaultRuntime = data.DefaultRuntime;
            result.liveRestoreEnabled = data.LiveRestoreEnabled;
            result.isolation = data.Isolation;
            result.initBinary = data.InitBinary;
            result.productLicense = data.ProductLicense;
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        });
      });
    }
    exports.dockerInfo = dockerInfo;
    function dockerContainers(all, callback) {
      function inContainers(containers, id) {
        let filtered = containers.filter((obj) => {
          return obj.Id && obj.Id === id;
        });
        return filtered.length > 0;
      }
      if (util.isFunction(all) && !callback) {
        callback = all;
        all = false;
      }
      all = all || false;
      let result = [];
      return new Promise((resolve) => {
        process.nextTick(() => {
          if (!_docker_socket) {
            _docker_socket = new DockerSocket();
          }
          const workload = [];
          _docker_socket.listContainers(all, (data) => {
            let docker_containers = {};
            try {
              docker_containers = data;
              if (docker_containers && Object.prototype.toString.call(docker_containers) === "[object Array]" && docker_containers.length > 0) {
                for (let key in _docker_container_stats) {
                  if ({}.hasOwnProperty.call(_docker_container_stats, key)) {
                    if (!inContainers(docker_containers, key))
                      delete _docker_container_stats[key];
                  }
                }
                docker_containers.forEach(function(element) {
                  if (element.Names && Object.prototype.toString.call(element.Names) === "[object Array]" && element.Names.length > 0) {
                    element.Name = element.Names[0].replace(/^\/|\/$/g, "");
                  }
                  workload.push(dockerContainerInspect(element.Id.trim(), element));
                });
                if (workload.length) {
                  Promise.all(
                    workload
                  ).then((data2) => {
                    if (callback) {
                      callback(data2);
                    }
                    resolve(data2);
                  });
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            } catch (err) {
              for (let key in _docker_container_stats) {
                if ({}.hasOwnProperty.call(_docker_container_stats, key)) {
                  if (!inContainers(docker_containers, key))
                    delete _docker_container_stats[key];
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          });
        });
      });
    }
    function dockerContainerInspect(containerID, payload) {
      containerID = containerID || "";
      return new Promise((resolve) => {
        process.nextTick(() => {
          if (containerID) {
            if (!_docker_socket) {
              _docker_socket = new DockerSocket();
            }
            _docker_socket.getInspect(containerID.trim(), (data) => {
              try {
                resolve({
                  id: payload.Id,
                  name: payload.Name,
                  image: payload.Image,
                  imageID: payload.ImageID,
                  command: payload.Command,
                  created: payload.Created,
                  started: data.State && data.State.StartedAt ? Math.round(new Date(data.State.StartedAt).getTime() / 1e3) : 0,
                  finished: data.State && data.State.FinishedAt && !data.State.FinishedAt.startsWith("0001-01-01") ? Math.round(new Date(data.State.FinishedAt).getTime() / 1e3) : 0,
                  createdAt: data.Created ? data.Created : "",
                  startedAt: data.State && data.State.StartedAt ? data.State.StartedAt : "",
                  finishedAt: data.State && data.State.FinishedAt && !data.State.FinishedAt.startsWith("0001-01-01") ? data.State.FinishedAt : "",
                  state: payload.State,
                  restartCount: data.RestartCount || 0,
                  platform: data.Platform || "",
                  driver: data.Driver || "",
                  ports: payload.Ports,
                  mounts: payload.Mounts
                });
              } catch (err) {
                resolve();
              }
            });
          } else {
            resolve();
          }
        });
      });
    }
    exports.dockerContainers = dockerContainers;
    function docker_calcCPUPercent(cpu_stats, precpu_stats) {
      if (!_windows) {
        let cpuPercent = 0;
        let cpuDelta = cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage;
        let systemDelta = cpu_stats.system_cpu_usage - precpu_stats.system_cpu_usage;
        if (systemDelta > 0 && cpuDelta > 0) {
          cpuPercent = cpuDelta / systemDelta * cpu_stats.cpu_usage.percpu_usage.length * 100;
        }
        return cpuPercent;
      } else {
        let nanoSecNow = util.nanoSeconds();
        let cpuPercent = 0;
        if (_docker_last_read > 0) {
          let possIntervals = nanoSecNow - _docker_last_read;
          let intervalsUsed = cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage;
          if (possIntervals > 0) {
            cpuPercent = 100 * intervalsUsed / possIntervals;
          }
        }
        _docker_last_read = nanoSecNow;
        return cpuPercent;
      }
    }
    function docker_calcNetworkIO(networks) {
      let rx;
      let tx;
      for (let key in networks) {
        if (!{}.hasOwnProperty.call(networks, key))
          continue;
        let obj = networks[key];
        rx = +obj.rx_bytes;
        tx = +obj.tx_bytes;
      }
      return {
        rx,
        tx
      };
    }
    function docker_calcBlockIO(blkio_stats) {
      let result = {
        r: 0,
        w: 0
      };
      if (blkio_stats && blkio_stats.io_service_bytes_recursive && Object.prototype.toString.call(blkio_stats.io_service_bytes_recursive) === "[object Array]" && blkio_stats.io_service_bytes_recursive.length > 0) {
        blkio_stats.io_service_bytes_recursive.forEach(function(element) {
          if (element.op && element.op.toLowerCase() === "read" && element.value) {
            result.r += element.value;
          }
          if (element.op && element.op.toLowerCase() === "write" && element.value) {
            result.w += element.value;
          }
        });
      }
      return result;
    }
    function dockerContainerStats(containerIDs, callback) {
      let containerArray = [];
      if (util.isFunction(containerIDs) && !callback) {
        callback = containerIDs;
        containerArray = ["*"];
      } else {
        containerIDs = containerIDs || "*";
        containerIDs = containerIDs.trim().toLowerCase().replace(/,+/g, "|");
        containerArray = containerIDs.split("|");
      }
      return new Promise((resolve) => {
        process.nextTick(() => {
          const result = [];
          const workload = [];
          if (containerArray.length && containerArray[0].trim() === "*") {
            containerArray = [];
            dockerContainers().then((allContainers) => {
              for (let container2 of allContainers) {
                containerArray.push(container2.id);
              }
              dockerContainerStats(containerArray.join(",")).then((result2) => {
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              });
            });
          } else {
            for (let containerID of containerArray) {
              workload.push(dockerContainerStatsSingle(containerID.trim()));
            }
            if (workload.length) {
              Promise.all(
                workload
              ).then((data) => {
                if (callback) {
                  callback(data);
                }
                resolve(data);
              });
            } else {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    function dockerContainerStatsSingle(containerID) {
      containerID = containerID || "";
      let result = {
        id: containerID,
        mem_usage: 0,
        mem_limit: 0,
        mem_percent: 0,
        cpu_percent: 0,
        pids: 0,
        netIO: {
          rx: 0,
          wx: 0
        },
        blockIO: {
          r: 0,
          w: 0
        }
      };
      return new Promise((resolve) => {
        process.nextTick(() => {
          if (containerID) {
            if (!_docker_socket) {
              _docker_socket = new DockerSocket();
            }
            _docker_socket.getInspect(containerID, (dataInspect) => {
              try {
                _docker_socket.getStats(containerID, (data) => {
                  try {
                    let stats = data;
                    if (!stats.message) {
                      result.mem_usage = stats.memory_stats && stats.memory_stats.usage ? stats.memory_stats.usage : 0;
                      result.mem_limit = stats.memory_stats && stats.memory_stats.limit ? stats.memory_stats.limit : 0;
                      result.mem_percent = stats.memory_stats && stats.memory_stats.usage && stats.memory_stats.limit ? stats.memory_stats.usage / stats.memory_stats.limit * 100 : 0;
                      result.cpu_percent = stats.cpu_stats && stats.precpu_stats ? docker_calcCPUPercent(stats.cpu_stats, stats.precpu_stats) : 0;
                      result.pids = stats.pids_stats && stats.pids_stats.current ? stats.pids_stats.current : 0;
                      result.restartCount = dataInspect.RestartCount ? dataInspect.RestartCount : 0;
                      if (stats.networks)
                        result.netIO = docker_calcNetworkIO(stats.networks);
                      if (stats.blkio_stats)
                        result.blockIO = docker_calcBlockIO(stats.blkio_stats);
                      result.cpu_stats = stats.cpu_stats ? stats.cpu_stats : {};
                      result.precpu_stats = stats.precpu_stats ? stats.precpu_stats : {};
                      result.memory_stats = stats.memory_stats ? stats.memory_stats : {};
                      result.networks = stats.networks ? stats.networks : {};
                    }
                  } catch (err) {
                    util.noop();
                  }
                  resolve(result);
                });
              } catch (err) {
                util.noop();
              }
            });
          } else {
            resolve(result);
          }
        });
      });
    }
    exports.dockerContainerStats = dockerContainerStats;
    function dockerContainerProcesses(containerID, callback) {
      containerID = containerID || "";
      let result = [];
      return new Promise((resolve) => {
        process.nextTick(() => {
          if (containerID) {
            if (!_docker_socket) {
              _docker_socket = new DockerSocket();
            }
            _docker_socket.getProcesses(containerID, (data) => {
              try {
                if (data && data.Titles && data.Processes) {
                  let titles = data.Titles.map(function(value) {
                    return value.toUpperCase();
                  });
                  let pos_pid = titles.indexOf("PID");
                  let pos_ppid = titles.indexOf("PPID");
                  let pos_pgid = titles.indexOf("PGID");
                  let pos_vsz = titles.indexOf("VSZ");
                  let pos_time = titles.indexOf("TIME");
                  let pos_elapsed = titles.indexOf("ELAPSED");
                  let pos_ni = titles.indexOf("NI");
                  let pos_ruser = titles.indexOf("RUSER");
                  let pos_user = titles.indexOf("USER");
                  let pos_rgroup = titles.indexOf("RGROUP");
                  let pos_group = titles.indexOf("GROUP");
                  let pos_stat = titles.indexOf("STAT");
                  let pos_rss = titles.indexOf("RSS");
                  let pos_command = titles.indexOf("COMMAND");
                  data.Processes.forEach((process2) => {
                    result.push({
                      pid_host: pos_pid >= 0 ? process2[pos_pid] : "",
                      ppid: pos_ppid >= 0 ? process2[pos_ppid] : "",
                      pgid: pos_pgid >= 0 ? process2[pos_pgid] : "",
                      user: pos_user >= 0 ? process2[pos_user] : "",
                      ruser: pos_ruser >= 0 ? process2[pos_ruser] : "",
                      group: pos_group >= 0 ? process2[pos_group] : "",
                      rgroup: pos_rgroup >= 0 ? process2[pos_rgroup] : "",
                      stat: pos_stat >= 0 ? process2[pos_stat] : "",
                      time: pos_time >= 0 ? process2[pos_time] : "",
                      elapsed: pos_elapsed >= 0 ? process2[pos_elapsed] : "",
                      nice: pos_ni >= 0 ? process2[pos_ni] : "",
                      rss: pos_rss >= 0 ? process2[pos_rss] : "",
                      vsz: pos_vsz >= 0 ? process2[pos_vsz] : "",
                      command: pos_command >= 0 ? process2[pos_command] : ""
                    });
                  });
                }
              } catch (err) {
                util.noop();
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } else {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        });
      });
    }
    exports.dockerContainerProcesses = dockerContainerProcesses;
    function dockerAll(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          dockerContainers(true).then((result) => {
            if (result && Object.prototype.toString.call(result) === "[object Array]" && result.length > 0) {
              let l = result.length;
              result.forEach(function(element) {
                dockerContainerStats(element.id).then((res) => {
                  element.mem_usage = res[0].mem_usage;
                  element.mem_limit = res[0].mem_limit;
                  element.mem_percent = res[0].mem_percent;
                  element.cpu_percent = res[0].cpu_percent;
                  element.pids = res[0].pids;
                  element.netIO = res[0].netIO;
                  element.blockIO = res[0].blockIO;
                  element.cpu_stats = res[0].cpu_stats;
                  element.precpu_stats = res[0].precpu_stats;
                  element.memory_stats = res[0].memory_stats;
                  element.networks = res[0].networks;
                  dockerContainerProcesses(element.id).then((processes) => {
                    element.processes = processes;
                    l -= 1;
                    if (l === 0) {
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                    }
                  });
                });
              });
            } else {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          });
        });
      });
    }
    exports.dockerAll = dockerAll;
  }
});

// node_modules/@jedithepro/system-info/lib/virtualbox.js
var require_virtualbox = __commonJS({
  "node_modules/@jedithepro/system-info/lib/virtualbox.js"(exports) {
    "use strict";
    var os = require("os");
    var exec2 = require("child_process").exec;
    var util = require_util2();
    function vboxInfo(callback) {
      let result = [];
      return new Promise((resolve) => {
        process.nextTick(() => {
          try {
            exec2(util.getVboxmanage() + " list vms --long", function(error, stdout) {
              let parts = (os.EOL + stdout.toString()).split(os.EOL + "Name:");
              parts.shift();
              parts.forEach((part) => {
                const lines = ("Name:" + part).split(os.EOL);
                const state = util.getValue(lines, "State");
                const running = state.startsWith("running");
                const runningSinceString = running ? state.replace("running (since ", "").replace(")", "").trim() : "";
                let runningSince = 0;
                try {
                  if (running) {
                    const sinceDateObj = new Date(runningSinceString);
                    const offset = sinceDateObj.getTimezoneOffset();
                    runningSince = Math.round((Date.now() - Date.parse(sinceDateObj)) / 1e3) + offset * 60;
                  }
                } catch (e) {
                  util.noop();
                }
                const stoppedSinceString = !running ? state.replace("powered off (since", "").replace(")", "").trim() : "";
                let stoppedSince = 0;
                try {
                  if (!running) {
                    const sinceDateObj = new Date(stoppedSinceString);
                    const offset = sinceDateObj.getTimezoneOffset();
                    stoppedSince = Math.round((Date.now() - Date.parse(sinceDateObj)) / 1e3) + offset * 60;
                  }
                } catch (e) {
                  util.noop();
                }
                result.push({
                  id: util.getValue(lines, "UUID"),
                  name: util.getValue(lines, "Name"),
                  running,
                  started: runningSinceString,
                  runningSince,
                  stopped: stoppedSinceString,
                  stoppedSince,
                  guestOS: util.getValue(lines, "Guest OS"),
                  hardwareUUID: util.getValue(lines, "Hardware UUID"),
                  memory: parseInt(util.getValue(lines, "Memory size", "     "), 10),
                  vram: parseInt(util.getValue(lines, "VRAM size"), 10),
                  cpus: parseInt(util.getValue(lines, "Number of CPUs"), 10),
                  cpuExepCap: util.getValue(lines, "CPU exec cap"),
                  cpuProfile: util.getValue(lines, "CPUProfile"),
                  chipset: util.getValue(lines, "Chipset"),
                  firmware: util.getValue(lines, "Firmware"),
                  pageFusion: util.getValue(lines, "Page Fusion") === "enabled",
                  configFile: util.getValue(lines, "Config file"),
                  snapshotFolder: util.getValue(lines, "Snapshot folder"),
                  logFolder: util.getValue(lines, "Log folder"),
                  HPET: util.getValue(lines, "HPET") === "enabled",
                  PAE: util.getValue(lines, "PAE") === "enabled",
                  longMode: util.getValue(lines, "Long Mode") === "enabled",
                  tripleFaultReset: util.getValue(lines, "Triple Fault Reset") === "enabled",
                  APIC: util.getValue(lines, "APIC") === "enabled",
                  X2APIC: util.getValue(lines, "X2APIC") === "enabled",
                  ACPI: util.getValue(lines, "ACPI") === "enabled",
                  IOAPIC: util.getValue(lines, "IOAPIC") === "enabled",
                  biosAPICmode: util.getValue(lines, "BIOS APIC mode"),
                  bootMenuMode: util.getValue(lines, "Boot menu mode"),
                  bootDevice1: util.getValue(lines, "Boot Device 1"),
                  bootDevice2: util.getValue(lines, "Boot Device 2"),
                  bootDevice3: util.getValue(lines, "Boot Device 3"),
                  bootDevice4: util.getValue(lines, "Boot Device 4"),
                  timeOffset: util.getValue(lines, "Time offset"),
                  RTC: util.getValue(lines, "RTC")
                });
              });
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } catch (e) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        });
      });
    }
    exports.vboxInfo = vboxInfo;
  }
});

// node_modules/@jedithepro/system-info/lib/index.js
var require_lib = __commonJS({
  "node_modules/@jedithepro/system-info/lib/index.js"(exports) {
    "use strict";
    var lib_version = require_package2().version;
    var util = require_util2();
    var system = require_system();
    var osInfo = require_osinfo();
    var cpu = require_cpu();
    var memory = require_memory();
    var battery = require_battery();
    var graphics = require_graphics();
    var filesystem = require_filesystem();
    var network = require_network();
    var wifi = require_wifi();
    var processes = require_processes();
    var users = require_users();
    var internet = require_internet();
    var docker = require_docker();
    var vbox = require_virtualbox();
    var _platform = process.platform;
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    if (_windows) {
      util.getCodepage();
    }
    function version() {
      return lib_version;
    }
    function getStaticData(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let data = {};
          data.version = version();
          Promise.all([
            system.system(),
            system.bios(),
            system.baseboard(),
            system.chassis(),
            osInfo.osInfo(),
            osInfo.uuid(),
            osInfo.versions(),
            cpu.cpu(),
            cpu.cpuFlags(),
            graphics.graphics(),
            network.networkInterfaces(),
            memory.memLayout(),
            filesystem.diskLayout()
          ]).then((res) => {
            data.system = res[0];
            data.bios = res[1];
            data.baseboard = res[2];
            data.chassis = res[3];
            data.os = res[4];
            data.uuid = res[5];
            data.versions = res[6];
            data.cpu = res[7];
            data.cpu.flags = res[8];
            data.graphics = res[9];
            data.net = res[10];
            data.memLayout = res[11];
            data.diskLayout = res[12];
            if (callback) {
              callback(data);
            }
            resolve(data);
          });
        });
      });
    }
    function getDynamicData(srv, iface, callback) {
      if (util.isFunction(iface)) {
        callback = iface;
        iface = "";
      }
      if (util.isFunction(srv)) {
        callback = srv;
        srv = "";
      }
      return new Promise((resolve) => {
        process.nextTick(() => {
          iface = iface || network.getDefaultNetworkInterface();
          srv = srv || "";
          let functionProcessed = function() {
            let totalFunctions = 15;
            if (_windows)
              totalFunctions = 11;
            if (_freebsd || _openbsd || _netbsd)
              totalFunctions = 11;
            if (_sunos)
              totalFunctions = 6;
            return function() {
              if (--totalFunctions === 0) {
                if (callback) {
                  callback(data);
                }
                resolve(data);
              }
            };
          }();
          let data = {};
          data.time = osInfo.time();
          data.node = process.versions.node;
          data.v8 = process.versions.v8;
          cpu.cpuCurrentspeed().then((res) => {
            data.cpuCurrentspeed = res;
            functionProcessed();
          });
          users.users().then((res) => {
            data.users = res;
            functionProcessed();
          });
          if (!_windows) {
            processes.processes().then((res) => {
              data.processes = res;
              functionProcessed();
            });
          }
          cpu.currentLoad().then((res) => {
            data.currentLoad = res;
            functionProcessed();
          });
          if (!_sunos) {
            cpu.cpuTemperature().then((res) => {
              data.temp = res;
              functionProcessed();
            });
          }
          if (!_openbsd && !_freebsd && !_netbsd && !_sunos) {
            network.networkStats(iface).then((res) => {
              data.networkStats = res;
              functionProcessed();
            });
          }
          if (!_sunos) {
            network.networkConnections().then((res) => {
              data.networkConnections = res;
              functionProcessed();
            });
          }
          memory.mem().then((res) => {
            data.mem = res;
            functionProcessed();
          });
          if (!_sunos) {
            battery().then((res) => {
              data.battery = res;
              functionProcessed();
            });
          }
          if (!_windows && !_sunos) {
            processes.services(srv).then((res) => {
              data.services = res;
              functionProcessed();
            });
          }
          if (!_sunos) {
            filesystem.fsSize().then((res) => {
              data.fsSize = res;
              functionProcessed();
            });
          }
          if (!_windows && !_openbsd && !_freebsd && !_netbsd && !_sunos) {
            filesystem.fsStats().then((res) => {
              data.fsStats = res;
              functionProcessed();
            });
          }
          if (!_windows && !_openbsd && !_freebsd && !_netbsd && !_sunos) {
            filesystem.disksIO().then((res) => {
              data.disksIO = res;
              functionProcessed();
            });
          }
          if (!_openbsd && !_freebsd && !_netbsd && !_sunos) {
            wifi.wifiNetworks().then((res) => {
              data.wifiNetworks = res;
              functionProcessed();
            });
          }
          internet.inetLatency().then((res) => {
            data.inetLatency = res;
            functionProcessed();
          });
        });
      });
    }
    function getAllData(srv, iface, callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let data = {};
          if (iface && util.isFunction(iface) && !callback) {
            callback = iface;
            iface = "";
          }
          if (srv && util.isFunction(srv) && !iface && !callback) {
            callback = srv;
            srv = "";
            iface = "";
          }
          getStaticData().then((res) => {
            data = res;
            getDynamicData(srv, iface).then((res2) => {
              for (let key in res2) {
                if ({}.hasOwnProperty.call(res2, key)) {
                  data[key] = res2[key];
                }
              }
              if (callback) {
                callback(data);
              }
              resolve(data);
            });
          });
        });
      });
    }
    function get(valueObject, callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          const allPromises = Object.keys(valueObject).filter((func) => ({}).hasOwnProperty.call(exports, func)).map((func) => {
            const params = valueObject[func].substring(valueObject[func].lastIndexOf("(") + 1, valueObject[func].lastIndexOf(")"));
            const funcWithoutParams = func.split("(")[0];
            if (params) {
              return exports[funcWithoutParams](params);
            } else {
              return exports[funcWithoutParams]("");
            }
          });
          Promise.all(allPromises).then((data) => {
            const result = {};
            let i = 0;
            for (let key in valueObject) {
              if ({}.hasOwnProperty.call(valueObject, key) && {}.hasOwnProperty.call(exports, key) && data.length > i) {
                if (valueObject[key] === "*" || valueObject[key] === "all") {
                  result[key] = data[i];
                } else {
                  const keys = valueObject[key].replace(/,/g, " ").replace(/ +/g, " ").split(" ");
                  if (data[i]) {
                    if (Array.isArray(data[i])) {
                      const partialArray = [];
                      data[i].forEach((element) => {
                        const partialRes = {};
                        keys.forEach((k) => {
                          if ({}.hasOwnProperty.call(element, k)) {
                            partialRes[k] = element[k];
                          }
                        });
                        partialArray.push(partialRes);
                      });
                      result[key] = partialArray;
                    } else {
                      const partialRes = {};
                      keys.forEach((k) => {
                        if ({}.hasOwnProperty.call(data[i], k)) {
                          partialRes[k] = data[i][k];
                        }
                      });
                      result[key] = partialRes;
                    }
                  } else {
                    result[key] = {};
                  }
                }
                i++;
              }
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        });
      });
    }
    function observe(valueObject, interval, callback) {
      let _data = null;
      const result = setInterval(() => {
        get(valueObject).then((data) => {
          if (JSON.stringify(_data) !== JSON.stringify(data)) {
            _data = Object.assign({}, data);
            callback(data);
          }
        });
      }, interval);
      return result;
    }
    exports.version = version;
    exports.system = system.system;
    exports.bios = system.bios;
    exports.baseboard = system.baseboard;
    exports.chassis = system.chassis;
    exports.time = osInfo.time;
    exports.osInfo = osInfo.osInfo;
    exports.versions = osInfo.versions;
    exports.shell = osInfo.shell;
    exports.uuid = osInfo.uuid;
    exports.cpu = cpu.cpu;
    exports.cpuFlags = cpu.cpuFlags;
    exports.cpuCache = cpu.cpuCache;
    exports.cpuCurrentspeed = cpu.cpuCurrentspeed;
    exports.cpuTemperature = cpu.cpuTemperature;
    exports.currentLoad = cpu.currentLoad;
    exports.fullLoad = cpu.fullLoad;
    exports.mem = memory.mem;
    exports.memLayout = memory.memLayout;
    exports.battery = battery;
    exports.graphics = graphics.graphics;
    exports.fsSize = filesystem.fsSize;
    exports.fsOpenFiles = filesystem.fsOpenFiles;
    exports.blockDevices = filesystem.blockDevices;
    exports.fsStats = filesystem.fsStats;
    exports.disksIO = filesystem.disksIO;
    exports.diskLayout = filesystem.diskLayout;
    exports.networkInterfaceDefault = network.networkInterfaceDefault;
    exports.networkGatewayDefault = network.networkGatewayDefault;
    exports.networkInterfaces = network.networkInterfaces;
    exports.networkStats = network.networkStats;
    exports.networkConnections = network.networkConnections;
    exports.wifiNetworks = wifi.wifiNetworks;
    exports.services = processes.services;
    exports.processes = processes.processes;
    exports.processLoad = processes.processLoad;
    exports.users = users.users;
    exports.inetChecksite = internet.inetChecksite;
    exports.inetLatency = internet.inetLatency;
    exports.dockerInfo = docker.dockerInfo;
    exports.dockerContainers = docker.dockerContainers;
    exports.dockerContainerStats = docker.dockerContainerStats;
    exports.dockerContainerProcesses = docker.dockerContainerProcesses;
    exports.dockerAll = docker.dockerAll;
    exports.vboxInfo = vbox.vboxInfo;
    exports.getStaticData = getStaticData;
    exports.getDynamicData = getDynamicData;
    exports.getAllData = getAllData;
    exports.get = get;
    exports.observe = observe;
  }
});

// node_modules/webidl-conversions/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/webidl-conversions/lib/index.js"(exports, module2) {
    "use strict";
    var conversions = {};
    module2.exports = conversions;
    function sign(x) {
      return x < 0 ? -1 : 1;
    }
    function evenRound(x) {
      if (x % 1 === 0.5 && (x & 1) === 0) {
        return Math.floor(x);
      } else {
        return Math.round(x);
      }
    }
    function createNumberConversion(bitLength, typeOpts) {
      if (!typeOpts.unsigned) {
        --bitLength;
      }
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
      const upperBound = Math.pow(2, bitLength) - 1;
      const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
      const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
      return function(V, opts) {
        if (!opts)
          opts = {};
        let x = +V;
        if (opts.enforceRange) {
          if (!Number.isFinite(x)) {
            throw new TypeError("Argument is not a finite number");
          }
          x = sign(x) * Math.floor(Math.abs(x));
          if (x < lowerBound || x > upperBound) {
            throw new TypeError("Argument is not in byte range");
          }
          return x;
        }
        if (!isNaN(x) && opts.clamp) {
          x = evenRound(x);
          if (x < lowerBound)
            x = lowerBound;
          if (x > upperBound)
            x = upperBound;
          return x;
        }
        if (!Number.isFinite(x) || x === 0) {
          return 0;
        }
        x = sign(x) * Math.floor(Math.abs(x));
        x = x % moduloVal;
        if (!typeOpts.unsigned && x >= moduloBound) {
          return x - moduloVal;
        } else if (typeOpts.unsigned) {
          if (x < 0) {
            x += moduloVal;
          } else if (x === -0) {
            return 0;
          }
        }
        return x;
      };
    }
    conversions["void"] = function() {
      return void 0;
    };
    conversions["boolean"] = function(val) {
      return !!val;
    };
    conversions["byte"] = createNumberConversion(8, { unsigned: false });
    conversions["octet"] = createNumberConversion(8, { unsigned: true });
    conversions["short"] = createNumberConversion(16, { unsigned: false });
    conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
    conversions["long"] = createNumberConversion(32, { unsigned: false });
    conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
    conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
    conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
    conversions["double"] = function(V) {
      const x = +V;
      if (!Number.isFinite(x)) {
        throw new TypeError("Argument is not a finite floating-point value");
      }
      return x;
    };
    conversions["unrestricted double"] = function(V) {
      const x = +V;
      if (isNaN(x)) {
        throw new TypeError("Argument is NaN");
      }
      return x;
    };
    conversions["float"] = conversions["double"];
    conversions["unrestricted float"] = conversions["unrestricted double"];
    conversions["DOMString"] = function(V, opts) {
      if (!opts)
        opts = {};
      if (opts.treatNullAsEmptyString && V === null) {
        return "";
      }
      return String(V);
    };
    conversions["ByteString"] = function(V, opts) {
      const x = String(V);
      let c = void 0;
      for (let i = 0; (c = x.codePointAt(i)) !== void 0; ++i) {
        if (c > 255) {
          throw new TypeError("Argument is not a valid bytestring");
        }
      }
      return x;
    };
    conversions["USVString"] = function(V) {
      const S = String(V);
      const n = S.length;
      const U = [];
      for (let i = 0; i < n; ++i) {
        const c = S.charCodeAt(i);
        if (c < 55296 || c > 57343) {
          U.push(String.fromCodePoint(c));
        } else if (56320 <= c && c <= 57343) {
          U.push(String.fromCodePoint(65533));
        } else {
          if (i === n - 1) {
            U.push(String.fromCodePoint(65533));
          } else {
            const d = S.charCodeAt(i + 1);
            if (56320 <= d && d <= 57343) {
              const a = c & 1023;
              const b = d & 1023;
              U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
              ++i;
            } else {
              U.push(String.fromCodePoint(65533));
            }
          }
        }
      }
      return U.join("");
    };
    conversions["Date"] = function(V, opts) {
      if (!(V instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
      }
      if (isNaN(V)) {
        return void 0;
      }
      return V;
    };
    conversions["RegExp"] = function(V, opts) {
      if (!(V instanceof RegExp)) {
        V = new RegExp(V);
      }
      return V;
    };
  }
});

// node_modules/whatwg-url/lib/utils.js
var require_utils = __commonJS({
  "node_modules/whatwg-url/lib/utils.js"(exports, module2) {
    "use strict";
    module2.exports.mixin = function mixin(target, source) {
      const keys = Object.getOwnPropertyNames(source);
      for (let i = 0; i < keys.length; ++i) {
        Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
      }
    };
    module2.exports.wrapperSymbol = Symbol("wrapper");
    module2.exports.implSymbol = Symbol("impl");
    module2.exports.wrapperForImpl = function(impl) {
      return impl[module2.exports.wrapperSymbol];
    };
    module2.exports.implForWrapper = function(wrapper) {
      return wrapper[module2.exports.implSymbol];
    };
  }
});

// node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "node_modules/tr46/lib/mappingTable.json"(exports, module2) {
    module2.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
  }
});

// node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "node_modules/tr46/index.js"(exports, module2) {
    "use strict";
    var punycode = require("punycode");
    var mappingTable = require_mappingTable();
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1
    };
    function normalize(str) {
      return str.split("\0").map(function(s) {
        return s.normalize("NFC");
      }).join("\0");
    }
    function findStatus(val) {
      var start = 0;
      var end = mappingTable.length - 1;
      while (start <= end) {
        var mid = Math.floor((start + end) / 2);
        var target = mappingTable[mid];
        if (target[0][0] <= val && target[0][1] >= val) {
          return target;
        } else if (target[0][0] > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string) {
      return string.replace(regexAstralSymbols, "_").length;
    }
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false;
      var processed = "";
      var len = countSymbols(domain_name);
      for (var i = 0; i < len; ++i) {
        var codePoint = domain_name.codePointAt(i);
        var status = findStatus(codePoint);
        switch (status[1]) {
          case "disallowed":
            hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
          case "ignored":
            break;
          case "mapped":
            processed += String.fromCodePoint.apply(String, status[2]);
            break;
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
              processed += String.fromCodePoint.apply(String, status[2]);
            } else {
              processed += String.fromCodePoint(codePoint);
            }
            break;
          case "valid":
            processed += String.fromCodePoint(codePoint);
            break;
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true;
              processed += String.fromCodePoint(codePoint);
            } else {
              processed += String.fromCodePoint.apply(String, status[2]);
            }
            break;
          case "disallowed_STD3_valid":
            if (useSTD3) {
              hasError = true;
            }
            processed += String.fromCodePoint(codePoint);
            break;
        }
      }
      return {
        string: processed,
        error: hasError
      };
    }
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode.toUnicode(label);
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
      }
      var error = false;
      if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
        error = true;
      }
      var len = countSymbols(label);
      for (var i = 0; i < len; ++i) {
        var status = findStatus(label.codePointAt(i));
        if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
          error = true;
          break;
        }
      }
      return {
        label,
        error
      };
    }
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option);
      result.string = normalize(result.string);
      var labels = result.string.split(".");
      for (var i = 0; i < labels.length; ++i) {
        try {
          var validation = validateLabel(labels[i]);
          labels[i] = validation.label;
          result.error = result.error || validation.error;
        } catch (e) {
          result.error = true;
        }
      }
      return {
        string: labels.join("."),
        error: result.error
      };
    }
    module2.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
      var result = processing(domain_name, useSTD3, processing_option);
      var labels = result.string.split(".");
      labels = labels.map(function(l) {
        try {
          return punycode.toASCII(l);
        } catch (e) {
          result.error = true;
          return l;
        }
      });
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length;
        if (total.length > 253 || total.length === 0) {
          result.error = true;
        }
        for (var i = 0; i < labels.length; ++i) {
          if (labels.length > 63 || labels.length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error)
        return null;
      return labels.join(".");
    };
    module2.exports.toUnicode = function(domain_name, useSTD3) {
      var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
      return {
        domain: result.string,
        error: result.error
      };
    };
    module2.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  }
});

// node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "node_modules/whatwg-url/lib/url-state-machine.js"(exports, module2) {
    "use strict";
    var punycode = require("punycode");
    var tr46 = require_tr46();
    var specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return punycode.ucs2.decode(str).length;
    }
    function at(input, idx) {
      const c = input[idx];
      return isNaN(c) ? void 0 : String.fromCodePoint(c);
    }
    function isASCIIDigit(c) {
      return c >= 48 && c <= 57;
    }
    function isASCIIAlpha(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122;
    }
    function isASCIIAlphanumeric(c) {
      return isASCIIAlpha(c) || isASCIIDigit(c);
    }
    function isASCIIHex(c) {
      return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
    }
    function isWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
    }
    function containsForbiddenHostCodePoint(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function containsForbiddenHostCodePointExcludingPercent(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url) {
      return isSpecialScheme(url.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function percentEncode(c) {
      let hex = c.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = "0" + hex;
      }
      return "%" + hex;
    }
    function utf8PercentEncode(c) {
      const buf = new Buffer(c);
      let str = "";
      for (let i = 0; i < buf.length; ++i) {
        str += percentEncode(buf[i]);
      }
      return str;
    }
    function utf8PercentDecode(str) {
      const input = new Buffer(str);
      const output = [];
      for (let i = 0; i < input.length; ++i) {
        if (input[i] !== 37) {
          output.push(input[i]);
        } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
          output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
          i += 2;
        } else {
          output.push(input[i]);
        }
      }
      return new Buffer(output).toString();
    }
    function isC0ControlPercentEncode(c) {
      return c <= 31 || c > 126;
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
    function isPathPercentEncode(c) {
      return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
    function isUserinfoPercentEncode(c) {
      return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
    }
    function percentEncodeChar(c, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c);
      if (encodeSetPredicate(c)) {
        return utf8PercentEncode(cStr);
      }
      return cStr;
    }
    function parseIPv4Number(input) {
      let R = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R = 8;
      }
      if (input === "") {
        return 0;
      }
      const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
      if (regex.test(input)) {
        return failure;
      }
      return parseInt(input, R);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return input;
      }
      const numbers = [];
      for (const part of parts) {
        if (part === "") {
          return input;
        }
        const n = parseIPv4Number(part);
        if (n === failure) {
          return input;
        }
        numbers.push(n);
      }
      for (let i = 0; i < numbers.length - 1; ++i) {
        if (numbers[i] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n of numbers) {
        ipv4 += n * Math.pow(256, 3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n = address;
      for (let i = 1; i <= 4; ++i) {
        output = String(n % 256) + output;
        if (i !== 4) {
          output = "." + output;
        }
        n = Math.floor(n / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = punycode.ucs2.decode(input);
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === 58) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === 46) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === 46 && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (isASCIIDigit(input[pointer])) {
              const number = parseInt(at(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === 58) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const seqResult = findLongestZeroSequence(address);
      const compress = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost(input, isSpecialArg) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (!isSpecialArg) {
        return parseOpaqueHost(input);
      }
      const domain = utf8PercentDecode(input);
      const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
      if (asciiDomain === null) {
        return failure;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
      }
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
      }
      return asciiDomain;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
      }
      let output = "";
      const decoded = punycode.ucs2.decode(input);
      for (let i = 0; i < decoded.length; ++i) {
        output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
      }
      return output;
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i = 0; i < arr.length; ++i) {
        if (arr[i] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen
      };
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
      }
      return host;
    }
    function trimControlChars(url) {
      return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
    }
    function trimTabAndNewline(url) {
      return url.replace(/\u0009|\u000A|\u000D/g, "");
    }
    function shortenPath(url) {
      const path3 = url.path;
      if (path3.length === 0) {
        return;
      }
      if (url.scheme === "file" && path3.length === 1 && isNormalizedWindowsDriveLetter(path3[0])) {
        return;
      }
      path3.pop();
    }
    function includesCredentials(url) {
      return url.username !== "" || url.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url) {
      return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
    }
    function isNormalizedWindowsDriveLetter(string) {
      return /^[A-Za-z]:$/.test(string);
    }
    function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c = this.input[this.pointer];
        const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
        const ret = this["parse " + this.state](c, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
      if (isASCIIAlpha(c)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
      if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
        this.buffer += cStr.toLowerCase();
      } else if (c === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
          return false;
        }
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
      if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
        return failure;
      } else if (this.base.cannotBeABaseURL && c === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
      if (c === 47) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c === 47) {
        this.state = "relative slash";
      } else if (c === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
      if (isSpecial(this.url) && (c === 47 || c === 92)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c === 47) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
      if (c !== 47 && c !== 92) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
      if (c === 64) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
          return false;
        }
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c === 91) {
          this.arrFlag = true;
        } else if (c === 93) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
      if (isASCIIDigit(c)) {
        this.buffer += cStr;
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
    URLStateMachine.prototype["parse file"] = function parseFile(c) {
      this.url.scheme = "file";
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (this.input.length - this.pointer - 1 === 0 || !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else {
            this.parseError = true;
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          } else {
            this.url.host = this.base.host;
          }
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
      if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
      if (isSpecial(this.url)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "path";
        if (c !== 47 && c !== 92) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c !== void 0) {
        this.state = "path";
        if (c !== 47) {
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c) {
      if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
        if (isSpecial(this.url) && c === 92) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c === void 0 || c === 63 || c === 35)) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        }
        if (c === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += percentEncodeChar(c, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
      if (c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (!isNaN(c) && c !== 37) {
          this.parseError = true;
        }
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c)) {
          this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
      if (isNaN(c) || !this.stateOverride && c === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8";
        }
        const buffer = new Buffer(this.buffer);
        for (let i = 0; i < buffer.length; ++i) {
          if (buffer[i] < 33 || buffer[i] > 126 || buffer[i] === 34 || buffer[i] === 35 || buffer[i] === 60 || buffer[i] === 62) {
            this.url.query += percentEncode(buffer[i]);
          } else {
            this.url.query += String.fromCodePoint(buffer[i]);
          }
        }
        this.buffer = "";
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
      if (isNaN(c)) {
      } else if (c === 0) {
        this.parseError = true;
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
      }
      return true;
    };
    function serializeURL(url, excludeFragment) {
      let output = url.scheme + ":";
      if (url.host !== null) {
        output += "//";
        if (url.username !== "" || url.password !== "") {
          output += url.username;
          if (url.password !== "") {
            output += ":" + url.password;
          }
          output += "@";
        }
        output += serializeHost(url.host);
        if (url.port !== null) {
          output += ":" + url.port;
        }
      } else if (url.host === null && url.scheme === "file") {
        output += "//";
      }
      if (url.cannotBeABaseURL) {
        output += url.path[0];
      } else {
        for (const string of url.path) {
          output += "/" + string;
        }
      }
      if (url.query !== null) {
        output += "?" + url.query;
      }
      if (!excludeFragment && url.fragment !== null) {
        output += "#" + url.fragment;
      }
      return output;
    }
    function serializeOrigin(tuple) {
      let result = tuple.scheme + "://";
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += ":" + tuple.port;
      }
      return result;
    }
    module2.exports.serializeURL = serializeURL;
    module2.exports.serializeURLOrigin = function(url) {
      switch (url.scheme) {
        case "blob":
          try {
            return module2.exports.serializeURLOrigin(module2.exports.parseURL(url.path[0]));
          } catch (e) {
            return "null";
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url.scheme,
            host: url.host,
            port: url.port
          });
        case "file":
          return "file://";
        default:
          return "null";
      }
    };
    module2.exports.basicURLParse = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
      if (usm.failure) {
        return "failure";
      }
      return usm.url;
    };
    module2.exports.setTheUsername = function(url, username) {
      url.username = "";
      const decoded = punycode.ucs2.decode(username);
      for (let i = 0; i < decoded.length; ++i) {
        url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module2.exports.setThePassword = function(url, password) {
      url.password = "";
      const decoded = punycode.ucs2.decode(password);
      for (let i = 0; i < decoded.length; ++i) {
        url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module2.exports.serializeHost = serializeHost;
    module2.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module2.exports.serializeInteger = function(integer) {
      return String(integer);
    };
    module2.exports.parseURL = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      return module2.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
    };
  }
});

// node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "node_modules/whatwg-url/lib/URL-impl.js"(exports) {
    "use strict";
    var usm = require_url_state_machine();
    exports.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url = constructorArgs[0];
        const base = constructorArgs[1];
        let parsedBase = null;
        if (base !== void 0) {
          parsedBase = usm.basicURLParse(base);
          if (parsedBase === "failure") {
            throw new TypeError("Invalid base URL");
          }
        }
        const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v) {
        const parsedURL = usm.basicURLParse(v);
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v) {
        usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v);
      }
      get password() {
        return this._url.password;
      }
      set password(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v);
      }
      get host() {
        const url = this._url;
        if (url.host === null) {
          return "";
        }
        if (url.port === null) {
          return usm.serializeHost(url.host);
        }
        return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
      }
      set host(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0];
        }
        if (this._url.path.length === 0) {
          return "";
        }
        return "/" + this._url.path.join("/");
      }
      set pathname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return "?" + this._url.query;
      }
      set search(v) {
        const url = this._url;
        if (v === "") {
          url.query = null;
          return;
        }
        const input = v[0] === "?" ? v.substring(1) : v;
        url.query = "";
        usm.basicURLParse(input, { url, stateOverride: "query" });
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return "#" + this._url.fragment;
      }
      set hash(v) {
        if (v === "") {
          this._url.fragment = null;
          return;
        }
        const input = v[0] === "#" ? v.substring(1) : v;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "node_modules/whatwg-url/lib/URL.js"(exports, module2) {
    "use strict";
    var conversions = require_lib2();
    var utils = require_utils();
    var Impl = require_URL_impl();
    var impl = utils.implSymbol;
    function URL(url) {
      if (!this || this[impl] || !(this instanceof URL)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
      }
      if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 2; ++i) {
        args[i] = arguments[i];
      }
      args[0] = conversions["USVString"](args[0]);
      if (args[1] !== void 0) {
        args[1] = conversions["USVString"](args[1]);
      }
      module2.exports.setup(this, args);
    }
    URL.prototype.toJSON = function toJSON() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 0; ++i) {
        args[i] = arguments[i];
      }
      return this[impl].toJSON.apply(this[impl], args);
    };
    Object.defineProperty(URL.prototype, "href", {
      get() {
        return this[impl].href;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].href = V;
      },
      enumerable: true,
      configurable: true
    });
    URL.prototype.toString = function() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      return this.href;
    };
    Object.defineProperty(URL.prototype, "origin", {
      get() {
        return this[impl].origin;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "protocol", {
      get() {
        return this[impl].protocol;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].protocol = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "username", {
      get() {
        return this[impl].username;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].username = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "password", {
      get() {
        return this[impl].password;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].password = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "host", {
      get() {
        return this[impl].host;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].host = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "hostname", {
      get() {
        return this[impl].hostname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hostname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "port", {
      get() {
        return this[impl].port;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].port = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "pathname", {
      get() {
        return this[impl].pathname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].pathname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "search", {
      get() {
        return this[impl].search;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].search = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "hash", {
      get() {
        return this[impl].hash;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hash = V;
      },
      enumerable: true,
      configurable: true
    });
    module2.exports = {
      is(obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData)
          privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils.wrapperSymbol] = obj;
      },
      interface: URL,
      expose: {
        Window: { URL },
        Worker: { URL }
      }
    };
  }
});

// node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({
  "node_modules/whatwg-url/lib/public-api.js"(exports) {
    "use strict";
    exports.URL = require_URL().interface;
    exports.serializeURL = require_url_state_machine().serializeURL;
    exports.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
    exports.basicURLParse = require_url_state_machine().basicURLParse;
    exports.setTheUsername = require_url_state_machine().setTheUsername;
    exports.setThePassword = require_url_state_machine().setThePassword;
    exports.serializeHost = require_url_state_machine().serializeHost;
    exports.serializeInteger = require_url_state_machine().serializeInteger;
    exports.parseURL = require_url_state_machine().parseURL;
  }
});

// node_modules/node-fetch/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/node-fetch/lib/index.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var Stream = _interopDefault(require("stream"));
    var http = _interopDefault(require("http"));
    var Url = _interopDefault(require("url"));
    var whatwgUrl = _interopDefault(require_public_api());
    var https = _interopDefault(require("https"));
    var zlib = _interopDefault(require("zlib"));
    var Readable = Stream.Readable;
    var BUFFER = Symbol("buffer");
    var TYPE = Symbol("type");
    var Blob = class {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a = blobParts;
          const length = Number(a.length);
          for (let i = 0; i < length; i++) {
            const element = a[i];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof Blob) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== void 0 && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable();
        readable._read = function() {
        };
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new Blob([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function FetchError(message, type, systemError) {
      Error.call(this, message);
      this.message = message;
      this.type = type;
      if (systemError) {
        this.code = this.errno = systemError.code;
      }
      Error.captureStackTrace(this, this.constructor);
    }
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    var convert;
    try {
      convert = require("encoding").convert;
    } catch (e) {
    }
    var INTERNALS = Symbol("Body internals");
    var PassThrough = Stream.PassThrough;
    function Body(body) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
      let size = _ref$size === void 0 ? 0 : _ref$size;
      var _ref$timeout = _ref.timeout;
      let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
      if (body == null) {
        body = null;
      } else if (isURLSearchParams(body)) {
        body = Buffer.from(body.toString());
      } else if (isBlob(body))
        ;
      else if (Buffer.isBuffer(body))
        ;
      else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        body = Buffer.from(body);
      } else if (ArrayBuffer.isView(body)) {
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
      } else if (body instanceof Stream)
        ;
      else {
        body = Buffer.from(String(body));
      }
      this[INTERNALS] = {
        body,
        disturbed: false,
        error: null
      };
      this.size = size;
      this.timeout = timeout;
      if (body instanceof Stream) {
        body.on("error", function(err) {
          const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
          _this[INTERNALS].error = error;
        });
      }
    }
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      arrayBuffer() {
        return consumeBody.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      blob() {
        let ct = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then(function(buf) {
          return Object.assign(
            new Blob([], {
              type: ct.toLowerCase()
            }),
            {
              [BUFFER]: buf
            }
          );
        });
      },
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err) {
            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      text() {
        return consumeBody.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      buffer() {
        return consumeBody.call(this);
      },
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body.mixIn = function(proto) {
      for (const name of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
          Object.defineProperty(proto, name, desc);
        }
      }
    };
    function consumeBody() {
      var _this4 = this;
      if (this[INTERNALS].disturbed) {
        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
      }
      this[INTERNALS].disturbed = true;
      if (this[INTERNALS].error) {
        return Body.Promise.reject(this[INTERNALS].error);
      }
      let body = this.body;
      if (body === null) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      if (isBlob(body)) {
        body = body.stream();
      }
      if (Buffer.isBuffer(body)) {
        return Body.Promise.resolve(body);
      }
      if (!(body instanceof Stream)) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      let accum = [];
      let accumBytes = 0;
      let abort = false;
      return new Body.Promise(function(resolve, reject) {
        let resTimeout;
        if (_this4.timeout) {
          resTimeout = setTimeout(function() {
            abort = true;
            reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
          }, _this4.timeout);
        }
        body.on("error", function(err) {
          if (err.name === "AbortError") {
            abort = true;
            reject(err);
          } else {
            reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
          }
        });
        body.on("data", function(chunk) {
          if (abort || chunk === null) {
            return;
          }
          if (_this4.size && accumBytes + chunk.length > _this4.size) {
            abort = true;
            reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
            return;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        });
        body.on("end", function() {
          if (abort) {
            return;
          }
          clearTimeout(resTimeout);
          try {
            resolve(Buffer.concat(accum, accumBytes));
          } catch (err) {
            reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
          }
        });
      });
    }
    function convertBody(buffer, headers) {
      if (typeof convert !== "function") {
        throw new Error("The package `encoding` must be installed to use the textConverted() function");
      }
      const ct = headers.get("content-type");
      let charset = "utf-8";
      let res, str;
      if (ct) {
        res = /charset=([^;]*)/i.exec(ct);
      }
      str = buffer.slice(0, 1024).toString();
      if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
      }
      if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
          res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
          if (res) {
            res.pop();
          }
        }
        if (res) {
          res = /charset=(.*)/i.exec(res.pop());
        }
      }
      if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
      }
      if (res) {
        charset = res.pop();
        if (charset === "gb2312" || charset === "gbk") {
          charset = "gb18030";
        }
      }
      return convert(buffer, "UTF-8", charset).toString();
    }
    function isURLSearchParams(obj) {
      if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
        return false;
      }
      return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
    }
    function isBlob(obj) {
      return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
    }
    function clone(instance) {
      let p1, p2;
      let body = instance.body;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream && typeof body.getBoundary !== "function") {
        p1 = new PassThrough();
        p2 = new PassThrough();
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS].body = p1;
        body = p2;
      }
      return body;
    }
    function extractContentType(body) {
      if (body === null) {
        return null;
      } else if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      } else if (isURLSearchParams(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isBlob(body)) {
        return body.type || null;
      } else if (Buffer.isBuffer(body)) {
        return null;
      } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        return null;
      } else if (ArrayBuffer.isView(body)) {
        return null;
      } else if (typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      } else if (body instanceof Stream) {
        return null;
      } else {
        return "text/plain;charset=UTF-8";
      }
    }
    function getTotalBytes(instance) {
      const body = instance.body;
      if (body === null) {
        return 0;
      } else if (isBlob(body)) {
        return body.size;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (body && typeof body.getLengthSync === "function") {
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) {
          return body.getLengthSync();
        }
        return null;
      } else {
        return null;
      }
    }
    function writeToStream(dest, instance) {
      const body = instance.body;
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    }
    Body.Promise = global.Promise;
    var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function validateName(name) {
      name = `${name}`;
      if (invalidTokenRegex.test(name) || name === "") {
        throw new TypeError(`${name} is not a legal HTTP header name`);
      }
    }
    function validateValue(value) {
      value = `${value}`;
      if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
      }
    }
    function find(map, name) {
      name = name.toLowerCase();
      for (const key in map) {
        if (key.toLowerCase() === name) {
          return key;
        }
      }
      return void 0;
    }
    var MAP = Symbol("map");
    var Headers = class {
      constructor() {
        let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init instanceof Headers) {
          const rawHeaders = init.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init == null)
          ;
        else if (typeof init === "object") {
          const method = init[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init)) {
              const value = init[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i = 0;
        while (i < pairs.length) {
          var _pairs$i = pairs[i];
          const name = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name, this);
          pairs = getHeaders(this);
          i++;
        }
      }
      set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== void 0 ? key : name] = [value];
      }
      append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name] = [value];
        }
      }
      has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== void 0;
      }
      delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      raw() {
        return this[MAP];
      }
      keys() {
        return createHeadersIterator(this, "key");
      }
      values() {
        return createHeadersIterator(this, "value");
      }
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers.prototype.entries = Headers.prototype[Symbol.iterator];
    Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    function getHeaders(headers) {
      let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
      const keys = Object.keys(headers[MAP]).sort();
      return keys.map(kind === "key" ? function(k) {
        return k.toLowerCase();
      } : kind === "value" ? function(k) {
        return headers[MAP][k].join(", ");
      } : function(k) {
        return [k.toLowerCase(), headers[MAP][k].join(", ")];
      });
    }
    var INTERNAL = Symbol("internal");
    function createHeadersIterator(target, kind) {
      const iterator = Object.create(HeadersIteratorPrototype);
      iterator[INTERNAL] = {
        target,
        kind,
        index: 0
      };
      return iterator;
    }
    var HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index + 1;
        return {
          value: values[index],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function exportNodeCompatibleHeaders(headers) {
      const obj = Object.assign({ __proto__: null }, headers[MAP]);
      const hostHeaderKey = find(headers[MAP], "Host");
      if (hostHeaderKey !== void 0) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
      }
      return obj;
    }
    function createHeadersLenient(obj) {
      const headers = new Headers();
      for (const name of Object.keys(obj)) {
        if (invalidTokenRegex.test(name)) {
          continue;
        }
        if (Array.isArray(obj[name])) {
          for (const val of obj[name]) {
            if (invalidHeaderCharRegex.test(val)) {
              continue;
            }
            if (headers[MAP][name] === void 0) {
              headers[MAP][name] = [val];
            } else {
              headers[MAP][name].push(val);
            }
          }
        } else if (!invalidHeaderCharRegex.test(obj[name])) {
          headers[MAP][name] = [obj[name]];
        }
      }
      return headers;
    }
    var INTERNALS$1 = Symbol("Response internals");
    var STATUS_CODES = http.STATUS_CODES;
    var Response = class {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      clone() {
        return new Response(clone(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body.mixIn(Response.prototype);
    Object.defineProperties(Response.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    var INTERNALS$2 = Symbol("Request internals");
    var URL = Url.URL || whatwgUrl.URL;
    var parse_url = Url.parse;
    var format_url = Url.format;
    function parseURL(urlStr) {
      if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
        urlStr = new URL(urlStr).toString();
      }
      return parse_url(urlStr);
    }
    var streamDestructionSupported = "destroy" in Stream.Readable.prototype;
    function isRequest(input) {
      return typeof input === "object" && typeof input[INTERNALS$2] === "object";
    }
    function isAbortSignal(signal) {
      const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
      return !!(proto && proto.constructor.name === "AbortSignal");
    }
    var Request = class {
      constructor(input) {
        let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parseURL(input.href);
          } else {
            parsedURL = parseURL(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parseURL(input.url);
        }
        let method = init.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
        Body.call(this, inputBody, {
          timeout: init.timeout || input.timeout || 0,
          size: init.size || input.size || 0
        });
        const headers = new Headers(init.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init)
          signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      clone() {
        return new Request(this);
      }
    };
    Body.mixIn(Request.prototype);
    Object.defineProperty(Request.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    function getNodeRequestOptions(request) {
      const parsedURL = request[INTERNALS$2].parsedURL;
      const headers = new Headers(request[INTERNALS$2].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError("Only absolute URLs are supported");
      }
      if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError("Only HTTP(S) protocols are supported");
      }
      if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
        throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
      }
      let contentLengthValue = null;
      if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body != null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number") {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate");
      }
      let agent = request.agent;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
      });
    }
    function AbortError(message) {
      Error.call(this, message);
      this.type = "aborted";
      this.message = message;
      Error.captureStackTrace(this, this.constructor);
    }
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = "AbortError";
    var URL$1 = Url.URL || whatwgUrl.URL;
    var PassThrough$1 = Stream.PassThrough;
    var isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
      const orig = new URL$1(original).hostname;
      const dest = new URL$1(destination).hostname;
      return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
    };
    function fetch2(url, opts) {
      if (!fetch2.Promise) {
        throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
      }
      Body.Promise = fetch2.Promise;
      return new fetch2.Promise(function(resolve, reject) {
        const request = new Request(url, opts);
        const options = getNodeRequestOptions(request);
        const send = (options.protocol === "https:" ? https : http).request;
        const signal = request.signal;
        let response = null;
        const abort = function abort2() {
          let error = new AbortError("The user aborted a request.");
          reject(error);
          if (request.body && request.body instanceof Stream.Readable) {
            request.body.destroy(error);
          }
          if (!response || !response.body)
            return;
          response.body.emit("error", error);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        const abortAndFinalize = function abortAndFinalize2() {
          abort();
          finalize();
        };
        const req = send(options);
        let reqTimeout;
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        function finalize() {
          req.abort();
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
          clearTimeout(reqTimeout);
        }
        if (request.timeout) {
          req.once("socket", function(socket) {
            reqTimeout = setTimeout(function() {
              reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
              finalize();
            }, request.timeout);
          });
        }
        req.on("error", function(err) {
          reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
          finalize();
        });
        req.on("response", function(res) {
          clearTimeout(reqTimeout);
          const headers = createHeadersLenient(res.headers);
          if (fetch2.isRedirect(res.statusCode)) {
            const location = headers.get("Location");
            let locationURL = null;
            try {
              locationURL = location === null ? null : new URL$1(location, request.url).toString();
            } catch (err) {
              if (request.redirect !== "manual") {
                reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
                finalize();
                return;
              }
            }
            switch (request.redirect) {
              case "error":
                reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
                finalize();
                return;
              case "manual":
                if (locationURL !== null) {
                  try {
                    headers.set("Location", locationURL);
                  } catch (err) {
                    reject(err);
                  }
                }
                break;
              case "follow":
                if (locationURL === null) {
                  break;
                }
                if (request.counter >= request.follow) {
                  reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                  finalize();
                  return;
                }
                const requestOpts = {
                  headers: new Headers(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  body: request.body,
                  signal: request.signal,
                  timeout: request.timeout,
                  size: request.size
                };
                if (!isDomainOrSubdomain(request.url, locationURL)) {
                  for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                    requestOpts.headers.delete(name);
                  }
                }
                if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                  reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                  finalize();
                  return;
                }
                if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                  requestOpts.method = "GET";
                  requestOpts.body = void 0;
                  requestOpts.headers.delete("content-length");
                }
                resolve(fetch2(new Request(locationURL, requestOpts)));
                finalize();
                return;
            }
          }
          res.once("end", function() {
            if (signal)
              signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = res.pipe(new PassThrough$1());
          const response_options = {
            url: request.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers,
            size: request.size,
            timeout: request.timeout,
            counter: request.counter
          };
          const codings = headers.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
            response = new Response(body, response_options);
            resolve(response);
            return;
          }
          const zlibOptions = {
            flush: zlib.Z_SYNC_FLUSH,
            finishFlush: zlib.Z_SYNC_FLUSH
          };
          if (codings == "gzip" || codings == "x-gzip") {
            body = body.pipe(zlib.createGunzip(zlibOptions));
            response = new Response(body, response_options);
            resolve(response);
            return;
          }
          if (codings == "deflate" || codings == "x-deflate") {
            const raw = res.pipe(new PassThrough$1());
            raw.once("data", function(chunk) {
              if ((chunk[0] & 15) === 8) {
                body = body.pipe(zlib.createInflate());
              } else {
                body = body.pipe(zlib.createInflateRaw());
              }
              response = new Response(body, response_options);
              resolve(response);
            });
            return;
          }
          if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
            body = body.pipe(zlib.createBrotliDecompress());
            response = new Response(body, response_options);
            resolve(response);
            return;
          }
          response = new Response(body, response_options);
          resolve(response);
        });
        writeToStream(req, request);
      });
    }
    fetch2.isRedirect = function(code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };
    fetch2.Promise = global.Promise;
    module2.exports = exports = fetch2;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = exports;
    exports.Headers = Headers;
    exports.Request = Request;
    exports.Response = Response;
    exports.FetchError = FetchError;
  }
});

// node_modules/meaw/lib/meaw.cjs.js
var require_meaw_cjs = __commonJS({
  "node_modules/meaw/lib/meaw.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defs = [
      { start: 0, end: 31, prop: "N" },
      { start: 32, end: 126, prop: "Na" },
      { start: 127, end: 160, prop: "N" },
      { start: 161, end: 161, prop: "A" },
      { start: 162, end: 163, prop: "Na" },
      { start: 164, end: 164, prop: "A" },
      { start: 165, end: 166, prop: "Na" },
      { start: 167, end: 168, prop: "A" },
      { start: 169, end: 169, prop: "N" },
      { start: 170, end: 170, prop: "A" },
      { start: 171, end: 171, prop: "N" },
      { start: 172, end: 172, prop: "Na" },
      { start: 173, end: 174, prop: "A" },
      { start: 175, end: 175, prop: "Na" },
      { start: 176, end: 180, prop: "A" },
      { start: 181, end: 181, prop: "N" },
      { start: 182, end: 186, prop: "A" },
      { start: 187, end: 187, prop: "N" },
      { start: 188, end: 191, prop: "A" },
      { start: 192, end: 197, prop: "N" },
      { start: 198, end: 198, prop: "A" },
      { start: 199, end: 207, prop: "N" },
      { start: 208, end: 208, prop: "A" },
      { start: 209, end: 214, prop: "N" },
      { start: 215, end: 216, prop: "A" },
      { start: 217, end: 221, prop: "N" },
      { start: 222, end: 225, prop: "A" },
      { start: 226, end: 229, prop: "N" },
      { start: 230, end: 230, prop: "A" },
      { start: 231, end: 231, prop: "N" },
      { start: 232, end: 234, prop: "A" },
      { start: 235, end: 235, prop: "N" },
      { start: 236, end: 237, prop: "A" },
      { start: 238, end: 239, prop: "N" },
      { start: 240, end: 240, prop: "A" },
      { start: 241, end: 241, prop: "N" },
      { start: 242, end: 243, prop: "A" },
      { start: 244, end: 246, prop: "N" },
      { start: 247, end: 250, prop: "A" },
      { start: 251, end: 251, prop: "N" },
      { start: 252, end: 252, prop: "A" },
      { start: 253, end: 253, prop: "N" },
      { start: 254, end: 254, prop: "A" },
      { start: 255, end: 256, prop: "N" },
      { start: 257, end: 257, prop: "A" },
      { start: 258, end: 272, prop: "N" },
      { start: 273, end: 273, prop: "A" },
      { start: 274, end: 274, prop: "N" },
      { start: 275, end: 275, prop: "A" },
      { start: 276, end: 282, prop: "N" },
      { start: 283, end: 283, prop: "A" },
      { start: 284, end: 293, prop: "N" },
      { start: 294, end: 295, prop: "A" },
      { start: 296, end: 298, prop: "N" },
      { start: 299, end: 299, prop: "A" },
      { start: 300, end: 304, prop: "N" },
      { start: 305, end: 307, prop: "A" },
      { start: 308, end: 311, prop: "N" },
      { start: 312, end: 312, prop: "A" },
      { start: 313, end: 318, prop: "N" },
      { start: 319, end: 322, prop: "A" },
      { start: 323, end: 323, prop: "N" },
      { start: 324, end: 324, prop: "A" },
      { start: 325, end: 327, prop: "N" },
      { start: 328, end: 331, prop: "A" },
      { start: 332, end: 332, prop: "N" },
      { start: 333, end: 333, prop: "A" },
      { start: 334, end: 337, prop: "N" },
      { start: 338, end: 339, prop: "A" },
      { start: 340, end: 357, prop: "N" },
      { start: 358, end: 359, prop: "A" },
      { start: 360, end: 362, prop: "N" },
      { start: 363, end: 363, prop: "A" },
      { start: 364, end: 461, prop: "N" },
      { start: 462, end: 462, prop: "A" },
      { start: 463, end: 463, prop: "N" },
      { start: 464, end: 464, prop: "A" },
      { start: 465, end: 465, prop: "N" },
      { start: 466, end: 466, prop: "A" },
      { start: 467, end: 467, prop: "N" },
      { start: 468, end: 468, prop: "A" },
      { start: 469, end: 469, prop: "N" },
      { start: 470, end: 470, prop: "A" },
      { start: 471, end: 471, prop: "N" },
      { start: 472, end: 472, prop: "A" },
      { start: 473, end: 473, prop: "N" },
      { start: 474, end: 474, prop: "A" },
      { start: 475, end: 475, prop: "N" },
      { start: 476, end: 476, prop: "A" },
      { start: 477, end: 592, prop: "N" },
      { start: 593, end: 593, prop: "A" },
      { start: 594, end: 608, prop: "N" },
      { start: 609, end: 609, prop: "A" },
      { start: 610, end: 707, prop: "N" },
      { start: 708, end: 708, prop: "A" },
      { start: 709, end: 710, prop: "N" },
      { start: 711, end: 711, prop: "A" },
      { start: 712, end: 712, prop: "N" },
      { start: 713, end: 715, prop: "A" },
      { start: 716, end: 716, prop: "N" },
      { start: 717, end: 717, prop: "A" },
      { start: 718, end: 719, prop: "N" },
      { start: 720, end: 720, prop: "A" },
      { start: 721, end: 727, prop: "N" },
      { start: 728, end: 731, prop: "A" },
      { start: 732, end: 732, prop: "N" },
      { start: 733, end: 733, prop: "A" },
      { start: 734, end: 734, prop: "N" },
      { start: 735, end: 735, prop: "A" },
      { start: 736, end: 767, prop: "N" },
      { start: 768, end: 879, prop: "A" },
      { start: 880, end: 912, prop: "N" },
      { start: 913, end: 929, prop: "A" },
      { start: 930, end: 930, prop: "N" },
      { start: 931, end: 937, prop: "A" },
      { start: 938, end: 944, prop: "N" },
      { start: 945, end: 961, prop: "A" },
      { start: 962, end: 962, prop: "N" },
      { start: 963, end: 969, prop: "A" },
      { start: 970, end: 1024, prop: "N" },
      { start: 1025, end: 1025, prop: "A" },
      { start: 1026, end: 1039, prop: "N" },
      { start: 1040, end: 1103, prop: "A" },
      { start: 1104, end: 1104, prop: "N" },
      { start: 1105, end: 1105, prop: "A" },
      { start: 1106, end: 4351, prop: "N" },
      { start: 4352, end: 4447, prop: "W" },
      { start: 4448, end: 8207, prop: "N" },
      { start: 8208, end: 8208, prop: "A" },
      { start: 8209, end: 8210, prop: "N" },
      { start: 8211, end: 8214, prop: "A" },
      { start: 8215, end: 8215, prop: "N" },
      { start: 8216, end: 8217, prop: "A" },
      { start: 8218, end: 8219, prop: "N" },
      { start: 8220, end: 8221, prop: "A" },
      { start: 8222, end: 8223, prop: "N" },
      { start: 8224, end: 8226, prop: "A" },
      { start: 8227, end: 8227, prop: "N" },
      { start: 8228, end: 8231, prop: "A" },
      { start: 8232, end: 8239, prop: "N" },
      { start: 8240, end: 8240, prop: "A" },
      { start: 8241, end: 8241, prop: "N" },
      { start: 8242, end: 8243, prop: "A" },
      { start: 8244, end: 8244, prop: "N" },
      { start: 8245, end: 8245, prop: "A" },
      { start: 8246, end: 8250, prop: "N" },
      { start: 8251, end: 8251, prop: "A" },
      { start: 8252, end: 8253, prop: "N" },
      { start: 8254, end: 8254, prop: "A" },
      { start: 8255, end: 8307, prop: "N" },
      { start: 8308, end: 8308, prop: "A" },
      { start: 8309, end: 8318, prop: "N" },
      { start: 8319, end: 8319, prop: "A" },
      { start: 8320, end: 8320, prop: "N" },
      { start: 8321, end: 8324, prop: "A" },
      { start: 8325, end: 8360, prop: "N" },
      { start: 8361, end: 8361, prop: "H" },
      { start: 8362, end: 8363, prop: "N" },
      { start: 8364, end: 8364, prop: "A" },
      { start: 8365, end: 8450, prop: "N" },
      { start: 8451, end: 8451, prop: "A" },
      { start: 8452, end: 8452, prop: "N" },
      { start: 8453, end: 8453, prop: "A" },
      { start: 8454, end: 8456, prop: "N" },
      { start: 8457, end: 8457, prop: "A" },
      { start: 8458, end: 8466, prop: "N" },
      { start: 8467, end: 8467, prop: "A" },
      { start: 8468, end: 8469, prop: "N" },
      { start: 8470, end: 8470, prop: "A" },
      { start: 8471, end: 8480, prop: "N" },
      { start: 8481, end: 8482, prop: "A" },
      { start: 8483, end: 8485, prop: "N" },
      { start: 8486, end: 8486, prop: "A" },
      { start: 8487, end: 8490, prop: "N" },
      { start: 8491, end: 8491, prop: "A" },
      { start: 8492, end: 8530, prop: "N" },
      { start: 8531, end: 8532, prop: "A" },
      { start: 8533, end: 8538, prop: "N" },
      { start: 8539, end: 8542, prop: "A" },
      { start: 8543, end: 8543, prop: "N" },
      { start: 8544, end: 8555, prop: "A" },
      { start: 8556, end: 8559, prop: "N" },
      { start: 8560, end: 8569, prop: "A" },
      { start: 8570, end: 8584, prop: "N" },
      { start: 8585, end: 8585, prop: "A" },
      { start: 8586, end: 8591, prop: "N" },
      { start: 8592, end: 8601, prop: "A" },
      { start: 8602, end: 8631, prop: "N" },
      { start: 8632, end: 8633, prop: "A" },
      { start: 8634, end: 8657, prop: "N" },
      { start: 8658, end: 8658, prop: "A" },
      { start: 8659, end: 8659, prop: "N" },
      { start: 8660, end: 8660, prop: "A" },
      { start: 8661, end: 8678, prop: "N" },
      { start: 8679, end: 8679, prop: "A" },
      { start: 8680, end: 8703, prop: "N" },
      { start: 8704, end: 8704, prop: "A" },
      { start: 8705, end: 8705, prop: "N" },
      { start: 8706, end: 8707, prop: "A" },
      { start: 8708, end: 8710, prop: "N" },
      { start: 8711, end: 8712, prop: "A" },
      { start: 8713, end: 8714, prop: "N" },
      { start: 8715, end: 8715, prop: "A" },
      { start: 8716, end: 8718, prop: "N" },
      { start: 8719, end: 8719, prop: "A" },
      { start: 8720, end: 8720, prop: "N" },
      { start: 8721, end: 8721, prop: "A" },
      { start: 8722, end: 8724, prop: "N" },
      { start: 8725, end: 8725, prop: "A" },
      { start: 8726, end: 8729, prop: "N" },
      { start: 8730, end: 8730, prop: "A" },
      { start: 8731, end: 8732, prop: "N" },
      { start: 8733, end: 8736, prop: "A" },
      { start: 8737, end: 8738, prop: "N" },
      { start: 8739, end: 8739, prop: "A" },
      { start: 8740, end: 8740, prop: "N" },
      { start: 8741, end: 8741, prop: "A" },
      { start: 8742, end: 8742, prop: "N" },
      { start: 8743, end: 8748, prop: "A" },
      { start: 8749, end: 8749, prop: "N" },
      { start: 8750, end: 8750, prop: "A" },
      { start: 8751, end: 8755, prop: "N" },
      { start: 8756, end: 8759, prop: "A" },
      { start: 8760, end: 8763, prop: "N" },
      { start: 8764, end: 8765, prop: "A" },
      { start: 8766, end: 8775, prop: "N" },
      { start: 8776, end: 8776, prop: "A" },
      { start: 8777, end: 8779, prop: "N" },
      { start: 8780, end: 8780, prop: "A" },
      { start: 8781, end: 8785, prop: "N" },
      { start: 8786, end: 8786, prop: "A" },
      { start: 8787, end: 8799, prop: "N" },
      { start: 8800, end: 8801, prop: "A" },
      { start: 8802, end: 8803, prop: "N" },
      { start: 8804, end: 8807, prop: "A" },
      { start: 8808, end: 8809, prop: "N" },
      { start: 8810, end: 8811, prop: "A" },
      { start: 8812, end: 8813, prop: "N" },
      { start: 8814, end: 8815, prop: "A" },
      { start: 8816, end: 8833, prop: "N" },
      { start: 8834, end: 8835, prop: "A" },
      { start: 8836, end: 8837, prop: "N" },
      { start: 8838, end: 8839, prop: "A" },
      { start: 8840, end: 8852, prop: "N" },
      { start: 8853, end: 8853, prop: "A" },
      { start: 8854, end: 8856, prop: "N" },
      { start: 8857, end: 8857, prop: "A" },
      { start: 8858, end: 8868, prop: "N" },
      { start: 8869, end: 8869, prop: "A" },
      { start: 8870, end: 8894, prop: "N" },
      { start: 8895, end: 8895, prop: "A" },
      { start: 8896, end: 8977, prop: "N" },
      { start: 8978, end: 8978, prop: "A" },
      { start: 8979, end: 8985, prop: "N" },
      { start: 8986, end: 8987, prop: "W" },
      { start: 8988, end: 9e3, prop: "N" },
      { start: 9001, end: 9002, prop: "W" },
      { start: 9003, end: 9192, prop: "N" },
      { start: 9193, end: 9196, prop: "W" },
      { start: 9197, end: 9199, prop: "N" },
      { start: 9200, end: 9200, prop: "W" },
      { start: 9201, end: 9202, prop: "N" },
      { start: 9203, end: 9203, prop: "W" },
      { start: 9204, end: 9311, prop: "N" },
      { start: 9312, end: 9449, prop: "A" },
      { start: 9450, end: 9450, prop: "N" },
      { start: 9451, end: 9547, prop: "A" },
      { start: 9548, end: 9551, prop: "N" },
      { start: 9552, end: 9587, prop: "A" },
      { start: 9588, end: 9599, prop: "N" },
      { start: 9600, end: 9615, prop: "A" },
      { start: 9616, end: 9617, prop: "N" },
      { start: 9618, end: 9621, prop: "A" },
      { start: 9622, end: 9631, prop: "N" },
      { start: 9632, end: 9633, prop: "A" },
      { start: 9634, end: 9634, prop: "N" },
      { start: 9635, end: 9641, prop: "A" },
      { start: 9642, end: 9649, prop: "N" },
      { start: 9650, end: 9651, prop: "A" },
      { start: 9652, end: 9653, prop: "N" },
      { start: 9654, end: 9655, prop: "A" },
      { start: 9656, end: 9659, prop: "N" },
      { start: 9660, end: 9661, prop: "A" },
      { start: 9662, end: 9663, prop: "N" },
      { start: 9664, end: 9665, prop: "A" },
      { start: 9666, end: 9669, prop: "N" },
      { start: 9670, end: 9672, prop: "A" },
      { start: 9673, end: 9674, prop: "N" },
      { start: 9675, end: 9675, prop: "A" },
      { start: 9676, end: 9677, prop: "N" },
      { start: 9678, end: 9681, prop: "A" },
      { start: 9682, end: 9697, prop: "N" },
      { start: 9698, end: 9701, prop: "A" },
      { start: 9702, end: 9710, prop: "N" },
      { start: 9711, end: 9711, prop: "A" },
      { start: 9712, end: 9724, prop: "N" },
      { start: 9725, end: 9726, prop: "W" },
      { start: 9727, end: 9732, prop: "N" },
      { start: 9733, end: 9734, prop: "A" },
      { start: 9735, end: 9736, prop: "N" },
      { start: 9737, end: 9737, prop: "A" },
      { start: 9738, end: 9741, prop: "N" },
      { start: 9742, end: 9743, prop: "A" },
      { start: 9744, end: 9747, prop: "N" },
      { start: 9748, end: 9749, prop: "W" },
      { start: 9750, end: 9755, prop: "N" },
      { start: 9756, end: 9756, prop: "A" },
      { start: 9757, end: 9757, prop: "N" },
      { start: 9758, end: 9758, prop: "A" },
      { start: 9759, end: 9791, prop: "N" },
      { start: 9792, end: 9792, prop: "A" },
      { start: 9793, end: 9793, prop: "N" },
      { start: 9794, end: 9794, prop: "A" },
      { start: 9795, end: 9799, prop: "N" },
      { start: 9800, end: 9811, prop: "W" },
      { start: 9812, end: 9823, prop: "N" },
      { start: 9824, end: 9825, prop: "A" },
      { start: 9826, end: 9826, prop: "N" },
      { start: 9827, end: 9829, prop: "A" },
      { start: 9830, end: 9830, prop: "N" },
      { start: 9831, end: 9834, prop: "A" },
      { start: 9835, end: 9835, prop: "N" },
      { start: 9836, end: 9837, prop: "A" },
      { start: 9838, end: 9838, prop: "N" },
      { start: 9839, end: 9839, prop: "A" },
      { start: 9840, end: 9854, prop: "N" },
      { start: 9855, end: 9855, prop: "W" },
      { start: 9856, end: 9874, prop: "N" },
      { start: 9875, end: 9875, prop: "W" },
      { start: 9876, end: 9885, prop: "N" },
      { start: 9886, end: 9887, prop: "A" },
      { start: 9888, end: 9888, prop: "N" },
      { start: 9889, end: 9889, prop: "W" },
      { start: 9890, end: 9897, prop: "N" },
      { start: 9898, end: 9899, prop: "W" },
      { start: 9900, end: 9916, prop: "N" },
      { start: 9917, end: 9918, prop: "W" },
      { start: 9919, end: 9919, prop: "A" },
      { start: 9920, end: 9923, prop: "N" },
      { start: 9924, end: 9925, prop: "W" },
      { start: 9926, end: 9933, prop: "A" },
      { start: 9934, end: 9934, prop: "W" },
      { start: 9935, end: 9939, prop: "A" },
      { start: 9940, end: 9940, prop: "W" },
      { start: 9941, end: 9953, prop: "A" },
      { start: 9954, end: 9954, prop: "N" },
      { start: 9955, end: 9955, prop: "A" },
      { start: 9956, end: 9959, prop: "N" },
      { start: 9960, end: 9961, prop: "A" },
      { start: 9962, end: 9962, prop: "W" },
      { start: 9963, end: 9969, prop: "A" },
      { start: 9970, end: 9971, prop: "W" },
      { start: 9972, end: 9972, prop: "A" },
      { start: 9973, end: 9973, prop: "W" },
      { start: 9974, end: 9977, prop: "A" },
      { start: 9978, end: 9978, prop: "W" },
      { start: 9979, end: 9980, prop: "A" },
      { start: 9981, end: 9981, prop: "W" },
      { start: 9982, end: 9983, prop: "A" },
      { start: 9984, end: 9988, prop: "N" },
      { start: 9989, end: 9989, prop: "W" },
      { start: 9990, end: 9993, prop: "N" },
      { start: 9994, end: 9995, prop: "W" },
      { start: 9996, end: 10023, prop: "N" },
      { start: 10024, end: 10024, prop: "W" },
      { start: 10025, end: 10044, prop: "N" },
      { start: 10045, end: 10045, prop: "A" },
      { start: 10046, end: 10059, prop: "N" },
      { start: 10060, end: 10060, prop: "W" },
      { start: 10061, end: 10061, prop: "N" },
      { start: 10062, end: 10062, prop: "W" },
      { start: 10063, end: 10066, prop: "N" },
      { start: 10067, end: 10069, prop: "W" },
      { start: 10070, end: 10070, prop: "N" },
      { start: 10071, end: 10071, prop: "W" },
      { start: 10072, end: 10101, prop: "N" },
      { start: 10102, end: 10111, prop: "A" },
      { start: 10112, end: 10132, prop: "N" },
      { start: 10133, end: 10135, prop: "W" },
      { start: 10136, end: 10159, prop: "N" },
      { start: 10160, end: 10160, prop: "W" },
      { start: 10161, end: 10174, prop: "N" },
      { start: 10175, end: 10175, prop: "W" },
      { start: 10176, end: 10213, prop: "N" },
      { start: 10214, end: 10221, prop: "Na" },
      { start: 10222, end: 10628, prop: "N" },
      { start: 10629, end: 10630, prop: "Na" },
      { start: 10631, end: 11034, prop: "N" },
      { start: 11035, end: 11036, prop: "W" },
      { start: 11037, end: 11087, prop: "N" },
      { start: 11088, end: 11088, prop: "W" },
      { start: 11089, end: 11092, prop: "N" },
      { start: 11093, end: 11093, prop: "W" },
      { start: 11094, end: 11097, prop: "A" },
      { start: 11098, end: 11903, prop: "N" },
      { start: 11904, end: 11929, prop: "W" },
      { start: 11930, end: 11930, prop: "N" },
      { start: 11931, end: 12019, prop: "W" },
      { start: 12020, end: 12031, prop: "N" },
      { start: 12032, end: 12245, prop: "W" },
      { start: 12246, end: 12271, prop: "N" },
      { start: 12272, end: 12283, prop: "W" },
      { start: 12284, end: 12287, prop: "N" },
      { start: 12288, end: 12288, prop: "F" },
      { start: 12289, end: 12350, prop: "W" },
      { start: 12351, end: 12352, prop: "N" },
      { start: 12353, end: 12438, prop: "W" },
      { start: 12439, end: 12440, prop: "N" },
      { start: 12441, end: 12543, prop: "W" },
      { start: 12544, end: 12548, prop: "N" },
      { start: 12549, end: 12591, prop: "W" },
      { start: 12592, end: 12592, prop: "N" },
      { start: 12593, end: 12686, prop: "W" },
      { start: 12687, end: 12687, prop: "N" },
      { start: 12688, end: 12730, prop: "W" },
      { start: 12731, end: 12735, prop: "N" },
      { start: 12736, end: 12771, prop: "W" },
      { start: 12772, end: 12783, prop: "N" },
      { start: 12784, end: 12830, prop: "W" },
      { start: 12831, end: 12831, prop: "N" },
      { start: 12832, end: 12871, prop: "W" },
      { start: 12872, end: 12879, prop: "A" },
      { start: 12880, end: 19903, prop: "W" },
      { start: 19904, end: 19967, prop: "N" },
      { start: 19968, end: 42124, prop: "W" },
      { start: 42125, end: 42127, prop: "N" },
      { start: 42128, end: 42182, prop: "W" },
      { start: 42183, end: 43359, prop: "N" },
      { start: 43360, end: 43388, prop: "W" },
      { start: 43389, end: 44031, prop: "N" },
      { start: 44032, end: 55203, prop: "W" },
      { start: 55204, end: 57343, prop: "N" },
      { start: 57344, end: 63743, prop: "A" },
      { start: 63744, end: 64255, prop: "W" },
      { start: 64256, end: 65023, prop: "N" },
      { start: 65024, end: 65039, prop: "A" },
      { start: 65040, end: 65049, prop: "W" },
      { start: 65050, end: 65071, prop: "N" },
      { start: 65072, end: 65106, prop: "W" },
      { start: 65107, end: 65107, prop: "N" },
      { start: 65108, end: 65126, prop: "W" },
      { start: 65127, end: 65127, prop: "N" },
      { start: 65128, end: 65131, prop: "W" },
      { start: 65132, end: 65280, prop: "N" },
      { start: 65281, end: 65376, prop: "F" },
      { start: 65377, end: 65470, prop: "H" },
      { start: 65471, end: 65473, prop: "N" },
      { start: 65474, end: 65479, prop: "H" },
      { start: 65480, end: 65481, prop: "N" },
      { start: 65482, end: 65487, prop: "H" },
      { start: 65488, end: 65489, prop: "N" },
      { start: 65490, end: 65495, prop: "H" },
      { start: 65496, end: 65497, prop: "N" },
      { start: 65498, end: 65500, prop: "H" },
      { start: 65501, end: 65503, prop: "N" },
      { start: 65504, end: 65510, prop: "F" },
      { start: 65511, end: 65511, prop: "N" },
      { start: 65512, end: 65518, prop: "H" },
      { start: 65519, end: 65532, prop: "N" },
      { start: 65533, end: 65533, prop: "A" },
      { start: 65534, end: 94175, prop: "N" },
      { start: 94176, end: 94179, prop: "W" },
      { start: 94180, end: 94207, prop: "N" },
      { start: 94208, end: 100343, prop: "W" },
      { start: 100344, end: 100351, prop: "N" },
      { start: 100352, end: 101106, prop: "W" },
      { start: 101107, end: 110591, prop: "N" },
      { start: 110592, end: 110878, prop: "W" },
      { start: 110879, end: 110927, prop: "N" },
      { start: 110928, end: 110930, prop: "W" },
      { start: 110931, end: 110947, prop: "N" },
      { start: 110948, end: 110951, prop: "W" },
      { start: 110952, end: 110959, prop: "N" },
      { start: 110960, end: 111355, prop: "W" },
      { start: 111356, end: 126979, prop: "N" },
      { start: 126980, end: 126980, prop: "W" },
      { start: 126981, end: 127182, prop: "N" },
      { start: 127183, end: 127183, prop: "W" },
      { start: 127184, end: 127231, prop: "N" },
      { start: 127232, end: 127242, prop: "A" },
      { start: 127243, end: 127247, prop: "N" },
      { start: 127248, end: 127277, prop: "A" },
      { start: 127278, end: 127279, prop: "N" },
      { start: 127280, end: 127337, prop: "A" },
      { start: 127338, end: 127343, prop: "N" },
      { start: 127344, end: 127373, prop: "A" },
      { start: 127374, end: 127374, prop: "W" },
      { start: 127375, end: 127376, prop: "A" },
      { start: 127377, end: 127386, prop: "W" },
      { start: 127387, end: 127404, prop: "A" },
      { start: 127405, end: 127487, prop: "N" },
      { start: 127488, end: 127490, prop: "W" },
      { start: 127491, end: 127503, prop: "N" },
      { start: 127504, end: 127547, prop: "W" },
      { start: 127548, end: 127551, prop: "N" },
      { start: 127552, end: 127560, prop: "W" },
      { start: 127561, end: 127567, prop: "N" },
      { start: 127568, end: 127569, prop: "W" },
      { start: 127570, end: 127583, prop: "N" },
      { start: 127584, end: 127589, prop: "W" },
      { start: 127590, end: 127743, prop: "N" },
      { start: 127744, end: 127776, prop: "W" },
      { start: 127777, end: 127788, prop: "N" },
      { start: 127789, end: 127797, prop: "W" },
      { start: 127798, end: 127798, prop: "N" },
      { start: 127799, end: 127868, prop: "W" },
      { start: 127869, end: 127869, prop: "N" },
      { start: 127870, end: 127891, prop: "W" },
      { start: 127892, end: 127903, prop: "N" },
      { start: 127904, end: 127946, prop: "W" },
      { start: 127947, end: 127950, prop: "N" },
      { start: 127951, end: 127955, prop: "W" },
      { start: 127956, end: 127967, prop: "N" },
      { start: 127968, end: 127984, prop: "W" },
      { start: 127985, end: 127987, prop: "N" },
      { start: 127988, end: 127988, prop: "W" },
      { start: 127989, end: 127991, prop: "N" },
      { start: 127992, end: 128062, prop: "W" },
      { start: 128063, end: 128063, prop: "N" },
      { start: 128064, end: 128064, prop: "W" },
      { start: 128065, end: 128065, prop: "N" },
      { start: 128066, end: 128252, prop: "W" },
      { start: 128253, end: 128254, prop: "N" },
      { start: 128255, end: 128317, prop: "W" },
      { start: 128318, end: 128330, prop: "N" },
      { start: 128331, end: 128334, prop: "W" },
      { start: 128335, end: 128335, prop: "N" },
      { start: 128336, end: 128359, prop: "W" },
      { start: 128360, end: 128377, prop: "N" },
      { start: 128378, end: 128378, prop: "W" },
      { start: 128379, end: 128404, prop: "N" },
      { start: 128405, end: 128406, prop: "W" },
      { start: 128407, end: 128419, prop: "N" },
      { start: 128420, end: 128420, prop: "W" },
      { start: 128421, end: 128506, prop: "N" },
      { start: 128507, end: 128591, prop: "W" },
      { start: 128592, end: 128639, prop: "N" },
      { start: 128640, end: 128709, prop: "W" },
      { start: 128710, end: 128715, prop: "N" },
      { start: 128716, end: 128716, prop: "W" },
      { start: 128717, end: 128719, prop: "N" },
      { start: 128720, end: 128722, prop: "W" },
      { start: 128723, end: 128724, prop: "N" },
      { start: 128725, end: 128725, prop: "W" },
      { start: 128726, end: 128746, prop: "N" },
      { start: 128747, end: 128748, prop: "W" },
      { start: 128749, end: 128755, prop: "N" },
      { start: 128756, end: 128762, prop: "W" },
      { start: 128763, end: 128991, prop: "N" },
      { start: 128992, end: 129003, prop: "W" },
      { start: 129004, end: 129292, prop: "N" },
      { start: 129293, end: 129393, prop: "W" },
      { start: 129394, end: 129394, prop: "N" },
      { start: 129395, end: 129398, prop: "W" },
      { start: 129399, end: 129401, prop: "N" },
      { start: 129402, end: 129442, prop: "W" },
      { start: 129443, end: 129444, prop: "N" },
      { start: 129445, end: 129450, prop: "W" },
      { start: 129451, end: 129453, prop: "N" },
      { start: 129454, end: 129482, prop: "W" },
      { start: 129483, end: 129484, prop: "N" },
      { start: 129485, end: 129535, prop: "W" },
      { start: 129536, end: 129647, prop: "N" },
      { start: 129648, end: 129651, prop: "W" },
      { start: 129652, end: 129655, prop: "N" },
      { start: 129656, end: 129658, prop: "W" },
      { start: 129659, end: 129663, prop: "N" },
      { start: 129664, end: 129666, prop: "W" },
      { start: 129667, end: 129679, prop: "N" },
      { start: 129680, end: 129685, prop: "W" },
      { start: 129686, end: 131071, prop: "N" },
      { start: 131072, end: 196605, prop: "W" },
      { start: 196606, end: 196607, prop: "N" },
      { start: 196608, end: 262141, prop: "W" },
      { start: 262142, end: 917759, prop: "N" },
      { start: 917760, end: 917999, prop: "A" },
      { start: 918e3, end: 983039, prop: "N" },
      { start: 983040, end: 1048573, prop: "A" },
      { start: 1048574, end: 1048575, prop: "N" },
      { start: 1048576, end: 1114109, prop: "A" },
      { start: 1114110, end: 1114111, prop: "N" }
    ];
    var version = "12.1.0";
    function _getEAWOfCodePoint(codePoint) {
      let min = 0;
      let max = defs.length - 1;
      while (min !== max) {
        const i = min + (max - min >> 1);
        const def = defs[i];
        if (codePoint < def.start) {
          max = i - 1;
        } else if (codePoint > def.end) {
          min = i + 1;
        } else {
          return def.prop;
        }
      }
      return defs[min].prop;
    }
    function getEAW(str, at) {
      const codePoint = str.codePointAt(at || 0);
      return codePoint === void 0 ? void 0 : _getEAWOfCodePoint(codePoint);
    }
    var defaultWidthMap = {
      "N": 1,
      "Na": 1,
      "W": 2,
      "F": 2,
      "H": 1,
      "A": 1
    };
    function computeWidth2(str, widthMap) {
      const map = widthMap ? Object.assign({}, defaultWidthMap, widthMap) : defaultWidthMap;
      let width = 0;
      for (const char of str) {
        width += map[getEAW(char)];
      }
      return width;
    }
    exports.computeWidth = computeWidth2;
    exports.eawVersion = version;
    exports.getEAW = getEAW;
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports, module2) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    module2.exports = {
      SEMVER_SPEC_VERSION,
      MAX_LENGTH,
      MAX_SAFE_INTEGER,
      MAX_SAFE_COMPONENT_LENGTH
    };
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports, module2) {
    var { MAX_SAFE_COMPONENT_LENGTH } = require_constants();
    var debug = require_debug();
    exports = module2.exports = {};
    var re = exports.re = [];
    var src = exports.src = [];
    var t = exports.t = {};
    var R = 0;
    var createToken = (name, value, isGlobal) => {
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
    createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports, module2) {
    var opts = ["includePrerelease", "loose", "rtl"];
    var parseOptions = (options) => !options ? {} : typeof options !== "object" ? { loose: true } : opts.filter((k) => options[k]).reduce((o, k) => {
      o[k] = true;
      return o;
    }, {});
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports, module2) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      inc(release, identifier) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier);
            this.inc("pre", identifier);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier);
            }
            this.inc("pre", identifier);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0) {
              this.prerelease = [0];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                this.prerelease.push(0);
              }
            }
            if (identifier) {
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = [identifier, 0];
                }
              } else {
                this.prerelease = [identifier, 0];
              }
            }
            break;
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.format();
        this.raw = this.version;
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports, module2) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// src/extension.ts
var extension_exports = {};
__export(extension_exports, {
  activate: () => activate4,
  getExtensionPath: () => getExtensionPath
});
module.exports = __toCommonJS(extension_exports);
var vscode18 = __toESM(require("vscode"));

// src/util/commandManager.ts
var vscode = __toESM(require("vscode"));
var CommandManager = class {
  constructor() {
    this.commands = /* @__PURE__ */ new Map();
  }
  dispose() {
    for (const registration of this.commands.values()) {
      registration.dispose();
    }
    this.commands.clear();
  }
  register(command) {
    this.registerCommand(command.id, command.execute, command);
    return command;
  }
  registerCommand(id, impl, thisArg) {
    if (this.commands.has(id)) {
      return;
    }
    this.commands.set(
      id,
      vscode.commands.registerCommand(id, impl, thisArg)
    );
  }
};

// src/commands/openDocumentLink.ts
var vscode2 = __toESM(require("vscode"));
var path = __toESM(require("path"));

// src/util/file.ts
function isRSTFile(document2) {
  return document2.languageId === "restructuredtext";
}

// src/commands/openDocumentLink.ts
var _OpenDocumentLinkCommand = class {
  constructor() {
    this.id = _OpenDocumentLinkCommand.id;
  }
  static createCommandUri(path3, fragment) {
    return vscode2.Uri.parse(
      `command:${_OpenDocumentLinkCommand.id}?${encodeURIComponent(
        JSON.stringify({ path: path3, fragment })
      )}`
    );
  }
  execute(args) {
    const p = decodeURIComponent(args.path);
    return this.tryOpen(p, args).catch(() => {
      if (path.extname(p) === "") {
        return this.tryOpen(p + ".md", args);
      }
      const resource = vscode2.Uri.file(p);
      return Promise.resolve(void 0).then(
        () => vscode2.commands.executeCommand("vscode.open", resource)
      ).then(() => void 0);
    });
  }
  async tryOpen(path3, args) {
    const resource = vscode2.Uri.file(path3);
    if (vscode2.window.activeTextEditor && isRSTFile(vscode2.window.activeTextEditor.document) && vscode2.window.activeTextEditor.document.uri.fsPath === resource.fsPath) {
      return this.tryRevealLine(
        vscode2.window.activeTextEditor,
        args.fragment
      );
    } else {
      return vscode2.workspace.openTextDocument(resource).then(vscode2.window.showTextDocument).then((editor) => this.tryRevealLine(editor, args.fragment));
    }
  }
  async tryRevealLine(editor, fragment) {
    if (editor && fragment) {
      const lineNumberFragment = fragment.match(/^L(\d+)$/i);
      if (lineNumberFragment) {
        const line = +lineNumberFragment[1] - 1;
        if (!isNaN(line)) {
          return editor.revealRange(
            new vscode2.Range(line, 0, line, 0),
            vscode2.TextEditorRevealType.AtTop
          );
        }
      }
    }
  }
};
var OpenDocumentLinkCommand = _OpenDocumentLinkCommand;
OpenDocumentLinkCommand.id = "_rst.openDocumentLink";

// src/commands/moveCursorToPosition.ts
var vscode3 = __toESM(require("vscode"));
var MoveCursorToPositionCommand = class {
  constructor() {
    this.id = "_rst.moveCursorToPosition";
  }
  execute(line, character) {
    if (!vscode3.window.activeTextEditor) {
      return;
    }
    const position = new vscode3.Position(line, character);
    const selection = new vscode3.Selection(position, position);
    vscode3.window.activeTextEditor.revealRange(selection);
    vscode3.window.activeTextEditor.selection = selection;
  }
};

// src/editor/extension.ts
var vscode15 = __toESM(require("vscode"));

// src/editor/commands.ts
var vscode11 = __toESM(require("vscode"));

// src/editor/util.ts
var vscode5 = __toESM(require("vscode"));

// src/editor/i18n.ts
var vscode4 = __toESM(require("vscode"));
var i18nFiles = {
  en: "./../package.nls.json"
};
var i18nData = getData();
function getData() {
  const locale = vscode4.env.language;
  let i18nJSON;
  if (locale in i18nFiles) {
    i18nJSON = require(i18nFiles[locale]);
  } else {
    i18nJSON = require(i18nFiles["en"]);
  }
  return i18nJSON;
}

// src/editor/util.ts
function getTextAtOffsetPosition(document2, position, offset) {
  const curLine = position.line;
  const curChar = position.character;
  const newChar = curChar + offset;
  const lineEndChar = document2.lineAt(curLine).range.end.character;
  if (newChar < 0 || newChar > lineEndChar) {
    return;
  }
  const range = new vscode5.Range(curLine, curChar, curLine, newChar);
  return document2.getText(range);
}
function isSelectingLastChara() {
  const editor = vscode5.window.activeTextEditor;
  if (!editor) {
    return;
  }
  const selPosition = editor.selection.start;
  const lineEndPosition = editor.document.lineAt(selPosition.line).range.end;
  const isLastIndex = selPosition.isEqual(lineEndPosition);
  return isLastIndex;
}
function isAscii(text) {
  if (text.match(/[\x01-\x7E\xA1-\xDF]/)) {
    return true;
  } else {
    return false;
  }
}
function countTextWidth(text) {
  let count = 0;
  for (let i = 0; i < text.length; i++) {
    const chr = text[i];
    if (isAscii(chr)) {
      count += 1;
    } else {
      count += 2;
    }
  }
  return count;
}
function tableSizeIsSelected(editor) {
  if (!editor) {
    editor = vscode5.window.activeTextEditor;
    if (!editor) {
      return;
    }
  }
  const selection = editor.selection;
  if (selection.isEmpty) {
    return;
  }
  const startPos = new vscode5.Position(selection.start.line, 0);
  const endLine = selection.end.line;
  const endLastChar = editor.document.lineAt(endLine).range.end.character;
  const endPos = new vscode5.Position(endLine, endLastChar);
  const data = editor.document.getText(new vscode5.Range(startPos, endPos));
  const regRowColumn = /^(?<row>\d+)(?<x>x)(?<column>\d+)$/;
  const match = regRowColumn.exec(data);
  if (!match?.groups) {
    return;
  }
  const rowText = match.groups["row"];
  const x = match.groups["x"];
  const columnText = match.groups["column"];
  if (!(rowText && x && columnText)) {
    return;
  }
  return [Number(rowText), Number(columnText)];
}
function tableIsSelected(editor) {
  if (!editor) {
    editor = vscode5.window.activeTextEditor;
    if (!editor) {
      return;
    }
  }
  const curLine = editor.selection.start.line;
  const regTableBegin = /^(\+-[-+]+-\+)$/;
  const regTableEnd = /^(?!(\s|\+|\||-))(?<!\w+)/;
  const allText = editor.document.getText();
  const allTextSplit = allText.split(/\r\n|\r|\n/);
  let tableLines = [];
  let inTheTable = false;
  for (let i = 0; i < allTextSplit.length; i++) {
    const textLine = allTextSplit[i];
    if (!inTheTable) {
      const match = regTableBegin.exec(textLine);
      if (match) {
        tableLines.push(i);
        inTheTable = true;
      }
    } else {
      const match = regTableEnd.exec(textLine);
      if (match) {
        inTheTable = false;
        if (tableLines.includes(curLine)) {
          return tableLines;
        } else {
          tableLines = [];
        }
      } else {
        tableLines.push(i);
      }
    }
  }
  if (tableLines.includes(curLine)) {
    return tableLines;
  } else {
    return;
  }
}
function listIsSelected(editor) {
  if (!editor) {
    editor = vscode5.window.activeTextEditor;
    if (!editor) {
      return false;
    }
  }
  const curLine = editor.selection.start.line;
  const regListLine = /^\s*((\(?([a-zA-Z0-9]+|#)(\.|\))) )|^\s*([-+*] )/;
  const curLineRange = editor.document.lineAt(curLine).range;
  const curLineText = editor.document.getText(curLineRange);
  const match = regListLine.exec(curLineText);
  if (match) {
    return true;
  } else {
    return false;
  }
}
function listExistsOneLineAbove(editor) {
  if (!editor) {
    editor = vscode5.window.activeTextEditor;
    if (!editor) {
      return false;
    }
  }
  const curLine = editor.selection.start.line;
  const regListLine = /^\s*((\(?([a-zA-Z0-9]+|#)(\.|\))) )|^\s*([-+*] )/;
  if (curLine === 0) {
    return false;
  } else {
    const oneLineAboveRange = editor.document.lineAt(curLine - 1).range;
    const oneLineAboveText = editor.document.getText(oneLineAboveRange);
    const match = regListLine.exec(oneLineAboveText);
    if (match) {
      return true;
    } else {
      return false;
    }
  }
}

// src/editor/tableEditor.ts
var vscode10 = __toESM(require("vscode"));

// node_modules/reflect-metadata/Reflect.js
var Reflect2;
(function(Reflect3) {
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : Function("return this;")();
    var exporter = makeExporter(Reflect3);
    if (typeof root.Reflect === "undefined") {
      root.Reflect = Reflect3;
    } else {
      exporter = makeExporter(root.Reflect, exporter);
    }
    factory(exporter);
    function makeExporter(target, previous) {
      return function(key, value) {
        if (typeof target[key] !== "function") {
          Object.defineProperty(target, key, { configurable: true, writable: true, value });
        }
        if (previous)
          previous(key, value);
      };
    }
  })(function(exporter) {
    var hasOwn = Object.prototype.hasOwnProperty;
    var supportsSymbol = typeof Symbol === "function";
    var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
    var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
    var supportsCreate = typeof Object.create === "function";
    var supportsProto = { __proto__: [] } instanceof Array;
    var downLevel = !supportsCreate && !supportsProto;
    var HashMap = {
      create: supportsCreate ? function() {
        return MakeDictionary(/* @__PURE__ */ Object.create(null));
      } : supportsProto ? function() {
        return MakeDictionary({ __proto__: null });
      } : function() {
        return MakeDictionary({});
      },
      has: downLevel ? function(map, key) {
        return hasOwn.call(map, key);
      } : function(map, key) {
        return key in map;
      },
      get: downLevel ? function(map, key) {
        return hasOwn.call(map, key) ? map[key] : void 0;
      } : function(map, key) {
        return map[key];
      }
    };
    var functionPrototype = Object.getPrototypeOf(Function);
    var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
    var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
    var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
    var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
    var Metadata = new _WeakMap();
    function decorate(decorators, target, propertyKey, attributes) {
      if (!IsUndefined(propertyKey)) {
        if (!IsArray(decorators))
          throw new TypeError();
        if (!IsObject(target))
          throw new TypeError();
        if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
          throw new TypeError();
        if (IsNull(attributes))
          attributes = void 0;
        propertyKey = ToPropertyKey(propertyKey);
        return DecorateProperty(decorators, target, propertyKey, attributes);
      } else {
        if (!IsArray(decorators))
          throw new TypeError();
        if (!IsConstructor(target))
          throw new TypeError();
        return DecorateConstructor(decorators, target);
      }
    }
    exporter("decorate", decorate);
    function metadata(metadataKey, metadataValue) {
      function decorator(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
          throw new TypeError();
        OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      return decorator;
    }
    exporter("metadata", metadata);
    function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
    }
    exporter("defineMetadata", defineMetadata);
    function hasMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasMetadata", hasMetadata);
    function hasOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasOwnMetadata", hasOwnMetadata);
    function getMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetMetadata(metadataKey, target, propertyKey);
    }
    exporter("getMetadata", getMetadata);
    function getOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("getOwnMetadata", getOwnMetadata);
    function getMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryMetadataKeys(target, propertyKey);
    }
    exporter("getMetadataKeys", getMetadataKeys);
    function getOwnMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryOwnMetadataKeys(target, propertyKey);
    }
    exporter("getOwnMetadataKeys", getOwnMetadataKeys);
    function deleteMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      var metadataMap = GetOrCreateMetadataMap(target, propertyKey, false);
      if (IsUndefined(metadataMap))
        return false;
      if (!metadataMap.delete(metadataKey))
        return false;
      if (metadataMap.size > 0)
        return true;
      var targetMetadata = Metadata.get(target);
      targetMetadata.delete(propertyKey);
      if (targetMetadata.size > 0)
        return true;
      Metadata.delete(target);
      return true;
    }
    exporter("deleteMetadata", deleteMetadata);
    function DecorateConstructor(decorators, target) {
      for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i];
        var decorated = decorator(target);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsConstructor(decorated))
            throw new TypeError();
          target = decorated;
        }
      }
      return target;
    }
    function DecorateProperty(decorators, target, propertyKey, descriptor) {
      for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i];
        var decorated = decorator(target, propertyKey, descriptor);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsObject(decorated))
            throw new TypeError();
          descriptor = decorated;
        }
      }
      return descriptor;
    }
    function GetOrCreateMetadataMap(O, P, Create) {
      var targetMetadata = Metadata.get(O);
      if (IsUndefined(targetMetadata)) {
        if (!Create)
          return void 0;
        targetMetadata = new _Map();
        Metadata.set(O, targetMetadata);
      }
      var metadataMap = targetMetadata.get(P);
      if (IsUndefined(metadataMap)) {
        if (!Create)
          return void 0;
        metadataMap = new _Map();
        targetMetadata.set(P, metadataMap);
      }
      return metadataMap;
    }
    function OrdinaryHasMetadata(MetadataKey, O, P) {
      var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn2)
        return true;
      var parent = OrdinaryGetPrototypeOf(O);
      if (!IsNull(parent))
        return OrdinaryHasMetadata(MetadataKey, parent, P);
      return false;
    }
    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
      var metadataMap = GetOrCreateMetadataMap(O, P, false);
      if (IsUndefined(metadataMap))
        return false;
      return ToBoolean(metadataMap.has(MetadataKey));
    }
    function OrdinaryGetMetadata(MetadataKey, O, P) {
      var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn2)
        return OrdinaryGetOwnMetadata(MetadataKey, O, P);
      var parent = OrdinaryGetPrototypeOf(O);
      if (!IsNull(parent))
        return OrdinaryGetMetadata(MetadataKey, parent, P);
      return void 0;
    }
    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
      var metadataMap = GetOrCreateMetadataMap(O, P, false);
      if (IsUndefined(metadataMap))
        return void 0;
      return metadataMap.get(MetadataKey);
    }
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
      var metadataMap = GetOrCreateMetadataMap(O, P, true);
      metadataMap.set(MetadataKey, MetadataValue);
    }
    function OrdinaryMetadataKeys(O, P) {
      var ownKeys = OrdinaryOwnMetadataKeys(O, P);
      var parent = OrdinaryGetPrototypeOf(O);
      if (parent === null)
        return ownKeys;
      var parentKeys = OrdinaryMetadataKeys(parent, P);
      if (parentKeys.length <= 0)
        return ownKeys;
      if (ownKeys.length <= 0)
        return parentKeys;
      var set = new _Set();
      var keys = [];
      for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
        var key = ownKeys_1[_i];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
        var key = parentKeys_1[_a];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      return keys;
    }
    function OrdinaryOwnMetadataKeys(O, P) {
      var keys = [];
      var metadataMap = GetOrCreateMetadataMap(O, P, false);
      if (IsUndefined(metadataMap))
        return keys;
      var keysObj = metadataMap.keys();
      var iterator = GetIterator(keysObj);
      var k = 0;
      while (true) {
        var next = IteratorStep(iterator);
        if (!next) {
          keys.length = k;
          return keys;
        }
        var nextValue = IteratorValue(next);
        try {
          keys[k] = nextValue;
        } catch (e) {
          try {
            IteratorClose(iterator);
          } finally {
            throw e;
          }
        }
        k++;
      }
    }
    function Type(x) {
      if (x === null)
        return 1;
      switch (typeof x) {
        case "undefined":
          return 0;
        case "boolean":
          return 2;
        case "string":
          return 3;
        case "symbol":
          return 4;
        case "number":
          return 5;
        case "object":
          return x === null ? 1 : 6;
        default:
          return 6;
      }
    }
    function IsUndefined(x) {
      return x === void 0;
    }
    function IsNull(x) {
      return x === null;
    }
    function IsSymbol(x) {
      return typeof x === "symbol";
    }
    function IsObject(x) {
      return typeof x === "object" ? x !== null : typeof x === "function";
    }
    function ToPrimitive(input, PreferredType) {
      switch (Type(input)) {
        case 0:
          return input;
        case 1:
          return input;
        case 2:
          return input;
        case 3:
          return input;
        case 4:
          return input;
        case 5:
          return input;
      }
      var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
      var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
      if (exoticToPrim !== void 0) {
        var result = exoticToPrim.call(input, hint);
        if (IsObject(result))
          throw new TypeError();
        return result;
      }
      return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
    }
    function OrdinaryToPrimitive(O, hint) {
      if (hint === "string") {
        var toString_1 = O.toString;
        if (IsCallable(toString_1)) {
          var result = toString_1.call(O);
          if (!IsObject(result))
            return result;
        }
        var valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O);
          if (!IsObject(result))
            return result;
        }
      } else {
        var valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O);
          if (!IsObject(result))
            return result;
        }
        var toString_2 = O.toString;
        if (IsCallable(toString_2)) {
          var result = toString_2.call(O);
          if (!IsObject(result))
            return result;
        }
      }
      throw new TypeError();
    }
    function ToBoolean(argument) {
      return !!argument;
    }
    function ToString(argument) {
      return "" + argument;
    }
    function ToPropertyKey(argument) {
      var key = ToPrimitive(argument, 3);
      if (IsSymbol(key))
        return key;
      return ToString(key);
    }
    function IsArray(argument) {
      return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
    }
    function IsCallable(argument) {
      return typeof argument === "function";
    }
    function IsConstructor(argument) {
      return typeof argument === "function";
    }
    function IsPropertyKey(argument) {
      switch (Type(argument)) {
        case 3:
          return true;
        case 4:
          return true;
        default:
          return false;
      }
    }
    function GetMethod(V, P) {
      var func = V[P];
      if (func === void 0 || func === null)
        return void 0;
      if (!IsCallable(func))
        throw new TypeError();
      return func;
    }
    function GetIterator(obj) {
      var method = GetMethod(obj, iteratorSymbol);
      if (!IsCallable(method))
        throw new TypeError();
      var iterator = method.call(obj);
      if (!IsObject(iterator))
        throw new TypeError();
      return iterator;
    }
    function IteratorValue(iterResult) {
      return iterResult.value;
    }
    function IteratorStep(iterator) {
      var result = iterator.next();
      return result.done ? false : result;
    }
    function IteratorClose(iterator) {
      var f = iterator["return"];
      if (f)
        f.call(iterator);
    }
    function OrdinaryGetPrototypeOf(O) {
      var proto = Object.getPrototypeOf(O);
      if (typeof O !== "function" || O === functionPrototype)
        return proto;
      if (proto !== functionPrototype)
        return proto;
      var prototype = O.prototype;
      var prototypeProto = prototype && Object.getPrototypeOf(prototype);
      if (prototypeProto == null || prototypeProto === Object.prototype)
        return proto;
      var constructor = prototypeProto.constructor;
      if (typeof constructor !== "function")
        return proto;
      if (constructor === O)
        return proto;
      return constructor;
    }
    function CreateMapPolyfill() {
      var cacheSentinel = {};
      var arraySentinel = [];
      var MapIterator = function() {
        function MapIterator2(keys, values, selector) {
          this._index = 0;
          this._keys = keys;
          this._values = values;
          this._selector = selector;
        }
        MapIterator2.prototype["@@iterator"] = function() {
          return this;
        };
        MapIterator2.prototype[iteratorSymbol] = function() {
          return this;
        };
        MapIterator2.prototype.next = function() {
          var index = this._index;
          if (index >= 0 && index < this._keys.length) {
            var result = this._selector(this._keys[index], this._values[index]);
            if (index + 1 >= this._keys.length) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            } else {
              this._index++;
            }
            return { value: result, done: false };
          }
          return { value: void 0, done: true };
        };
        MapIterator2.prototype.throw = function(error) {
          if (this._index >= 0) {
            this._index = -1;
            this._keys = arraySentinel;
            this._values = arraySentinel;
          }
          throw error;
        };
        MapIterator2.prototype.return = function(value) {
          if (this._index >= 0) {
            this._index = -1;
            this._keys = arraySentinel;
            this._values = arraySentinel;
          }
          return { value, done: true };
        };
        return MapIterator2;
      }();
      return function() {
        function Map2() {
          this._keys = [];
          this._values = [];
          this._cacheKey = cacheSentinel;
          this._cacheIndex = -2;
        }
        Object.defineProperty(Map2.prototype, "size", {
          get: function() {
            return this._keys.length;
          },
          enumerable: true,
          configurable: true
        });
        Map2.prototype.has = function(key) {
          return this._find(key, false) >= 0;
        };
        Map2.prototype.get = function(key) {
          var index = this._find(key, false);
          return index >= 0 ? this._values[index] : void 0;
        };
        Map2.prototype.set = function(key, value) {
          var index = this._find(key, true);
          this._values[index] = value;
          return this;
        };
        Map2.prototype.delete = function(key) {
          var index = this._find(key, false);
          if (index >= 0) {
            var size = this._keys.length;
            for (var i = index + 1; i < size; i++) {
              this._keys[i - 1] = this._keys[i];
              this._values[i - 1] = this._values[i];
            }
            this._keys.length--;
            this._values.length--;
            if (key === this._cacheKey) {
              this._cacheKey = cacheSentinel;
              this._cacheIndex = -2;
            }
            return true;
          }
          return false;
        };
        Map2.prototype.clear = function() {
          this._keys.length = 0;
          this._values.length = 0;
          this._cacheKey = cacheSentinel;
          this._cacheIndex = -2;
        };
        Map2.prototype.keys = function() {
          return new MapIterator(this._keys, this._values, getKey);
        };
        Map2.prototype.values = function() {
          return new MapIterator(this._keys, this._values, getValue);
        };
        Map2.prototype.entries = function() {
          return new MapIterator(this._keys, this._values, getEntry);
        };
        Map2.prototype["@@iterator"] = function() {
          return this.entries();
        };
        Map2.prototype[iteratorSymbol] = function() {
          return this.entries();
        };
        Map2.prototype._find = function(key, insert) {
          if (this._cacheKey !== key) {
            this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
          }
          if (this._cacheIndex < 0 && insert) {
            this._cacheIndex = this._keys.length;
            this._keys.push(key);
            this._values.push(void 0);
          }
          return this._cacheIndex;
        };
        return Map2;
      }();
      function getKey(key, _) {
        return key;
      }
      function getValue(_, value) {
        return value;
      }
      function getEntry(key, value) {
        return [key, value];
      }
    }
    function CreateSetPolyfill() {
      return function() {
        function Set2() {
          this._map = new _Map();
        }
        Object.defineProperty(Set2.prototype, "size", {
          get: function() {
            return this._map.size;
          },
          enumerable: true,
          configurable: true
        });
        Set2.prototype.has = function(value) {
          return this._map.has(value);
        };
        Set2.prototype.add = function(value) {
          return this._map.set(value, value), this;
        };
        Set2.prototype.delete = function(value) {
          return this._map.delete(value);
        };
        Set2.prototype.clear = function() {
          this._map.clear();
        };
        Set2.prototype.keys = function() {
          return this._map.keys();
        };
        Set2.prototype.values = function() {
          return this._map.values();
        };
        Set2.prototype.entries = function() {
          return this._map.entries();
        };
        Set2.prototype["@@iterator"] = function() {
          return this.keys();
        };
        Set2.prototype[iteratorSymbol] = function() {
          return this.keys();
        };
        return Set2;
      }();
    }
    function CreateWeakMapPolyfill() {
      var UUID_SIZE = 16;
      var keys = HashMap.create();
      var rootKey = CreateUniqueKey();
      return function() {
        function WeakMap2() {
          this._key = CreateUniqueKey();
        }
        WeakMap2.prototype.has = function(target) {
          var table = GetOrCreateWeakMapTable(target, false);
          return table !== void 0 ? HashMap.has(table, this._key) : false;
        };
        WeakMap2.prototype.get = function(target) {
          var table = GetOrCreateWeakMapTable(target, false);
          return table !== void 0 ? HashMap.get(table, this._key) : void 0;
        };
        WeakMap2.prototype.set = function(target, value) {
          var table = GetOrCreateWeakMapTable(target, true);
          table[this._key] = value;
          return this;
        };
        WeakMap2.prototype.delete = function(target) {
          var table = GetOrCreateWeakMapTable(target, false);
          return table !== void 0 ? delete table[this._key] : false;
        };
        WeakMap2.prototype.clear = function() {
          this._key = CreateUniqueKey();
        };
        return WeakMap2;
      }();
      function CreateUniqueKey() {
        var key;
        do
          key = "@@WeakMap@@" + CreateUUID();
        while (HashMap.has(keys, key));
        keys[key] = true;
        return key;
      }
      function GetOrCreateWeakMapTable(target, create) {
        if (!hasOwn.call(target, rootKey)) {
          if (!create)
            return void 0;
          Object.defineProperty(target, rootKey, { value: HashMap.create() });
        }
        return target[rootKey];
      }
      function FillRandomBytes(buffer, size) {
        for (var i = 0; i < size; ++i)
          buffer[i] = Math.random() * 255 | 0;
        return buffer;
      }
      function GenRandomBytes(size) {
        if (typeof Uint8Array === "function") {
          if (typeof crypto !== "undefined")
            return crypto.getRandomValues(new Uint8Array(size));
          if (typeof msCrypto !== "undefined")
            return msCrypto.getRandomValues(new Uint8Array(size));
          return FillRandomBytes(new Uint8Array(size), size);
        }
        return FillRandomBytes(new Array(size), size);
      }
      function CreateUUID() {
        var data = GenRandomBytes(UUID_SIZE);
        data[6] = data[6] & 79 | 64;
        data[8] = data[8] & 191 | 128;
        var result = "";
        for (var offset = 0; offset < UUID_SIZE; ++offset) {
          var byte = data[offset];
          if (offset === 4 || offset === 6 || offset === 8)
            result += "-";
          if (byte < 16)
            result += "0";
          result += byte.toString(16).toLowerCase();
        }
        return result;
      }
    }
    function MakeDictionary(obj) {
      obj.__ = void 0;
      delete obj.__;
      return obj;
    }
  });
})(Reflect2 || (Reflect2 = {}));

// src/inversify.config.ts
var import_inversify4 = __toESM(require_inversify());

// src/types.ts
var TYPES = {
  Logger: Symbol.for("Logger"),
  Python: Symbol.for("Python"),
  Configuration: Symbol.for("Configuration"),
  Esbonio: Symbol.for("Esbonio"),
  FolderStatus: Symbol.for("FolderStatus"),
  FileStatus: Symbol.for("FileStatus"),
  FileSelector: Symbol.for("FileSelector"),
  PreviewContext: Symbol.for("PreviewContext"),
  RstEngine: Symbol.for("RstEngine"),
  ContentProvider: Symbol.for("ContentProvider"),
  PreviewManager: Symbol.for("PreviewManager"),
  Policy: Symbol.for("Policy"),
  SecuritySelector: Symbol.for("SecuritySelector"),
  SingleFolder: Symbol.for("SingleFolder")
};
var NAMES = {
  Lsp: Symbol.for("Lsp"),
  Main: Symbol.for("Main")
};

// src/util/logger.ts
var vscode6 = __toESM(require("vscode"));
var import_inversify = __toESM(require_inversify());
var Rollbar = require_rollbar2();
var si = require_lib();
var Trace = /* @__PURE__ */ ((Trace2) => {
  Trace2[Trace2["Off"] = 0] = "Off";
  Trace2[Trace2["Verbose"] = 1] = "Verbose";
  return Trace2;
})(Trace || {});
((Trace2) => {
  function fromString(value) {
    value = value.toLowerCase();
    switch (value) {
      case "off":
        return 0 /* Off */;
      case "verbose":
        return 1 /* Verbose */;
      default:
        return 0 /* Off */;
    }
  }
  Trace2.fromString = fromString;
})(Trace || (Trace = {}));
function isString(value) {
  return Object.prototype.toString.call(value) === "[object String]";
}
var ConsoleLogger = class {
  constructor(name) {
    this.outputChannel = vscode6.window.createOutputChannel(name);
    this.updateConfiguration();
    this.rollbar = new Rollbar({
      accessToken: "ae7bc72e09184fb4aa1ea1c4a3cfb705",
      captureUncaught: false,
      captureUnhandledRejections: false
    });
  }
  error(message) {
    this.log(message);
  }
  info(message) {
    this.log(message);
  }
  debug(message) {
    this.log(message);
  }
  warning(message) {
    this.log(message);
  }
  collect(version, platform) {
    this.rollbar.log(version, { details: platform });
  }
  log(message, data) {
    if (this.trace === 1 /* Verbose */) {
      this.appendLine(
        `[Log - ${new Date().toLocaleTimeString()}] ${message}`
      );
      if (data) {
        this.appendLine(ConsoleLogger.data2String(data));
      }
    }
  }
  updateConfiguration() {
    this.trace = this.readTrace();
  }
  appendLine(value = "") {
    return this.outputChannel.appendLine(value);
  }
  append(value) {
    return this.outputChannel.append(value);
  }
  show() {
    this.outputChannel.show();
  }
  readTrace() {
    return Trace.fromString(
      vscode6.workspace.getConfiguration().get("restructuredtext.trace", "off")
    );
  }
  static data2String(data) {
    if (data instanceof Error) {
      if (isString(data.stack)) {
        return data.stack;
      }
      return data.message;
    }
    if (isString(data)) {
      return data;
    }
    return JSON.stringify(data, void 0, 2);
  }
  async logPlatform(version) {
    const result = await si.osInfo();
    const platform = result.platform;
    const release = result.release;
    const dist = result.distro;
    const arch = result.arch;
    this.log(`OS is ${platform} ${release} ${dist} ${arch}`);
    this.collect(version, `${platform} ${release} ${dist} ${arch}`);
  }
};
ConsoleLogger = __decorateClass([
  (0, import_inversify.injectable)()
], ConsoleLogger);

// src/util/python.ts
var import_inversify2 = __toESM(require_inversify());
var import_child_process = require("child_process");
var vscode7 = __toESM(require("vscode"));
var Python = class {
  constructor(logger, configuration2) {
    this.logger = logger;
    this.configuration = configuration2;
    this.version = null;
    this.ready = false;
  }
  isReady() {
    return this.ready;
  }
  async setup(resource) {
    if (await this.checkPython(resource)) {
      this.ready = true;
    }
  }
  async checkPython(resource, showInformation = true) {
    const path3 = await this.configuration.getPythonPath(resource);
    if (path3) {
      this.pythonPath = `"${path3}"`;
      if (await this.getVersion()) {
        return true;
      }
    }
    this.logger.error("Cannot find Python.");
    if (showInformation) {
      const choice = await vscode7.window.showErrorMessage(
        "Please review Python installation on this machine before using this extension.",
        "Learn more..."
      );
      if (choice === "Learn more...") {
        vscode7.commands.executeCommand(
          "vscode.open",
          vscode7.Uri.parse(
            "https://docs.restructuredtext.net/articles/prerequisites.html#install-python-for-most-features"
          )
        );
      }
    }
    return false;
  }
  async installDoc8() {
    try {
      await this.exec("-m", "pip", "install", "doc8");
      this.logger.info("Finished installing doc8");
      vscode7.window.showInformationMessage(
        "The linter doc8 is installed."
      );
    } catch (e) {
      this.logger.error("Failed to install doc8");
      vscode7.window.showErrorMessage(
        "Could not install doc8. Please run `pip install doc8` to use this linter, or check your Python path."
      );
    }
  }
  async checkDoc8Install() {
    try {
      await this.exec("-c", '"import doc8.main;"');
      return true;
    } catch (e) {
      return false;
    }
  }
  async installRstCheck() {
    try {
      await this.exec("-m", "pip", "install", "rstcheck");
      this.logger.info("Finished installing rstcheck");
      vscode7.window.showInformationMessage(
        "The linter rstcheck is installed."
      );
    } catch (e) {
      this.logger.error("Failed to install rstcheck");
      vscode7.window.showErrorMessage(
        "Could not install rstcheck. Please run `pip install rstcheck` to use this linter, or check your Python path."
      );
    }
  }
  async checkRstCheckInstall() {
    try {
      await this.exec("-c", '"import rstcheck;"');
      return true;
    } catch (e) {
      return false;
    }
  }
  async installRstLint() {
    try {
      await this.exec("-m", "pip", "install", "restructuredtext_lint");
      this.logger.info("Finished installing restructuredtext_lint");
      vscode7.window.showInformationMessage(
        "The linter restructuredtext_lint is installed."
      );
    } catch (e) {
      this.logger.error("Failed to install restructuredtext_lint");
      vscode7.window.showErrorMessage(
        "Could not install restructuredtext_lint. Please run `pip install restructuredtext_lint` to use this linter, or check your Python path."
      );
    }
  }
  async checkRstLintInstall() {
    try {
      await this.exec("-c", '"import restructuredtext_lint;"');
      return true;
    } catch (e) {
      return false;
    }
  }
  async getVersion() {
    if (this.version !== null) {
      return true;
    }
    try {
      const version = await this.exec(
        "-c",
        '"import sys; print(sys.version_info[0])"'
      );
      switch (Number.parseInt(version)) {
        case 2:
          this.version = 2;
          return true;
        case 3:
          this.version = 3;
          return true;
      }
    } catch (e) {
    }
    return false;
  }
  exec(...args) {
    const cmd = [this.pythonPath, ...args];
    return new Promise((resolve, reject) => {
      this.logger.info(
        `Running cmd: ${this.pythonPath} ${args.join(" ")}`
      );
      (0, import_child_process.exec)(
        cmd.join(" "),
        (error, stdout, stderr) => {
          if (error) {
            const errorMessage = [
              error.name,
              error.message,
              error.stack,
              "",
              stderr.toString()
            ].join("\n");
            this.logger.error(errorMessage);
            reject(errorMessage);
          } else {
            this.logger.info("Successful exec");
            resolve(stdout.toString());
          }
        }
      );
    });
  }
};
Python = __decorateClass([
  (0, import_inversify2.injectable)(),
  __decorateParam(0, (0, import_inversify2.inject)(TYPES.Logger)),
  __decorateParam(0, (0, import_inversify2.named)(NAMES.Main)),
  __decorateParam(1, (0, import_inversify2.inject)(TYPES.Configuration))
], Python);

// src/util/configuration.ts
var import_inversify3 = __toESM(require_inversify());
var import_vscode = require("vscode");

// src/util/stateUtils.ts
var vscode8 = require("vscode");
var globalState;
var workspaceState;
function setGlobalState(state) {
  globalState = state;
}
function getFromWorkspaceState(key, defaultValue) {
  if (!workspaceState) {
    return defaultValue;
  }
  return workspaceState.get(key, defaultValue);
}
function updateWorkspaceState(key, value) {
  if (!workspaceState) {
    return;
  }
  return workspaceState.update(key, value);
}
function setWorkspaceState(state) {
  workspaceState = state;
}

// src/util/config.ts
var vscode9 = require("vscode");
var WORKSPACE_IS_TRUSTED_KEY = "WORKSPACE_IS_TRUSTED_KEY";
var SECURITY_SENSITIVE_CONFIG = [
  "linter.doc8.executablePath",
  "linter.rstcheck.executablePath",
  "linter.rst-lint.executablePath"
];
async function initConfig(ctx) {
  const isTrusted = getFromWorkspaceState(WORKSPACE_IS_TRUSTED_KEY, false);
  if (isTrusted !== defaultConfig.workspaceIsTrusted()) {
    defaultConfig.toggleWorkspaceIsTrusted();
  }
  ctx.subscriptions.push(
    vscode9.commands.registerCommand(
      "restructuredtext.workspace.isTrusted.toggle",
      toggleWorkspaceIsTrusted
    )
  );
  if (isTrusted) {
    return;
  }
  const ignored = ignoredWorkspaceConfig(
    vscode9.workspace.getConfiguration("restructuredtext"),
    SECURITY_SENSITIVE_CONFIG
  );
  if (ignored.length === 0) {
    return;
  }
  const ignoredSettings = ignored.map((x) => `"restructuredtext.${x}"`).join(",");
  const val = await vscode9.window.showWarningMessage(
    `Some workspace/folder-level settings (${ignoredSettings}) from the untrusted workspace are disabled by default. If this workspace is trusted, explicitly enable the workspace/folder-level settings by running the "reStructuredText: Toggle Workspace Trust Flag" command.`,
    "OK",
    "Trust This Workspace",
    "More Info"
  );
  switch (val) {
    case "Trust This Workspace":
      await toggleWorkspaceIsTrusted();
      break;
    case "More Info":
      vscode9.env.openExternal(
        vscode9.Uri.parse(
          "https://docs.restructuredtext.net/articles/configuration.html#security"
        )
      );
      break;
    default:
      break;
  }
}
function ignoredWorkspaceConfig(cfg, keys) {
  return keys.filter((key) => {
    const inspect = cfg.inspect(key);
    return inspect.workspaceValue !== void 0 || inspect.workspaceFolderValue !== void 0;
  });
}
async function toggleWorkspaceIsTrusted() {
  const v = defaultConfig.toggleWorkspaceIsTrusted();
  await updateWorkspaceState(WORKSPACE_IS_TRUSTED_KEY, v);
}
var Configuration = class {
  constructor(_workspaceIsTrusted = false, getConfiguration = vscode9.workspace.getConfiguration) {
    this._workspaceIsTrusted = _workspaceIsTrusted;
    this.getConfiguration = getConfiguration;
  }
  toggleWorkspaceIsTrusted() {
    this._workspaceIsTrusted = !this._workspaceIsTrusted;
    return this._workspaceIsTrusted;
  }
  get(section, uri) {
    const cfg = this.getConfiguration(section, uri);
    if (section !== "restructuredtext" || this._workspaceIsTrusted) {
      return cfg;
    }
    return new WrappedConfiguration(cfg);
  }
  workspaceIsTrusted() {
    return this._workspaceIsTrusted;
  }
};
var defaultConfig = new Configuration();
var WrappedConfiguration = class {
  constructor(_wrapped) {
    this._wrapped = _wrapped;
    const desc = Object.getOwnPropertyDescriptors(_wrapped);
    for (const prop in desc) {
      if (typeof prop === "string" && !["get", "has", "inspect", "update", "_wrapped"].includes(prop)) {
        const d = desc[prop];
        if (SECURITY_SENSITIVE_CONFIG.includes(prop)) {
          const inspect = this._wrapped.inspect(prop);
          d.value = inspect.globalValue ?? inspect.defaultValue;
        }
        Object.defineProperty(this, prop, desc[prop]);
      }
    }
  }
  get(section, defaultValue) {
    if (SECURITY_SENSITIVE_CONFIG.includes(section)) {
      const inspect = this._wrapped.inspect(section);
      return inspect.globalValue ?? defaultValue ?? inspect.defaultValue;
    }
    return this._wrapped.get(section, defaultValue);
  }
  has(section) {
    return this._wrapped.has(section);
  }
  inspect(section) {
    return this._wrapped.inspect(section);
  }
  update(section, value, configurationTarget, overrideInLanguage) {
    return this._wrapped.update(
      section,
      value,
      configurationTarget,
      overrideInLanguage
    );
  }
};
function getConfig(section, uri) {
  if (!uri) {
    if (vscode9.window.activeTextEditor) {
      uri = vscode9.window.activeTextEditor.document.uri;
    } else {
      uri = null;
    }
  }
  return defaultConfig.get(section, uri);
}
var IsInCloudIDE = process.env.CLOUD_SHELL === "true" || process.env.CODESPACES === "true";

// src/constants.ts
var Constants = class {
};
Constants.python = "python";
Constants.shrinkLength = 32;
var Commands = {
  OPEN_PREVIEW: "esbonio.preview.open",
  OPEN_PREVIEW_TO_SIDE: "esbonio.preview.openSide",
  INSTALL_SERVER: "esbonio.server.install",
  RESTART_SERVER: "esbonio.server.restart",
  UPDATE_SERVER: "esbonio.server.update",
  RELOAD_WINDOW: "workbench.action.reloadWindow",
  OPEN_EXTENSION: "extension.open",
  INSTALL_EXTENSION: "workbench.extensions.installExtension",
  UNINSTALL_EXTENSION: "workbench.extensions.uninstallExtension"
};

// src/util/configuration.ts
var fs = require("fs");
var path2 = require("path");
var Configuration2 = class {
  getConflictingExtensions(resource) {
    return this.loadAnySetting(
      "conflictingExtensions",
      void 0,
      resource
    );
  }
  getRecommendedExtensions(resource) {
    return this.loadAnySetting(
      "recommendedExtensions",
      void 0,
      resource
    );
  }
  getDoc8Path(resource) {
    return this.loadSetting(
      "linter.doc8.executablePath",
      void 0,
      resource
    );
  }
  getDoc8ExtraArgs(resource) {
    return this.loadAnySetting(
      "linter.doc8.extraArgs",
      void 0,
      resource
    );
  }
  getRstCheckPath(resource) {
    return this.loadSetting(
      "linter.rstcheck.executablePath",
      void 0,
      resource
    );
  }
  getRstCheckExtraArgs(resource) {
    return this.loadAnySetting(
      "linter.rstcheck.extraArgs",
      void 0,
      resource
    );
  }
  getRstLintPath(resource) {
    return this.loadSetting(
      "linter.rst-lint.executablePath",
      void 0,
      resource
    );
  }
  getRstLintExtraArgs(resource) {
    return this.loadAnySetting(
      "linter.rst-lint.extraArgs",
      void 0,
      resource
    );
  }
  getTelemetryDisabled(resource) {
    return this.loadAnySetting("telemetry.disabled", false, resource);
  }
  getRunType(resource) {
    return this.loadAnySetting("linter.run", "onType", resource);
  }
  async getPythonPath(resource) {
    try {
      const extension = import_vscode.extensions.getExtension("ms-python.python");
      if (!extension) {
        return Constants.python;
      }
      const usingNewInterpreterStorage = extension.packageJSON?.featureFlags?.usingNewInterpreterStorage;
      if (usingNewInterpreterStorage) {
        if (!extension.isActive) {
          await extension.activate();
        }
        const pythonPath = extension.exports.settings.getExecutionDetails(resource).execCommand[0];
        return pythonPath;
      } else {
        return this.getConfiguration("python", resource).get(
          "pythonPath"
        ) ?? Constants.python;
      }
    } catch (error) {
      return Constants.python;
    }
  }
  getConfiguration(section, resource) {
    if (resource) {
      return import_vscode.workspace.getConfiguration(section, resource);
    } else {
      return import_vscode.workspace.getConfiguration(section);
    }
  }
  getPythonPath2(resource) {
    const primary = this.loadSetting(
      "pythonPath",
      "python3",
      resource,
      true,
      "python"
    );
    if (primary) {
      const workspaceRoot = this.getRootPath(resource);
      if (workspaceRoot) {
        const optional = path2.join(workspaceRoot, primary);
        if (fs.existsSync(optional)) {
          return optional;
        }
      }
    }
    return primary;
  }
  getLinterDisabled(resource) {
    return this.loadAnySetting(
      "linter.disabledLinters",
      [],
      resource
    );
  }
  getTableEditorDisabled(resource) {
    return this.loadAnySetting(
      "editor.tableEditor.disabled",
      false,
      resource
    );
  }
  getTableEditorReformatDisabled(resource) {
    return this.loadAnySetting(
      "editor.tableEditor.reformat.disabled",
      false,
      resource
    );
  }
  getAdornments(resource) {
    return this.loadAnySetting(
      "editor.sectionEditor.adornments",
      "#*=-^\"'`:.~_+",
      resource
    );
  }
  getPythonRecommendationDisabled(resource) {
    return this.loadAnySetting(
      "pythonRecommendation.disabled",
      false,
      resource
    );
  }
  async setPythonRecommendationDisabled(resource) {
    await this.saveAnySetting(
      "pythonRecommendation.disabled",
      true,
      resource
    );
  }
  loadAnySetting(configSection, defaultValue, resource, header = "restructuredtext") {
    if (defaultValue) {
      return getConfig(header, resource).get(configSection, defaultValue);
    }
    return getConfig(header, resource).get(configSection);
  }
  async saveAnySetting(configSection, value, resource, header = "restructuredtext") {
    if (import_vscode.workspace.workspaceFolders) {
      await getConfig(header, resource).update(configSection, value);
      return value;
    }
    return void 0;
  }
  loadSetting(configSection, defaultValue, resource, expand = true, header = "restructuredtext") {
    const result = this.loadAnySetting(
      configSection,
      defaultValue,
      resource,
      header
    );
    if (expand && result) {
      return this.expandMacro(result, resource);
    }
    return result;
  }
  expandMacro(input, resource) {
    if (input.indexOf("${") === -1) {
      return input;
    }
    let expanded;
    if (input.indexOf("${env:") > -1) {
      expanded = input.replace(/\$\{env:(.+)\}/, (_match, p1) => {
        const variable = process.env[p1];
        return variable ?? "";
      });
    } else {
      expanded = input;
    }
    if (expanded.indexOf("${") > -1) {
      const path3 = this.getRootPath(resource);
      if (path3) {
        return expanded.replace("${workspaceRoot}", path3).replace("${workspaceFolder}", path3);
      }
    }
    return expanded;
  }
  getRootPath(resource) {
    if (!import_vscode.workspace.workspaceFolders) {
      return import_vscode.workspace.rootPath ?? (resource ? path2.dirname(resource.fsPath) : void 0);
    }
    let root;
    if (import_vscode.workspace.workspaceFolders.length === 1) {
      root = import_vscode.workspace.workspaceFolders[0];
    } else {
      if (!resource) {
        return void 0;
      }
      root = import_vscode.workspace.getWorkspaceFolder(resource);
    }
    return root?.uri.fsPath;
  }
};
Configuration2 = __decorateClass([
  (0, import_inversify3.injectable)()
], Configuration2);

// src/inversify.config.ts
var import_vscode2 = require("vscode");
var container = new import_inversify4.Container();
var folders = import_vscode2.workspace.workspaceFolders;
var singleFolder = folders?.length === 1;
var main = new ConsoleLogger("reStructuredText");
container.bind(TYPES.Logger).toConstantValue(main).whenTargetNamed(NAMES.Main);
var lsp = new ConsoleLogger("Esbonio Language Server");
container.bind(TYPES.Logger).toConstantValue(lsp).whenTargetNamed(NAMES.Lsp);
container.bind(TYPES.Configuration).to(Configuration2).inSingletonScope();
container.bind(TYPES.Python).to(Python).inSingletonScope();
container.bind(TYPES.SingleFolder).toConstantValue(singleFolder);
var inversify_config_default = container;

// src/editor/tableEditor.ts
var TableEditor = class {
  constructor(editor) {
    this.editor = editor;
    this.tableLineNumbers = tableIsSelected(this.editor);
    this.tableRange = this._tableRange();
    this.selectedCellPosition = this.selectedCellColumn();
  }
  async reformat() {
    const configuration2 = inversify_config_default.get(TYPES.Configuration);
    if (configuration2.getTableEditorReformatDisabled()) {
      return;
    }
    this.tableLineNumbers = tableIsSelected(this.editor);
    const cellContents = this._getCellContents();
    const hasHeader = this._hasHeader();
    const insertText = this._generateTableString(cellContents, hasHeader);
    const editOptions = { undoStopBefore: false, undoStopAfter: false };
    await this.editor.edit((editBuilder) => {
      const tableRange = this._tableRange();
      editBuilder.replace(tableRange, insertText);
    }, editOptions);
  }
  async createEmptyGrid() {
    let [row, column] = tableSizeIsSelected(this.editor);
    const inputResult = await vscode10.window.showQuickPick([
      "With Header",
      "Without Header"
    ]);
    if (!inputResult) {
      return;
    }
    const header = inputResult === "With Header";
    if (header) {
      row += 1;
    }
    const contentsLine = new Array(column).fill("");
    const cellContents = new Array(row).fill(contentsLine);
    const insertText = this._generateTableString(cellContents, header);
    const curLine = this.editor.selection.start.line;
    const curLineRange = this.editor.document.lineAt(curLine).range;
    const editOptions = { undoStopBefore: false, undoStopAfter: false };
    await this.editor.edit((editBuilder) => {
      editBuilder.replace(curLineRange, insertText);
    }, editOptions);
    const newPos = new vscode10.Position(curLine + 1, 2);
    this.editor.selection = new vscode10.Selection(newPos, newPos);
  }
  async dataToTable() {
    if (this.editor.selection.isEmpty) {
      return;
    }
    const selection = this.editor.selection;
    const startPos = new vscode10.Position(selection.start.line, 0);
    const endLine = selection.end.line;
    const endLastChar = this.editor.document.lineAt(endLine).range.end.character;
    const endPos = new vscode10.Position(endLine, endLastChar);
    const data = this.editor.document.getText(
      new vscode10.Range(startPos, endPos)
    );
    const dataLines = data.split(/\r\n|\r|\n/);
    const cellContents = [];
    for (let i = 0; i < dataLines.length; i++) {
      const dataLine = dataLines[i];
      const contents = dataLine.split(",");
      cellContents.push([]);
      for (let j = 0; j < contents.length; j++) {
        let content = contents[j];
        content = content.trim();
        content = content.replace(/(\s)\s*/g, "$1");
        cellContents[i].push(content);
      }
    }
    const inputResult = await vscode10.window.showQuickPick([
      "With Header",
      "Without Header"
    ]);
    if (!inputResult) {
      return;
    }
    const header = inputResult === "With Header";
    const insertText = this._generateTableString(cellContents, header);
    const editOptions = { undoStopBefore: false, undoStopAfter: false };
    await this.editor.edit((editBuilder) => {
      editBuilder.replace(new vscode10.Range(startPos, endPos), insertText);
    }, editOptions);
    const newPos = new vscode10.Position(startPos.line + 1, 2);
    this.editor.selection = new vscode10.Selection(newPos, newPos);
  }
  _generateTableString(cellContents, header) {
    const cellStrLengthList = [];
    for (let i = 0; i < cellContents.length; i++) {
      for (let j = 0; j < cellContents[i].length; j++) {
        if (j > cellStrLengthList.length - 1) {
          cellStrLengthList.push(3);
        }
        const content = cellContents[i][j];
        const rows = content.split(/\r\n|\r|\n/);
        for (let k = 0; k < rows.length; k++) {
          const row = rows[k];
          let strCount = countTextWidth(row);
          if (rows.length > 1) {
            strCount -= 1;
          }
          cellStrLengthList[j] = Math.max(
            cellStrLengthList[j],
            strCount
          );
        }
      }
    }
    let gridRow = "";
    let headerRow = "";
    for (let i = 0; i < cellStrLengthList.length; i++) {
      const width = cellStrLengthList[i] + 2;
      gridRow += `+${"-".repeat(width)}`;
      headerRow += `+${"=".repeat(width)}`;
    }
    gridRow += "+";
    headerRow += "+";
    const insertTextLines = [];
    for (let i = 0; i < cellContents.length; i++) {
      if (i === 0) {
        insertTextLines.push(gridRow);
      }
      const multiLineCell = [];
      const columnContents = cellContents[i];
      for (let columnIndex = 0; columnIndex < columnContents.length; columnIndex++) {
        const cellText = columnContents[columnIndex];
        const cellTextSplit = cellText.split(/\r\n|\r|\n/);
        if (columnIndex === 0) {
          for (let j = 0; j < cellTextSplit.length; j++) {
            multiLineCell.push([]);
          }
        }
        for (let lineIndex = 0; lineIndex < cellTextSplit.length; lineIndex++) {
          const contentLine = cellTextSplit[lineIndex];
          multiLineCell[lineIndex].push(contentLine);
        }
      }
      for (let lineIndex = 0; lineIndex < multiLineCell.length; lineIndex++) {
        let cellRow = "";
        const lineTextList = multiLineCell[lineIndex];
        for (let columnIndex = 0; columnIndex < cellStrLengthList.length; columnIndex++) {
          const textMaxWidth = cellStrLengthList[columnIndex];
          const content = lineTextList[columnIndex];
          if (columnIndex < lineTextList.length) {
            const strCount = countTextWidth(content);
            const missingSpaces = `${" ".repeat(
              textMaxWidth - strCount + 1
            )}`;
            if (multiLineCell.length > 1) {
              cellRow += `|${content}${missingSpaces} `;
            } else {
              cellRow += `| ${content}${missingSpaces}`;
            }
          } else {
            cellRow += `|${" ".repeat(textMaxWidth + 2)}`;
          }
        }
        cellRow += "|";
        insertTextLines.push(cellRow);
      }
      if (i === 0 && header) {
        insertTextLines.push(headerRow);
      } else {
        insertTextLines.push(gridRow);
      }
    }
    return insertTextLines.join("\n");
  }
  _hasHeader() {
    if (!this.tableLineNumbers) {
      return false;
    }
    const regGridHeaderLine = /^\+=(=|\+)+=\+$/;
    for (let i = 0; i < this.tableLineNumbers.length; i++) {
      const tableLine = this.tableLineNumbers[i];
      let lineText = this.editor.document.lineAt(tableLine).text;
      lineText = lineText.trim();
      const gridHeaderLineMatch = regGridHeaderLine.exec(lineText);
      if (gridHeaderLineMatch) {
        return true;
      }
    }
    return false;
  }
  _getCellContents() {
    if (!this.tableLineNumbers) {
      return [];
    }
    const regContentsLine = /^(\+)?\|.+\|(\+)?$/;
    const regCellContents = /(?<=\|(\+|-)?([<>^v])*) (?<content>([^|]|(\*\|\*)|(`\|`))*?) (?=([<>^v])*(\+|-)?\|)/g;
    let curLineKind;
    const cellContents = [];
    for (let i = 0; i < this.tableLineNumbers.length; i++) {
      const tableLine = this.tableLineNumbers[i];
      let lineText = this.editor.document.lineAt(tableLine).text;
      lineText = lineText.trim();
      const contentsLine = regContentsLine.exec(lineText);
      if (!contentsLine) {
        curLineKind = void 0;
        continue;
      }
      if (curLineKind !== "contents") {
        cellContents.push([]);
      }
      let columnIndex = 0;
      let match;
      while (match = regCellContents.exec(lineText)) {
        if (!match?.groups) {
          continue;
        }
        let content = match.groups["content"];
        content = content.trim();
        content = content.replace(/(\s)\s*/g, "$1");
        if (curLineKind !== "contents") {
          cellContents[cellContents.length - 1].push(content);
        } else {
          let prevContent = cellContents[cellContents.length - 1][columnIndex];
          if (!prevContent) {
            prevContent = "| ";
          } else if (!prevContent.startsWith("|")) {
            prevContent = `| ${prevContent}`;
          }
          cellContents[cellContents.length - 1][columnIndex] = `${prevContent}
| ${content}`;
          columnIndex += 1;
        }
      }
      curLineKind = "contents";
    }
    return cellContents;
  }
  _tableRange() {
    if (this.tableLineNumbers) {
      const startPos = new vscode10.Position(this.tableLineNumbers[0], 0);
      const endLine = this.tableLineNumbers[this.tableLineNumbers.length - 1];
      const endLastChar = this.editor.document.lineAt(endLine).range.end.character;
      const endPos = new vscode10.Position(endLine, endLastChar);
      return new vscode10.Range(startPos, endPos);
    } else {
      const startPos = new vscode10.Position(0, 0);
      const endPos = new vscode10.Position(0, 0);
      return new vscode10.Range(startPos, endPos);
    }
  }
  isSelectedFirstGrid() {
    const curLine = this.editor.selection.start.line;
    const tableRange = this._tableRange();
    const tableStartLine = tableRange.start.line;
    return curLine === tableStartLine;
  }
  isSelectedLastGrid() {
    const curLine = this.editor.selection.end.line;
    const tableRange = this._tableRange();
    const tableLastLine = tableRange.end.line;
    return curLine === tableLastLine;
  }
  selectedCellColumn() {
    const curLine = this.editor.selection.start.line;
    const curChar = this.editor.selection.start.character;
    const lineText = this.editor.document.lineAt(curLine).text;
    const regContentsLine = /^\+?\|.+\|\+?$/;
    const regCellContents = /(?<=\|)(?<cell>(\+|-)?([<>v^])* .*? ([<>v^])*(\+|-)?)(?=\|)/g;
    let column = -1;
    let row = -1;
    if (!regContentsLine.exec(lineText) || !this.tableLineNumbers) {
      const selectedCell2 = {
        line: curLine,
        column,
        row
      };
      return selectedCell2;
    }
    let match;
    while (match = regCellContents.exec(lineText)) {
      if (!match?.groups) {
        continue;
      }
      column += 1;
      const matchIndex = match.index;
      const cellText = match.groups["cell"];
      const lastIndex = matchIndex + cellText.length;
      if (curChar <= lastIndex) {
        break;
      }
    }
    let curLineKind;
    for (let i = 0; i < this.tableLineNumbers.length; i++) {
      const lineNumber = this.tableLineNumbers[i];
      const lineText2 = this.editor.document.lineAt(lineNumber).text;
      if (!regContentsLine.exec(lineText2)) {
        curLineKind = void 0;
        continue;
      }
      if (!curLineKind) {
        row += 1;
        curLineKind = "contents";
      }
      if (lineNumber >= curLine) {
        break;
      }
    }
    const selectedCell = {
      line: curLine,
      column,
      row
    };
    return selectedCell;
  }
  selectCellContent(cellPosition, offset, offsetType) {
    if (!this.tableLineNumbers) {
      return;
    }
    let lineNumber = cellPosition.line;
    let rowIndex = cellPosition.row;
    let columnIndex = cellPosition.column;
    if (rowIndex === -1) {
      rowIndex = 0;
    }
    if (columnIndex === -1) {
      columnIndex = 0;
    }
    let curLine = lineNumber;
    if (offset === "top") {
      curLine -= 1;
      rowIndex -= 1;
    } else if (offset === "buttom") {
      curLine += 1;
      rowIndex += 1;
    } else if (offset === "right") {
      columnIndex += 1;
    } else if (offset === "left") {
      columnIndex -= 1;
    }
    let lineText = "";
    const regContentsLine = /^\|.+\|$/;
    if (offsetType === "cellIndex") {
      let curRowIndex = -1;
      let curLineKind;
      for (let i = 0; i < this.tableLineNumbers.length; i++) {
        const curLineNumber = this.tableLineNumbers[i];
        const lineText2 = this.editor.document.lineAt(curLineNumber).text;
        if (!regContentsLine.exec(lineText2)) {
          curLineKind = void 0;
          continue;
        }
        if (!curLineKind) {
          curRowIndex += 1;
          curLineKind = "contents";
        }
        if (curRowIndex >= rowIndex) {
          lineNumber = curLineNumber;
          break;
        }
      }
      lineText = this.editor.document.lineAt(lineNumber).text;
    } else {
      let matchedContentsLine = false;
      if (offset === "top" || offset === "buttom") {
        while (this.tableLineNumbers.includes(curLine)) {
          lineText = this.editor.document.lineAt(curLine).text;
          if (!regContentsLine.exec(lineText)) {
            if (offset === "top") {
              curLine -= 1;
            } else if (offset === "buttom") {
              curLine += 1;
            }
          } else {
            matchedContentsLine = true;
            lineNumber = curLine;
            break;
          }
        }
      }
      if (!matchedContentsLine) {
        lineText = this.editor.document.lineAt(lineNumber).text;
      }
    }
    const regCellContents = /(?<=\|)(?<cell> ([^|]|(\*\|\*)|(`\|`))* )(?=\|)/g;
    let curColumn = 0;
    let match;
    while (match = regCellContents.exec(lineText)) {
      if (curColumn >= columnIndex) {
        break;
      }
      curColumn += 1;
    }
    if (!match?.groups) {
      return;
    }
    const matchIndex = match.index;
    const cellText = match.groups["cell"];
    const regAllSpaces = /^(\s+)$/;
    const regWord = /^(\s*)(.*?)\s*$/;
    const allSpaceMatch = regAllSpaces.exec(cellText);
    const wordMatch = regWord.exec(cellText);
    let wordFirstIndex = 0;
    let wordLastIndex = 0;
    if (allSpaceMatch) {
      wordFirstIndex = matchIndex + 1;
      wordLastIndex = wordFirstIndex;
    } else if (wordMatch) {
      const cellSpeces = wordMatch[1];
      const cellWordText = wordMatch[2];
      wordFirstIndex = matchIndex + wordMatch.index + cellSpeces.length;
      wordLastIndex = wordFirstIndex + cellWordText.length;
    }
    const newPosStart = new vscode10.Position(lineNumber, wordFirstIndex);
    const newPosEnd = new vscode10.Position(lineNumber, wordLastIndex);
    this.editor.selection = new vscode10.Selection(newPosStart, newPosEnd);
  }
  async selectionChange(moveTo) {
    await this.reformat();
    this.selectCellContent(this.selectedCellPosition, moveTo);
  }
  async addNewLine() {
    const curLine = this.editor.selection.start.line;
    const curTextLine = this.editor.document.lineAt(curLine);
    const lineText = curTextLine.text;
    const lineEndPosition = curTextLine.range.end;
    const regCellContents = /(?<=\|)( .*? )(?=\|)/g;
    const emptyRow = lineText.replace(regCellContents, "   ");
    const insertText = `
${emptyRow}`;
    const editOptions = { undoStopBefore: false, undoStopAfter: false };
    await this.editor.edit((editBuilder) => {
      editBuilder.replace(lineEndPosition, insertText);
    }, editOptions);
    await this.reformat();
    this.selectCellContent(this.selectedCellPosition, "buttom");
  }
  async addRow() {
    if (!this.tableLineNumbers) {
      return;
    }
    const curLine = this.editor.selection.start.line;
    let startIndex = this.tableLineNumbers.indexOf(curLine);
    if (startIndex === -1) {
      return;
    } else if (startIndex === 0) {
      startIndex += 1;
    }
    const regGridLine = /^\+(-|=)(\1|\+)+\1\+$/;
    let insertRowLineNumber = startIndex;
    for (let i = startIndex; i < this.tableLineNumbers.length; i++) {
      const tableLine = this.tableLineNumbers[i];
      const lineText = this.editor.document.lineAt(tableLine).text;
      const gridLineMatch = regGridLine.exec(lineText);
      if (gridLineMatch) {
        insertRowLineNumber = this.tableLineNumbers[i];
        break;
      }
    }
    const cellContents = this._getCellContents();
    const hasHeader = this._hasHeader();
    const insertRowIndex = this.selectedCellPosition.row + 1;
    cellContents.splice(insertRowIndex, 0, [""]);
    const editOptions = { undoStopBefore: false, undoStopAfter: false };
    await this.editor.edit((editBuilder) => {
      const insertText = this._generateTableString(
        cellContents,
        hasHeader
      );
      const tableRange = this._tableRange();
      editBuilder.replace(tableRange, insertText);
    }, editOptions);
    this.tableLineNumbers = tableIsSelected(this.editor);
    this.selectedCellPosition.column = 0;
    this.selectedCellPosition.line = insertRowLineNumber;
    this.selectCellContent(
      this.selectedCellPosition,
      "buttom",
      "cellIndex"
    );
  }
  async removeRow() {
    await this.reformat();
    this.selectCellContent(this.selectedCellPosition);
  }
  async moveRow(moveTo) {
    if (!this.tableLineNumbers) {
      return;
    }
    const numOfTimesToMove = this._getNumberOfTimesToMove(moveTo);
    const cellContents = this._getCellContents();
    const hasHeader = this._hasHeader();
    const row_from = this.selectedCellPosition.row;
    let row_to = row_from + numOfTimesToMove;
    if (row_to < 0) {
      row_to = 0;
    } else if (row_to > cellContents.length - 1) {
      row_to = cellContents.length - 1;
    }
    const moveRowContents = cellContents[row_from];
    cellContents.splice(row_from, 1);
    cellContents.splice(row_to, 0, moveRowContents);
    const editOptions = { undoStopBefore: false, undoStopAfter: false };
    await this.editor.edit((editBuilder) => {
      const insertText = this._generateTableString(
        cellContents,
        hasHeader
      );
      const tableRange = this._tableRange();
      editBuilder.replace(tableRange, insertText);
    }, editOptions);
    this.selectedCellPosition.row = row_to;
    this.selectCellContent(this.selectedCellPosition);
  }
  async addColumn() {
    if (!this.tableLineNumbers) {
      return;
    }
    const addLastColumn = isSelectingLastChara();
    const curLine = this.editor.selection.start.line;
    const curLineText = this.editor.document.lineAt(curLine).text;
    const regContents = /(?<=\|)(\+?)( .*? )(\+?)(?=\|)/g;
    let match;
    let afterOperator;
    while (match = regContents.exec(curLineText)) {
      if (match[3]) {
        afterOperator = match[3];
        break;
      }
    }
    const cellContents = this._getCellContents();
    const hasHeader = this._hasHeader();
    const newLineCount = [];
    for (let i = 0; i < cellContents.length; i++) {
      newLineCount.push(0);
      const rowContents = cellContents[i];
      for (let j = 0; j < rowContents.length; j++) {
        const cellContent = rowContents[j];
        const lineCount = cellContent.split(/\r\n|\r|\n/).length;
        newLineCount[i] = Math.max(newLineCount[i], lineCount);
      }
    }
    let insertColumnIndex = this.selectedCellPosition.column;
    if (afterOperator || addLastColumn) {
      insertColumnIndex += 1;
    }
    for (let i = 0; i < cellContents.length; i++) {
      const rowContents = cellContents[i];
      if (newLineCount[i] > 1) {
        rowContents.splice(
          insertColumnIndex,
          0,
          `${"\n".repeat(newLineCount[i] - 1)}`
        );
      } else {
        rowContents.splice(insertColumnIndex, 0, "");
      }
    }
    const editOptions = { undoStopBefore: false, undoStopAfter: false };
    await this.editor.edit((editBuilder) => {
      const insertText = this._generateTableString(
        cellContents,
        hasHeader
      );
      const tableRange = this._tableRange();
      editBuilder.replace(tableRange, insertText);
    }, editOptions);
    if (curLineText.startsWith("+|")) {
      this.selectedCellPosition.column = 0;
    } else if (afterOperator || addLastColumn) {
      this.selectedCellPosition.column += 1;
    }
    this.selectCellContent(this.selectedCellPosition);
  }
  async removeColumn() {
    if (!this.tableLineNumbers) {
      return;
    }
    const cellContents = this._getCellContents();
    const hasHeader = this._hasHeader();
    const delColumnIndex = this.selectedCellPosition.column;
    for (let i = 0; i < cellContents.length; i++) {
      const rowContents = cellContents[i];
      rowContents.splice(delColumnIndex, 1);
    }
    const editOptions = { undoStopBefore: false, undoStopAfter: false };
    await this.editor.edit((editBuilder) => {
      const insertText = this._generateTableString(
        cellContents,
        hasHeader
      );
      const tableRange = this._tableRange();
      editBuilder.replace(tableRange, insertText);
    }, editOptions);
    const curColumn = this.selectedCellPosition.column;
    if (curColumn > 0) {
      this.selectedCellPosition.column -= 1;
    } else {
      this.selectedCellPosition.column = 0;
    }
    this.selectCellContent(this.selectedCellPosition);
  }
  async moveColumn(moveTo) {
    if (!this.tableLineNumbers) {
      return;
    }
    const numOfTimesToMove = this._getNumberOfTimesToMove(moveTo);
    const cellContents = this._getCellContents();
    const hasHeader = this._hasHeader();
    const column_from = this.selectedCellPosition.column;
    let column_to = column_from + numOfTimesToMove;
    if (column_to < 0) {
      column_to = 0;
    } else if (column_to > cellContents[0].length - 1) {
      column_to = cellContents[0].length - 1;
    }
    for (let i = 0; i < cellContents.length; i++) {
      const rowContents = cellContents[i];
      const moveColumnContent = rowContents[column_from];
      rowContents.splice(column_from, 1);
      rowContents.splice(column_to, 0, moveColumnContent);
    }
    const editOptions = { undoStopBefore: false, undoStopAfter: false };
    await this.editor.edit((editBuilder) => {
      const insertText = this._generateTableString(
        cellContents,
        hasHeader
      );
      const tableRange = this._tableRange();
      editBuilder.replace(tableRange, insertText);
    }, editOptions);
    this.selectedCellPosition.column = column_to;
    this.selectCellContent(this.selectedCellPosition);
  }
  _getNumberOfTimesToMove(moveTo) {
    let checkChar = "";
    if (moveTo === "top") {
      checkChar = "^";
    } else if (moveTo === "bottom") {
      checkChar = "v";
    } else if (moveTo === "right") {
      checkChar = ">";
    } else if (moveTo === "left") {
      checkChar = "<";
    }
    const curLine = this.editor.selection.start.line;
    const curLineCharList = this.editor.document.lineAt(curLine).text.split("");
    let curChar = this.editor.selection.start.character - 1;
    let numOfTimesToMove = 0;
    while (curChar >= 0) {
      if (checkChar !== curLineCharList[curChar]) {
        break;
      }
      numOfTimesToMove += 1;
      curChar -= 1;
    }
    if (moveTo === "right" || moveTo === "bottom") {
      return numOfTimesToMove;
    } else {
      return -numOfTimesToMove;
    }
  }
};

// src/editor/commands.ts
async function key_enter() {
  const editor = vscode11.window.activeTextEditor;
  if (!editor) {
    return;
  }
  if (tableIsSelected(editor)) {
    const prevTwoLetters = getTextAtOffsetPosition(
      editor.document,
      editor.selection.end,
      -2
    );
    const postLetter = getTextAtOffsetPosition(
      editor.document,
      editor.selection.end,
      1
    );
    const prevLetter = getTextAtOffsetPosition(
      editor.document,
      editor.selection.end,
      -1
    );
    const table = new TableEditor(editor);
    if (table.isSelectedFirstGrid()) {
      const curLine = editor.selection.start.line;
      const curLineFirstChar = editor.document.lineAt(curLine).range.start.character;
      const newPos = new vscode11.Position(curLine, curLineFirstChar);
      editor.selection = new vscode11.Selection(newPos, newPos);
      _addNewLine();
      return;
    } else if (table.isSelectedLastGrid()) {
      const curLine = editor.selection.end.line;
      const curLineLastChar = editor.document.lineAt(curLine).range.end.character;
      const newPos = new vscode11.Position(curLine, curLineLastChar);
      editor.selection = new vscode11.Selection(newPos, newPos);
      _addNewLine();
      return;
    }
    if (isSelectingLastChara() && prevLetter === "|") {
      table.addRow();
    } else if (prevTwoLetters === "|+" || prevLetter === "+" && postLetter === "|") {
      table.addColumn();
    } else if (prevTwoLetters === "|-" || prevLetter === "-" && postLetter === "|") {
      if (isSelectingLastChara()) {
        table.removeRow();
      } else {
        const regStartWithMinusSymbol = /^(-\|)/;
        const curLine = editor.selection.end.line;
        const curLineText = editor.document.lineAt(curLine).text;
        const startWithMatch = regStartWithMinusSymbol.exec(curLineText);
        if (startWithMatch) {
          table.removeRow();
        } else {
          table.removeColumn();
        }
      }
    } else if (prevTwoLetters === "|>" || prevTwoLetters === ">>" || prevLetter === ">" && postLetter === "|") {
      table.moveColumn("right");
    } else if (prevTwoLetters === "|<" || prevTwoLetters === "<<" || prevLetter === "<" && postLetter === "|") {
      table.moveColumn("left");
    } else if (prevTwoLetters === "|^" || prevTwoLetters === "^^" || prevLetter === "^" && postLetter === "|") {
      table.moveRow("top");
    } else if (prevTwoLetters === "|v" || prevTwoLetters === "vv" || prevLetter === "v" && postLetter === "|") {
      table.moveRow("bottom");
    } else {
      table.selectionChange("buttom");
    }
  } else if (listIsSelected(editor)) {
  }
}
async function key_shift_enter() {
  const editor = vscode11.window.activeTextEditor;
  if (!editor) {
    return;
  }
  if (tableIsSelected(editor)) {
    const table = new TableEditor(editor);
    table.selectionChange("top");
  } else if (listIsSelected(editor)) {
  }
}
async function key_alt_enter() {
  const editor = vscode11.window.activeTextEditor;
  if (!editor) {
    return;
  }
  if (tableIsSelected(editor) && !isSelectingLastChara()) {
    const table = new TableEditor(editor);
    table.addNewLine();
  }
}
async function key_tab() {
  const editor = vscode11.window.activeTextEditor;
  if (!editor) {
    return;
  }
  if (tableIsSelected(editor)) {
    const table = new TableEditor(editor);
    table.selectionChange("right");
  } else if (listIsSelected(editor)) {
    vscode11.commands.executeCommand("editor.action.triggerSuggest");
  } else if (listExistsOneLineAbove(editor)) {
    vscode11.commands.executeCommand("editor.action.triggerSuggest");
  } else {
    vscode11.commands.executeCommand("tab");
  }
}
async function key_shift_tab() {
  const editor = vscode11.window.activeTextEditor;
  if (!editor) {
    return;
  }
  if (tableIsSelected(editor)) {
    const table = new TableEditor(editor);
    table.selectionChange("left");
  } else if (listIsSelected(editor)) {
  } else {
    vscode11.commands.executeCommand("outdent");
  }
}
async function _addNewLine() {
  const editor = vscode11.window.activeTextEditor;
  if (!editor) {
    return;
  }
  const editOptions = { undoStopBefore: false, undoStopAfter: false };
  await editor.edit((editBuilder) => {
    const curPosition = editor.selection.end;
    editBuilder.insert(curPosition, "\n");
  }, editOptions);
}

// src/editor/link.ts
var import_node_fetch = __toESM(require_lib3());
var vscode12 = __toESM(require("vscode"));
var VSCodeInput = class {
  inputBox(label, placeholder, value) {
    return vscode12.window.showInputBox({
      prompt: label,
      placeHolder: placeholder,
      value
    });
  }
};
function getEOLSequence(eol) {
  switch (eol) {
    case vscode12.EndOfLine.LF:
      return "\n";
    case vscode12.EndOfLine.CRLF:
      return "\r\n";
  }
}
var _EditorCommands = class {
  constructor(userInput) {
    this.userInput = userInput;
    this.LINK_PATTERN = /\.\.[ ]_\S+:[ ]\S+\n/;
  }
  async insertLink(editor) {
    const link = await this.getLinkInfo(editor);
    if (!link.url || !link.label) {
      return;
    }
    const selection = editor.selection;
    const eol = getEOLSequence(editor.document.eol);
    const lastLine = editor.document.lineAt(editor.document.lineCount - 1);
    let lineText = editor.document.getText(
      lastLine.rangeIncludingLineBreak
    );
    let prefix = "";
    if (lineText.length === 0) {
      const line = editor.document.lineAt(editor.document.lineCount - 2);
      lineText = editor.document.getText(line.rangeIncludingLineBreak);
    } else {
      prefix = eol;
    }
    if (!this.LINK_PATTERN.test(lineText)) {
      prefix += eol;
    }
    const linkRef = `\`${link.label}\`_`;
    const linkDef = `${prefix}.. _${link.label}: ${link.url}${eol}`;
    await editor.edit((edit) => {
      edit.replace(selection, linkRef);
      edit.insert(lastLine.range.end, linkDef);
    });
    const position = editor.selection.end;
    editor.selection = new vscode12.Selection(position, position);
  }
  async insertInlineLink(editor) {
    const link = await this.getLinkInfo(editor);
    if (!link.url || !link.label) {
      return;
    }
    const selection = editor.selection;
    const inlineLink = `\`${link.label} <${link.url}>\`_`;
    await editor.edit((edit) => {
      edit.replace(selection, inlineLink);
    });
    const position = editor.selection.end;
    editor.selection = new vscode12.Selection(position, position);
  }
  register(context) {
    context.subscriptions.push(
      vscode12.commands.registerTextEditorCommand(
        _EditorCommands.INSERT_INLINE_LINK,
        this.insertInlineLink,
        this
      )
    );
    context.subscriptions.push(
      vscode12.commands.registerTextEditorCommand(
        _EditorCommands.INSERT_LINK,
        this.insertLink,
        this
      )
    );
  }
  async getLinkInfo(editor) {
    let label;
    const url = await this.userInput.inputBox("Link URL", "https://...");
    const parseTitle = (body) => {
      const match = body.match(/<title>([^<]*)<\/title>/);
      if (!match || typeof match[1] !== "string")
        throw new Error("Unable to parse the title tag");
      return match[1];
    };
    const title = await (0, import_node_fetch.default)(url).then((res) => res.text()).then((body) => parseTitle(body)).catch(() => null);
    const selection = editor.selection;
    if (selection.isEmpty) {
      label = await this.userInput.inputBox(
        "Link Text",
        "Link Text",
        title
      );
    } else {
      label = editor.document.getText(selection);
    }
    return { label, url };
  }
};
var EditorCommands = _EditorCommands;
EditorCommands.INSERT_LINK = "esbonio.insert.link";
EditorCommands.INSERT_INLINE_LINK = "esbonio.insert.inlineLink";

// src/editor/underline.ts
var vscode13 = __toESM(require("vscode"));
var meaw = __toESM(require_meaw_cjs());
var configuration = inversify_config_default.get(TYPES.Configuration);
var underlineChars = configuration.getAdornments();
function nextUnderlineChar(current, reverse = false) {
  const nextIndex = underlineChars.indexOf(current) + (reverse ? -1 : 1);
  const nextCharIndex = nextIndex >= 0 ? nextIndex % underlineChars.length : nextIndex + underlineChars.length;
  return underlineChars[nextCharIndex];
}
function currentUnderlineChar(currentLine, nextLine) {
  for (const char of underlineChars) {
    if (nextLine.length >= currentLine.length && nextLine === char.repeat(nextLine.length)) {
      return char;
    }
  }
  return null;
}
function underline(textEditor, edit, reverse = false) {
  textEditor.selections.forEach((selection) => {
    const position = selection.active;
    const line = textEditor.document.lineAt(position.line).text;
    if (line === "") {
      return;
    }
    let underlineChar = null;
    let nextLine = null;
    if (position.line < textEditor.document.lineCount - 1) {
      nextLine = textEditor.document.lineAt(position.line + 1).text;
      underlineChar = currentUnderlineChar(line, nextLine);
    }
    const lineWidth = underlineWidth(line);
    if (underlineChar === null) {
      edit.insert(
        new vscode13.Position(position.line, line.length),
        "\n" + "=".repeat(lineWidth)
      );
    } else {
      const nextLineRange = new vscode13.Range(
        new vscode13.Position(position.line + 1, 0),
        new vscode13.Position(position.line + 1, nextLine.length)
      );
      const replacement = nextUnderlineChar(underlineChar, reverse);
      edit.replace(nextLineRange, replacement.repeat(lineWidth));
    }
  });
}
function underlineWidth(line) {
  return meaw.computeWidth(line.normalize());
}

// src/editor/listEditing.ts
var import_vscode3 = require("vscode");
function activate(context) {
  context.subscriptions.push(
    import_vscode3.commands.registerCommand(
      "restructuredtext.editor.listEditing.onEnterKey",
      onEnterKey
    ),
    import_vscode3.commands.registerCommand(
      "restructuredtext.editor.listEditing.onCtrlEnterKey",
      () => {
        return onEnterKey("ctrl");
      }
    ),
    import_vscode3.commands.registerCommand(
      "restructuredtext.editor.listEditing.onShiftEnterKey",
      () => {
        return onEnterKey("shift");
      }
    ),
    import_vscode3.commands.registerCommand(
      "restructuredtext.editor.listEditing.onTabKey",
      onTabKey
    ),
    import_vscode3.commands.registerCommand(
      "restructuredtext.editor.listEditing.onShiftTabKey",
      () => {
        return onTabKey("shift");
      }
    ),
    import_vscode3.commands.registerCommand(
      "restructuredtext.editor.listEditing.onBackspaceKey",
      onBackspaceKey
    ),
    import_vscode3.commands.registerCommand(
      "restructuredtext.editor.listEditing.checkTaskList",
      checkTaskList
    ),
    import_vscode3.commands.registerCommand(
      "restructuredtext.editor.listEditing.onMoveLineDown",
      onMoveLineDown
    ),
    import_vscode3.commands.registerCommand(
      "restructuredtext.editor.listEditing.onMoveLineUp",
      onMoveLineUp
    ),
    import_vscode3.commands.registerCommand(
      "restructuredtext.editor.listEditing.onCopyLineDown",
      onCopyLineDown
    ),
    import_vscode3.commands.registerCommand(
      "restructuredtext.editor.listEditing.onCopyLineUp",
      onCopyLineUp
    ),
    import_vscode3.commands.registerCommand(
      "restructuredtext.editor.listEditing.onIndentLines",
      onIndentLines
    ),
    import_vscode3.commands.registerCommand(
      "restructuredtext.editor.listEditing.onOutdentLines",
      onOutdentLines
    )
  );
}
function onEnterKey(modifiers) {
  const editor = import_vscode3.window.activeTextEditor;
  const cursorPos = editor.selection.active;
  const line = editor.document.lineAt(cursorPos.line);
  const textBeforeCursor = line.text.substr(0, cursorPos.character);
  const textAfterCursor = line.text.substr(cursorPos.character);
  let lineBreakPos = cursorPos;
  if (modifiers === "ctrl") {
    lineBreakPos = line.range.end;
  }
  if (modifiers === "shift") {
    return asNormal("enter", modifiers);
  }
  const lineTextNoSpace = line.text.replace(/\s/g, "");
  if (lineTextNoSpace.length > 2 && (lineTextNoSpace.replace(/-/g, "").length === 0 || lineTextNoSpace.replace(/\*/g, "").length === 0)) {
    return asNormal("enter", modifiers);
  }
  if (/^(>|([-+*]|[0-9]+[.)]|#.)( +\[[ x]\])?)$/.test(
    textBeforeCursor.trim()
  ) && textAfterCursor.trim().length === 0) {
    return editor.edit((editBuilder) => {
      editBuilder.delete(line.range);
      editBuilder.insert(line.range.end, "\n");
    }).then(() => {
      editor.revealRange(editor.selection);
    }).then(() => fixMarker(findNextMarkerLineNumber()));
  }
  let matches;
  if (/^> /.test(textBeforeCursor)) {
    return editor.edit((editBuilder) => {
      editBuilder.insert(lineBreakPos, "\n> ");
    }).then(() => {
      if (modifiers === "ctrl" && !cursorPos.isEqual(lineBreakPos)) {
        const newCursorPos = cursorPos.with(line.lineNumber + 1, 2);
        editor.selection = new import_vscode3.Selection(
          newCursorPos,
          newCursorPos
        );
      }
    }).then(() => {
      editor.revealRange(editor.selection);
    });
  } else if ((matches = /^(\s*([-+*]|#.) +(\[[ x]\] +)?)/.exec(
    textBeforeCursor
  )) !== null) {
    return editor.edit((editBuilder) => {
      editBuilder.insert(
        lineBreakPos,
        `
${matches[1].replace("[x]", "[ ]")}`
      );
    }).then(() => {
      if (modifiers === "ctrl" && !cursorPos.isEqual(lineBreakPos)) {
        const newCursorPos = cursorPos.with(
          line.lineNumber + 1,
          matches[1].length
        );
        editor.selection = new import_vscode3.Selection(
          newCursorPos,
          newCursorPos
        );
      }
    }).then(() => {
      editor.revealRange(editor.selection);
    });
  } else if ((matches = /^(\s*)([0-9]+)([.)])( +)((\[[ x]\] +)?)/.exec(
    textBeforeCursor
  )) !== null) {
    const config = import_vscode3.workspace.getConfiguration("restructuredtext.editor.listEditing.orderedList").get("marker");
    let marker = "1";
    const leadingSpace = matches[1];
    const previousMarker = matches[2];
    const delimiter = matches[3];
    let trailingSpace = matches[4];
    const gfmCheckbox = matches[5].replace("[x]", "[ ]");
    const textIndent = (previousMarker + delimiter + trailingSpace).length;
    if (config === "ordered") {
      marker = String(Number(previousMarker) + 1);
    }
    trailingSpace = " ".repeat(
      Math.max(1, textIndent - (marker + delimiter).length)
    );
    const toBeAdded = leadingSpace + marker + delimiter + trailingSpace + gfmCheckbox;
    return editor.edit(
      (editBuilder) => {
        editBuilder.insert(lineBreakPos, `
${toBeAdded}`);
      },
      { undoStopBefore: true, undoStopAfter: false }
    ).then(() => {
      if (modifiers === "ctrl" && !cursorPos.isEqual(lineBreakPos)) {
        const newCursorPos = cursorPos.with(
          line.lineNumber + 1,
          toBeAdded.length
        );
        editor.selection = new import_vscode3.Selection(
          newCursorPos,
          newCursorPos
        );
      }
    }).then(() => fixMarker()).then(() => {
      editor.revealRange(editor.selection);
    });
  } else {
    return asNormal("enter", modifiers);
  }
}
function onTabKey(modifiers) {
  const editor = import_vscode3.window.activeTextEditor;
  const cursorPos = editor.selection.start;
  const lineText = editor.document.lineAt(cursorPos.line).text;
  const match = /^\s*([-+*]|[0-9]+[.)]|#.) +(\[[ x]\] +)?/.exec(lineText);
  if (match && (modifiers === "shift" || !editor.selection.isEmpty || editor.selection.isEmpty && cursorPos.character <= match[0].length)) {
    if (modifiers === "shift") {
      return outdent(editor).then(() => fixMarker());
    } else {
      return indent(editor).then(() => fixMarker());
    }
  } else {
    return asNormal("tab", modifiers);
  }
}
function onBackspaceKey() {
  const editor = import_vscode3.window.activeTextEditor;
  const cursor = editor.selection.active;
  const document2 = editor.document;
  const textBeforeCursor = document2.lineAt(cursor.line).text.substr(0, cursor.character);
  if (!editor.selection.isEmpty) {
    return asNormal("backspace").then(
      () => fixMarker(findNextMarkerLineNumber())
    );
  } else if (/^\s+([-+*]|[0-9]+[.)]) $/.test(textBeforeCursor)) {
    return outdent(editor).then(() => fixMarker());
  } else if (/^([-+*]|[0-9]+[.)]) $/.test(textBeforeCursor)) {
    return editor.edit((editBuilder) => {
      editBuilder.replace(
        new import_vscode3.Range(cursor.with({ character: 0 }), cursor),
        " ".repeat(textBeforeCursor.length)
      );
    }).then(() => fixMarker(findNextMarkerLineNumber()));
  } else if (/^\s*([-+*]|[0-9]+[.)]) +(\[[ x]\] )$/.test(textBeforeCursor)) {
    return deleteRange(
      editor,
      new import_vscode3.Range(
        cursor.with({ character: textBeforeCursor.length - 4 }),
        cursor
      )
    ).then(() => fixMarker(findNextMarkerLineNumber()));
  } else {
    return asNormal("backspace");
  }
}
function asNormal(key, modifiers) {
  switch (key) {
    case "enter":
      if (modifiers === "ctrl") {
        return import_vscode3.commands.executeCommand("editor.action.insertLineAfter");
      } else {
        return import_vscode3.commands.executeCommand("type", {
          source: "keyboard",
          text: "\n"
        });
      }
    case "tab":
      if (modifiers === "shift") {
        return import_vscode3.commands.executeCommand("editor.action.outdentLines");
      } else if (import_vscode3.window.activeTextEditor.selection.isEmpty && import_vscode3.workspace.getConfiguration("emmet").get("triggerExpansionOnTab")) {
        return import_vscode3.commands.executeCommand(
          "editor.emmet.action.expandAbbreviation"
        );
      } else {
        return import_vscode3.commands.executeCommand("tab");
      }
    case "backspace":
      return import_vscode3.commands.executeCommand("deleteLeft");
  }
}
function indent(editor) {
  if (!editor) {
    editor = import_vscode3.window.activeTextEditor;
  }
  if (import_vscode3.workspace.getConfiguration(
    "restructuredtext.editor.listEditing.list",
    editor.document.uri
  ).get("indentationSize") === "adaptive") {
    try {
      const selection = editor.selection;
      const indentationSize = tryDetermineIndentationSize(
        editor,
        selection.start.line,
        editor.document.lineAt(selection.start.line).firstNonWhitespaceCharacterIndex
      );
      const edit = new import_vscode3.WorkspaceEdit();
      for (let i = selection.start.line; i <= selection.end.line; i++) {
        if (i === selection.end.line && !selection.isEmpty && selection.end.character === 0) {
          break;
        }
        if (editor.document.lineAt(i).text.length !== 0) {
          edit.insert(
            editor.document.uri,
            new import_vscode3.Position(i, 0),
            " ".repeat(indentationSize)
          );
        }
      }
      return import_vscode3.workspace.applyEdit(edit);
    } catch (error) {
    }
  }
  return import_vscode3.commands.executeCommand("editor.action.indentLines");
}
function outdent(editor) {
  if (!editor) {
    editor = import_vscode3.window.activeTextEditor;
  }
  if (import_vscode3.workspace.getConfiguration(
    "restructuredtext.editor.listEditing.list",
    editor.document.uri
  ).get("indentationSize") === "adaptive") {
    try {
      const selection = editor.selection;
      const indentationSize = tryDetermineIndentationSize(
        editor,
        selection.start.line,
        editor.document.lineAt(selection.start.line).firstNonWhitespaceCharacterIndex
      );
      const edit = new import_vscode3.WorkspaceEdit();
      for (let i = selection.start.line; i <= selection.end.line; i++) {
        if (i === selection.end.line && !selection.isEmpty && selection.end.character === 0) {
          break;
        }
        const lineText = editor.document.lineAt(i).text;
        let maxOutdentSize;
        if (lineText.trim().length === 0) {
          maxOutdentSize = lineText.length;
        } else {
          maxOutdentSize = editor.document.lineAt(
            i
          ).firstNonWhitespaceCharacterIndex;
        }
        if (maxOutdentSize > 0) {
          edit.delete(
            editor.document.uri,
            new import_vscode3.Range(
              i,
              0,
              i,
              Math.min(indentationSize, maxOutdentSize)
            )
          );
        }
      }
      return import_vscode3.workspace.applyEdit(edit);
    } catch (error) {
    }
  }
  return import_vscode3.commands.executeCommand("editor.action.outdentLines");
}
function tryDetermineIndentationSize(editor, line, currentIndentation) {
  while (--line >= 0) {
    const lineText = editor.document.lineAt(line).text;
    let matches;
    if ((matches = /^(\s*)(([-+*]|[0-9]+[.)]) +)(\[[ x]\] +)?/.exec(
      lineText
    )) !== null) {
      if (matches[1].length <= currentIndentation) {
        return matches[2].length;
      }
    }
  }
  throw "No previous reStructuredText list item";
}
function findNextMarkerLineNumber(line) {
  const editor = import_vscode3.window.activeTextEditor;
  if (line === void 0) {
    line = editor.selection.start.line;
  }
  while (line < editor.document.lineCount) {
    const lineText = editor.document.lineAt(line).text;
    if (lineText.startsWith("#")) {
      return -1;
    }
    if (/^\s*[0-9]+[.)] +/.exec(lineText) !== null) {
      return line;
    }
    line++;
  }
  return void 0;
}
function lookUpwardForMarker(editor, line, currentIndentation) {
  while (--line >= 0) {
    const lineText = editor.document.lineAt(line).text;
    let matches;
    if ((matches = /^(\s*)(([0-9]+)[.)] +)/.exec(lineText)) !== null) {
      const leadingSpace = matches[1];
      const marker = matches[3];
      if (leadingSpace.length === currentIndentation) {
        return Number(marker) + 1;
      } else if (!leadingSpace.includes("	") && leadingSpace.length + matches[2].length <= currentIndentation || leadingSpace.includes("	") && leadingSpace.length + 1 <= currentIndentation) {
        return 1;
      }
    } else if ((matches = /^(\s*)\S/.exec(lineText)) !== null) {
      if (matches[1].length <= currentIndentation) {
        break;
      }
    }
  }
  return 1;
}
function fixMarker(line) {
  if (!import_vscode3.workspace.getConfiguration("restructuredtext.editor.listEditing.orderedList").get("autoRenumber"))
    return;
  if (import_vscode3.workspace.getConfiguration("restructuredtext.editor.listEditing.orderedList").get("marker") === "one")
    return;
  const editor = import_vscode3.window.activeTextEditor;
  if (line === void 0) {
    line = findNextMarkerLineNumber();
    if (line === void 0 || line > editor.selection.end.line) {
      line = editor.selection.active.line;
    }
  }
  if (line < 0 || editor.document.lineCount <= line) {
    return;
  }
  const currentLineText = editor.document.lineAt(line).text;
  let matches;
  if ((matches = /^(\s*)([0-9]+)([.)])( +)/.exec(currentLineText)) !== null) {
    const leadingSpace = matches[1];
    const marker = matches[2];
    const delimiter = matches[3];
    const trailingSpace = matches[4];
    const fixedMarker = lookUpwardForMarker(
      editor,
      line,
      leadingSpace.length
    );
    const listIndent = marker.length + delimiter.length + trailingSpace.length;
    let fixedMarkerString = String(fixedMarker);
    return editor.edit(
      (editBuilder) => {
        if (marker === fixedMarkerString) {
          return;
        }
        fixedMarkerString += delimiter + " ".repeat(
          Math.max(
            1,
            listIndent - (fixedMarkerString + delimiter).length
          )
        );
        editBuilder.replace(
          new import_vscode3.Range(
            line,
            leadingSpace.length,
            line,
            leadingSpace.length + listIndent
          ),
          fixedMarkerString
        );
      },
      { undoStopBefore: false, undoStopAfter: false }
    ).then(() => {
      let nextLine = line + 1;
      const indentString = " ".repeat(listIndent);
      while (editor.document.lineCount > nextLine) {
        const nextLineText = editor.document.lineAt(nextLine).text;
        if (/^\s*[0-9]+[.)] +/.test(nextLineText)) {
          return fixMarker(nextLine);
        } else if (/^\s*$/.test(nextLineText)) {
          nextLine++;
        } else if (listIndent <= 4 && !nextLineText.startsWith(indentString)) {
          return;
        } else {
          nextLine++;
        }
      }
    });
  }
}
function deleteRange(editor, range) {
  return editor.edit(
    (editBuilder) => {
      editBuilder.delete(range);
    },
    { undoStopBefore: true, undoStopAfter: false }
  );
}
function checkTaskList() {
  const editor = import_vscode3.window.activeTextEditor;
  const uncheckedRegex = /^(\s*([-+*]|[0-9]+[.)]) +\[) \]/;
  const checkedRegex = /^(\s*([-+*]|[0-9]+[.)]) +\[)x\]/;
  const toBeToggled = [];
  let newState = void 0;
  for (const selection of editor.selections) {
    for (let i = selection.start.line; i <= selection.end.line; i++) {
      const line = editor.document.lineAt(i);
      const lineStart = line.range.start;
      if (!selection.isSingleLine && (selection.start.isEqual(line.range.end) || selection.end.isEqual(line.range.start))) {
        continue;
      }
      let matches;
      if ((matches = uncheckedRegex.exec(line.text)) && newState !== false) {
        toBeToggled.push(
          lineStart.with({ character: matches[1].length })
        );
        newState = true;
      } else if ((matches = checkedRegex.exec(line.text)) && newState !== true) {
        toBeToggled.push(
          lineStart.with({ character: matches[1].length })
        );
        newState = false;
      }
    }
  }
  if (newState !== void 0) {
    const newChar = newState ? "x" : " ";
    return editor.edit((editBuilder) => {
      for (const pos of toBeToggled) {
        const range = new import_vscode3.Range(
          pos,
          pos.with({ character: pos.character + 1 })
        );
        editBuilder.replace(range, newChar);
      }
    });
  }
}
function onMoveLineUp() {
  return import_vscode3.commands.executeCommand("editor.action.moveLinesUpAction").then(() => fixMarker());
}
function onMoveLineDown() {
  return import_vscode3.commands.executeCommand("editor.action.moveLinesDownAction").then(
    () => fixMarker(
      findNextMarkerLineNumber(
        import_vscode3.window.activeTextEditor.selection.start.line - 1
      )
    )
  );
}
function onCopyLineUp() {
  return import_vscode3.commands.executeCommand("editor.action.copyLinesUpAction").then(() => fixMarker());
}
function onCopyLineDown() {
  return import_vscode3.commands.executeCommand("editor.action.copyLinesDownAction").then(() => fixMarker());
}
function onIndentLines() {
  return indent().then(() => fixMarker());
}
function onOutdentLines() {
  return outdent().then(() => fixMarker());
}

// src/editor/setContext.ts
var vscode14 = __toESM(require("vscode"));
async function setContext() {
  const configuration2 = inversify_config_default.get(TYPES.Configuration);
  if (configuration2.getTableEditorDisabled()) {
    return;
  }
  const editor = vscode14.window.activeTextEditor;
  if (editor) {
    vscode14.commands.executeCommand(
      "setContext",
      "resttext.editor.opening",
      true
    );
  } else {
    vscode14.commands.executeCommand(
      "setContext",
      "resttext.editor.opening",
      false
    );
    return;
  }
  const tableSizeIsSelected2 = tableSizeIsSelected(editor);
  if (tableSizeIsSelected2) {
    vscode14.commands.executeCommand(
      "setContext",
      "resttext.createGrid.enabled",
      true
    );
  } else {
    vscode14.commands.executeCommand(
      "setContext",
      "resttext.createGrid.enabled",
      false
    );
  }
  const tableIsSelected2 = tableIsSelected(editor);
  const listExistsOneLineAbove2 = listExistsOneLineAbove(editor);
  if (tableIsSelected2) {
    vscode14.commands.executeCommand(
      "setContext",
      "resttext.enter.enabled",
      true
    );
    vscode14.commands.executeCommand(
      "setContext",
      "resttext.shift.enter.enabled",
      true
    );
  } else {
    vscode14.commands.executeCommand(
      "setContext",
      "resttext.enter.enabled",
      false
    );
    vscode14.commands.executeCommand(
      "setContext",
      "resttext.shift.enter.enabled",
      false
    );
  }
  const selectedLastChara = isSelectingLastChara();
  if (tableIsSelected2 && !selectedLastChara) {
    vscode14.commands.executeCommand(
      "setContext",
      "resttext.alt.enter.enabled",
      true
    );
  } else {
    vscode14.commands.executeCommand(
      "setContext",
      "resttext.alt.enter.enabled",
      false
    );
  }
  if (tableIsSelected2 || listExistsOneLineAbove2) {
    vscode14.commands.executeCommand(
      "setContext",
      "resttext.tab.enabled",
      true
    );
  } else {
    vscode14.commands.executeCommand(
      "setContext",
      "resttext.tab.enabled",
      false
    );
  }
  if (tableIsSelected2) {
    vscode14.commands.executeCommand(
      "setContext",
      "resttext.shift.tab.enabled",
      true
    );
  } else {
    vscode14.commands.executeCommand(
      "setContext",
      "resttext.shift.tab.enabled",
      false
    );
  }
}

// src/editor/extension.ts
async function activate2(context) {
  setContext();
  vscode15.workspace.onDidCloseTextDocument(() => {
    setContext();
  });
  vscode15.window.onDidChangeActiveTextEditor(() => {
    setContext();
  });
  vscode15.window.onDidChangeTextEditorSelection(() => {
    setContext();
  });
  const editorCommands = new EditorCommands(new VSCodeInput());
  editorCommands.register(context);
  context.subscriptions.push(
    vscode15.commands.registerTextEditorCommand(
      "restructuredtext.features.underline.underline",
      underline
    ),
    vscode15.commands.registerTextEditorCommand(
      "restructuredtext.features.underline.underlineReverse",
      (textEditor, edit) => underline(textEditor, edit, true)
    )
  );
  context.subscriptions.push(
    vscode15.commands.registerCommand("resttext.table.createGrid", () => {
      const editor = vscode15.window.activeTextEditor;
      if (!editor) {
        return;
      }
      const table = new TableEditor(editor);
      table.createEmptyGrid();
    })
  );
  context.subscriptions.push(
    vscode15.commands.registerCommand("resttext.table.dataToTable", () => {
      const editor = vscode15.window.activeTextEditor;
      if (!editor) {
        return;
      }
      const table = new TableEditor(editor);
      table.dataToTable();
    })
  );
  context.subscriptions.push(
    vscode15.commands.registerCommand("resttext.key.enter", () => {
      key_enter();
    })
  );
  context.subscriptions.push(
    vscode15.commands.registerCommand("resttext.key.shift.enter", () => {
      key_shift_enter();
    })
  );
  context.subscriptions.push(
    vscode15.commands.registerCommand("resttext.key.alt.enter", () => {
      key_alt_enter();
    })
  );
  context.subscriptions.push(
    vscode15.commands.registerCommand("resttext.key.tab", () => {
      key_tab();
    })
  );
  context.subscriptions.push(
    vscode15.commands.registerCommand("resttext.key.shift.tab", () => {
      key_shift_tab();
    })
  );
  activate(context);
}

// src/linter/rstLinter.ts
var import_vscode4 = require("vscode");

// src/linter/lintingProvider.ts
var cp = __toESM(require("child_process"));
var vscode16 = __toESM(require("vscode"));

// src/util/async.ts
var Throttler = class {
  constructor() {
    this.activePromise = null;
    this.queuedPromise = null;
    this.queuedPromiseFactory = null;
  }
  queue(promiseFactory) {
    if (this.activePromise) {
      this.queuedPromiseFactory = promiseFactory;
      if (!this.queuedPromise) {
        const onComplete = () => {
          this.queuedPromise = null;
          const result = this.queue(this.queuedPromiseFactory);
          this.queuedPromiseFactory = null;
          return result;
        };
        this.queuedPromise = new Promise((resolve) => {
          this.activePromise.then(onComplete, onComplete).then(resolve);
        });
      }
      return new Promise((resolve, reject) => {
        this.queuedPromise.then(resolve, reject);
      });
    }
    this.activePromise = promiseFactory();
    return new Promise((resolve, reject) => {
      this.activePromise.then(
        (result) => {
          this.activePromise = null;
          resolve(result);
        },
        (err) => {
          this.activePromise = null;
          reject(err);
        }
      );
    });
  }
};
var Delayer = class {
  constructor(defaultDelay) {
    this.defaultDelay = defaultDelay;
    this.timeout = null;
    this.completionPromise = null;
    this.onResolve = null;
    this.task = null;
  }
  trigger(task, delay = this.defaultDelay) {
    this.task = task;
    this.cancelTimeout();
    if (!this.completionPromise) {
      this.completionPromise = new Promise((resolve) => {
        this.onResolve = resolve;
      }).then(() => {
        this.completionPromise = null;
        this.onResolve = null;
        const result = this.task();
        this.task = null;
        return result;
      });
    }
    this.timeout = setTimeout(() => {
      this.timeout = null;
      this.onResolve(null);
    }, delay);
    return this.completionPromise;
  }
  isTriggered() {
    return this.timeout !== null;
  }
  cancel() {
    this.cancelTimeout();
    if (this.completionPromise) {
      this.completionPromise = null;
    }
  }
  cancelTimeout() {
    if (this.timeout !== null) {
      clearTimeout(this.timeout);
      this.timeout = null;
    }
  }
};
var ThrottledDelayer = class extends Delayer {
  constructor(defaultDelay) {
    super(defaultDelay);
    this.throttler = new Throttler();
  }
  trigger(promiseFactory, delay) {
    return super.trigger(() => this.throttler.queue(promiseFactory), delay);
  }
};

// src/util/lineDecoder.ts
var import_string_decoder = require("string_decoder");
var LineDecoder = class {
  constructor(encoding = "utf8") {
    const input = encoding;
    this.stringDecoder = new import_string_decoder.StringDecoder(input);
    this.remaining = null;
    this.lines = [];
  }
  write(buffer) {
    const result = [];
    const value = this.remaining ? this.remaining + this.stringDecoder.write(buffer) : this.stringDecoder.write(buffer);
    if (value.length < 1) {
      this.lines = this.lines.concat(value);
      return result;
    }
    let start = 0;
    let ch;
    while (start < value.length && ((ch = value.charCodeAt(start)) === 13 || ch === 10)) {
      start++;
    }
    let idx = start;
    while (idx < value.length) {
      ch = value.charCodeAt(idx);
      if (ch === 13 || ch === 10) {
        result.push(value.substring(start, idx));
        idx++;
        while (idx < value.length && ((ch = value.charCodeAt(idx)) === 13 || ch === 10)) {
          idx++;
        }
        start = idx;
      } else {
        idx++;
      }
    }
    this.remaining = start < value.length ? value.substr(start) : null;
    this.lines = this.lines.concat(result);
    return result;
  }
  end() {
    if (this.remaining && this.remaining.length > 0) {
      this.lines = this.lines.concat(this.remaining);
    }
    return this.remaining;
  }
  getLines() {
    return this.lines;
  }
};

// src/linter/lintingProvider.ts
var RunTrigger = /* @__PURE__ */ ((RunTrigger2) => {
  RunTrigger2[RunTrigger2["onSave"] = 0] = "onSave";
  RunTrigger2[RunTrigger2["onType"] = 1] = "onType";
  RunTrigger2[RunTrigger2["off"] = 2] = "off";
  return RunTrigger2;
})(RunTrigger || {});
((RunTrigger2) => {
  RunTrigger2.strings = {
    off: "off",
    onSave: "onSave",
    onType: "onType"
  };
  RunTrigger2.from = (value) => {
    if (value === "onType") {
      return 1 /* onType */;
    } else if (value === "onSave") {
      return 0 /* onSave */;
    } else {
      return 2 /* off */;
    }
  };
})(RunTrigger || (RunTrigger = {}));
var LintingProvider = class {
  constructor(linter, logger, python) {
    this.linter = linter;
    this.logger = logger;
    this.python = python;
    this.executableNotFound = false;
  }
  activate(subscriptions) {
    this.diagnosticCollection = vscode16.languages.createDiagnosticCollection();
    subscriptions.push(this);
    vscode16.workspace.onDidChangeConfiguration(
      this.resetConfiguration,
      this,
      subscriptions
    );
    vscode16.workspace.onDidSaveTextDocument(
      (textDocument) => {
        if (textDocument.fileName.endsWith("settings.json")) {
          this.resetConfiguration();
        }
      },
      null,
      subscriptions
    );
    this.resetConfiguration();
    vscode16.workspace.onDidOpenTextDocument(
      this.triggerLint,
      this,
      subscriptions
    );
    vscode16.workspace.onDidCloseTextDocument(
      (textDocument) => {
        this.diagnosticCollection.delete(textDocument.uri);
        delete this.delayers[textDocument.uri.toString()];
      },
      null,
      subscriptions
    );
  }
  dispose() {
    this.diagnosticCollection.clear();
    this.diagnosticCollection.dispose();
  }
  resetConfiguration() {
    this.linterConfiguration = null;
    vscode16.workspace.textDocuments.forEach(this.triggerLint, this);
  }
  async loadConfiguration(resource) {
    const oldExecutable = this.linterConfiguration && this.linterConfiguration.executable;
    this.linterConfiguration = await this.linter.loadConfiguration(
      resource
    );
    this.delayers = /* @__PURE__ */ Object.create(null);
    if (this.executableNotFound) {
      this.executableNotFound = oldExecutable === this.linterConfiguration.executable;
    }
    if (this.documentListener) {
      this.documentListener.dispose();
    }
    if (RunTrigger.from(this.linterConfiguration.runTrigger) === 1 /* onType */) {
      this.documentListener = vscode16.workspace.onDidChangeTextDocument(
        (e) => {
          this.triggerLint(e.document);
        }
      );
    } else {
      this.documentListener = vscode16.workspace.onDidSaveTextDocument(
        this.triggerLint,
        this
      );
    }
    this.documentListener = vscode16.workspace.onDidSaveTextDocument(
      this.triggerLint,
      this
    );
  }
  async triggerLint(textDocument) {
    const configuration2 = inversify_config_default.get(TYPES.Configuration);
    const currentFolder = configuration2.getRootPath(textDocument.uri);
    if (this.linterConfiguration === null || currentFolder && this.linterConfiguration.rootPath !== currentFolder) {
      await this.loadConfiguration(textDocument.uri);
    }
    if (textDocument.languageId !== this.linter.languageId || textDocument.uri.scheme !== "file" || this.executableNotFound || RunTrigger.from(this.linterConfiguration.runTrigger) === 2 /* off */) {
      return;
    }
    const key = textDocument.uri.toString();
    let delayer = this.delayers[key];
    if (!delayer) {
      delayer = new ThrottledDelayer(
        RunTrigger.from(this.linterConfiguration.runTrigger) === 1 /* onType */ ? 250 : 0
      );
      this.delayers[key] = delayer;
    }
    delayer.trigger(() => this.doLint(textDocument));
  }
  async doLint(textDocument) {
    if (!await this.python.checkPython(textDocument.uri, false)) {
      return;
    }
    return new Promise((resolve) => {
      const configuration2 = inversify_config_default.get(
        TYPES.Configuration
      );
      const executable = this.linterConfiguration.executable;
      const decoder = new LineDecoder();
      let diagnostics = [];
      const file = '"' + textDocument.fileName + '"';
      const rootPath = configuration2.getRootPath(textDocument.uri);
      const options = rootPath ? { rootPath, shell: true } : void 0;
      let args = [];
      args = args.concat(this.linterConfiguration.module);
      if (RunTrigger.from(this.linterConfiguration.runTrigger) === 0 /* onSave */) {
        args = args.concat(this.linterConfiguration.fileArgs.slice(0));
        args.push(file);
      } else {
        args.push(file);
      }
      args = args.concat(this.linterConfiguration.extraArgs);
      const childProcess = cp.spawn(executable, args, options);
      this.logger.log(
        `[linter] Execute: ${executable} ${args.join(
          " "
        )} in ${rootPath}.`
      );
      childProcess.on("error", (error) => {
        if (this.executableNotFound) {
          resolve();
          return;
        }
        let message = null;
        if (error.code === "ENOENT") {
          message = `Cannot lint ${textDocument.fileName}. The executable '${executable}' was not found. Use the '${this.linter.languageId}.linter.executablePath' setting to configure the location of the executable`;
        } else {
          message = error.message ? error.message : `Failed to run executable using path: ${executable}. Reason is unknown.`;
        }
        this.logger.log(`[linter] ${message}`);
        vscode16.window.showInformationMessage(message);
        this.executableNotFound = true;
        resolve();
      });
      const onDataEvent = (data) => {
        decoder.write(data);
      };
      const onEndEvent = () => {
        decoder.end();
        const lines = decoder.getLines();
        if (lines && lines.length > 0) {
          diagnostics = this.linter.process(lines);
        }
        this.diagnosticCollection.set(textDocument.uri, diagnostics);
        resolve();
      };
      if (childProcess.pid) {
        if (RunTrigger.from(this.linterConfiguration.runTrigger) === 1 /* onType */) {
          childProcess.stdin.write(textDocument.getText());
          childProcess.stdin.end();
        }
        childProcess.stderr.on("data", onDataEvent);
        childProcess.stderr.on("end", onEndEvent);
        childProcess.stdout.on("data", onDataEvent);
        childProcess.stdout.on("end", onEndEvent);
      } else {
        resolve();
      }
    });
  }
};

// src/linter/rstLinter.ts
var RstLintingProvider = class {
  constructor(name, module2, path3, extraArgs, logger, python) {
    this.name = name;
    this.module = module2;
    this.path = path3;
    this.extraArgs = extraArgs;
    this.logger = logger;
    this.python = python;
    this.languageId = "restructuredtext";
  }
  activate(subscriptions) {
    const provider = new LintingProvider(this, this.logger, this.python);
    provider.activate(subscriptions);
  }
  async loadConfiguration(resource) {
    let module2 = [];
    const configuration2 = inversify_config_default.get(TYPES.Configuration);
    let build = this.path;
    if (build === null) {
      const python = await configuration2.getPythonPath(resource);
      if (python) {
        build = '"' + python + '"';
        module2 = module2.concat(["-m", this.module]);
      }
    } else {
      build = '"' + build + '"';
    }
    if (build === null) {
      build = this.name;
    }
    return {
      executable: build,
      module: module2,
      fileArgs: [],
      bufferArgs: [],
      extraArgs: this.extraArgs.map(
        (value) => configuration2.expandMacro(value, resource)
      ),
      runTrigger: configuration2.getRunType(resource),
      rootPath: configuration2.getRootPath(resource)
    };
  }
  process(contents) {
    const diagnostics = [];
    for (const text of contents) {
      if (text.includes("No module named") || text.includes("Errno")) {
        diagnostics.push({
          range: new import_vscode4.Range(0, 0, 0, Number.MAX_VALUE),
          severity: import_vscode4.DiagnosticSeverity.Warning,
          message: text,
          code: null,
          source: this.name
        });
        continue;
      }
      const regex = /(([A-Z]+)\s+)?(.+?):([0-9]+):?\s(([A-Z0-9]+)\s)?(\(([A-Z]+)\/[0-9]+\)\s)?(.+)/;
      const matches = regex.exec(text);
      if (matches === null) {
        continue;
      }
      const severity1 = matches[2];
      const file = matches[3];
      const line = matches[4];
      const code = matches[6];
      const severity2 = matches[8];
      const message = matches[9];
      if (file.endsWith(".py") && this.name === "doc8") {
        continue;
      }
      const lineNumber = parseInt(line, 10) - 1;
      diagnostics.push({
        range: new import_vscode4.Range(lineNumber, 0, lineNumber, Number.MAX_VALUE),
        severity: import_vscode4.DiagnosticSeverity.Warning,
        message,
        code: severity1 ?? severity2 ?? code,
        source: this.name
      });
    }
    return diagnostics;
  }
};

// src/linter/extension.ts
async function activate3(context, python, logger) {
  let rstlintToDisable = false;
  const configuration2 = inversify_config_default.get(TYPES.Configuration);
  const disabled = configuration2.getLinterDisabled();
  if (disabled.indexOf("doc8") === -1) {
    const doc8Path = configuration2.getDoc8Path();
    if (doc8Path || await python.checkDoc8Install()) {
      const doc8 = new RstLintingProvider(
        "doc8",
        "doc8.main",
        doc8Path,
        configuration2.getDoc8ExtraArgs(),
        logger,
        python
      );
      doc8.activate(context.subscriptions);
      rstlintToDisable = true;
      logger.log("Enabled doc8 linting...");
    }
  }
  if (disabled.indexOf("rstcheck") === -1) {
    const rstcheckPath = configuration2.getRstCheckPath();
    if (rstcheckPath || await python.checkRstCheckInstall()) {
      const rstcheck = new RstLintingProvider(
        "rstcheck",
        "rstcheck",
        rstcheckPath,
        configuration2.getRstCheckExtraArgs(),
        logger,
        python
      );
      rstcheck.activate(context.subscriptions);
      logger.log("Enabled rstcheck linting...");
    }
  }
  if (disabled.indexOf("rst-lint") === -1 && !rstlintToDisable) {
    const rstlintPath = configuration2.getRstLintPath();
    if (rstlintPath || await python.checkRstLintInstall()) {
      const rstlint = new RstLintingProvider(
        "rst-lint",
        "restructuredtext_lint.cli",
        rstlintPath,
        configuration2.getRstLintExtraArgs(),
        logger,
        python
      );
      rstlint.activate(context.subscriptions);
      logger.log("Enabled rst-lint linting...");
    }
  }
}

// src/rating.ts
var vscode17 = require("vscode");
async function updateActivationCount(context) {
  let activationCount = context.globalState.get("activationCount") || 0;
  activationCount++;
  await context.globalState.update("activationCount", activationCount);
  await promptForRating(context, activationCount);
}
async function promptForRating(context, activationCount) {
  if (isRatingProvided(context)) {
    return;
  }
  if (activationCount % 20 === 0) {
    const rateButton = "Rate Extension";
    const response = await vscode17.window.showInformationMessage(
      "You have used this extension for a while. Would you like to rate it in Visual Studio Code Marketplace?",
      rateButton
    );
    if (response === rateButton) {
      const extensionId = encodeURIComponent(context.extension.id);
      const marketplaceUrl = `https://marketplace.visualstudio.com/items?itemName=${extensionId}&ssr=false#review-details`;
      vscode17.env.openExternal(vscode17.Uri.parse(marketplaceUrl));
      setRatingProvided(context);
    }
  }
}
function isRatingProvided(context) {
  const ratingProvided = context.globalState.get("ratingProvided");
  return ratingProvided || false;
}
function setRatingProvided(context) {
  context.globalState.update("ratingProvided", true);
}

// src/extension.ts
var extensionPath = "";
function getExtensionPath() {
  return extensionPath;
}
async function activate4(context) {
  setGlobalState(context.globalState);
  setWorkspaceState(context.workspaceState);
  await initConfig(context);
  extensionPath = context.extensionPath;
  const logger = inversify_config_default.getNamed(TYPES.Logger, NAMES.Main);
  logger.log(
    "Please visit https://docs.restructuredtext.net to learn how to configure the extension."
  );
  const configuration2 = inversify_config_default.get(TYPES.Configuration);
  const conflicting = configuration2.getConflictingExtensions();
  for (const element of conflicting) {
    const found = vscode18.extensions.getExtension(element);
    if (found) {
      const message = `Found conflicting extension ${found.packageJSON.displayName}(${element}). Do you want to uninstall it now?`;
      logger.log(`found ${element}`);
      const choice = await vscode18.window.showErrorMessage(
        message,
        "Yes",
        "No"
      );
      if (choice === "Yes") {
        await vscode18.commands.executeCommand(
          Commands.OPEN_EXTENSION,
          element
        );
        await vscode18.commands.executeCommand(
          Commands.UNINSTALL_EXTENSION,
          element
        );
        await vscode18.commands.executeCommand(Commands.RELOAD_WINDOW);
      } else {
        vscode18.window.showWarningMessage(
          "Since conflicting extension is not uninstalled, extension activation ends now."
        );
        return;
      }
    }
  }
  const recommended = configuration2.getRecommendedExtensions();
  for (const element of recommended) {
    const found = vscode18.extensions.getExtension(element);
    if (!found && !configuration2.getPythonRecommendationDisabled()) {
      const message = `This extension depends on ${element}. Do you want to install it now?`;
      const choice = await vscode18.window.showInformationMessage(
        message,
        "Install",
        "Not now",
        "Do not show again"
      );
      if (choice === "Install") {
        logger.log(`Started to install ${element}..`);
        await vscode18.commands.executeCommand(
          Commands.OPEN_EXTENSION,
          element
        );
        if (element === "swyddfa.esbonio") {
          await vscode18.commands.executeCommand(
            Commands.INSTALL_EXTENSION,
            element,
            { installPreReleaseVersion: true }
          );
        } else {
          await vscode18.commands.executeCommand(
            Commands.INSTALL_EXTENSION,
            element
          );
        }
      } else if (choice === "Do not show again") {
        logger.log("Disabled missing dependency prompt.");
        await configuration2.setPythonRecommendationDisabled();
      }
    }
  }
  const minor = require_minor();
  const minorVersion = minor(context.extension.packageJSON.version);
  if (minorVersion % 2 !== 0) {
    vscode18.window.showInformationMessage(
      "Rollbar logging is enabled in preview release. Switch to a stable release to disable it."
    );
    await logger.logPlatform(context.extension.packageJSON.version);
  }
  const python = inversify_config_default.get(TYPES.Python);
  await python.setup();
  await activate2(context);
  await activate3(context, python, logger);
  const commandManager = new CommandManager();
  context.subscriptions.push(commandManager);
  commandManager.register(new MoveCursorToPositionCommand());
  commandManager.register(new OpenDocumentLinkCommand());
  context.subscriptions.push(
    vscode18.workspace.onDidChangeConfiguration(() => {
      logger.updateConfiguration();
    })
  );
  await updateActivationCount(context);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate,
  getExtensionPath
});
/*!
 * is.js 0.8.0
 * Author: Aras Atasaygin
 */
/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
//# sourceMappingURL=extension.js.map
